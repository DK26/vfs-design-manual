<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AnyFS Ecosystem Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for AnyFS: pluggable virtual filesystem backends + container layer for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-ea1e7c9c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-060c2755.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">AnyFS Ecosystem Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/anyfs-design-manual" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="anyfs-ecosystem"><a class="header" href="#anyfs-ecosystem">AnyFS Ecosystem</a></h1>
<p><strong>An open standard for pluggable virtual filesystem backends in Rust.</strong></p>
<hr>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>AnyFS is an <strong>open standard</strong> for virtual filesystem backends using a <strong>Tower-style middleware pattern</strong> for composable functionality.</p>
<p>You get:</p>
<ul>
<li>A familiar <code>std::fs</code>-aligned API</li>
<li>Composable middleware (limits, logging, security)</li>
<li>Choice of storage: memory, SQLite, host filesystem, or custom</li>
<li>A developer-first goal: make storage composition easy, safe, and enjoyable</li>
</ul>
<hr>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage&lt;B, R, M&gt;                   │  ← Ergonomics + type-safe marker
├─────────────────────────────────────────┤
│  Middleware (composable):               │
│    Quota&lt;B&gt;                             │  ← Quotas
│    Restrictions&lt;B&gt;                      │  ← Security
│    Tracing&lt;B&gt;                           │  ← Audit
├─────────────────────────────────────────┤
│  Fs                             │  ← Storage
│  (Memory, SQLite, VRootFs, custom...)   │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Each layer has one job.</strong> Compose only what you need.</p>
<hr>
<h2 id="two-crate-structure"><a class="header" href="#two-crate-structure">Two-Crate Structure</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>Fs</code> trait + types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + mounting + ergonomic <code>FileStorage&lt;B, R, M&gt;</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> Mounting (<code>FsFuse</code> + <code>MountHandle</code>) is part of the <code>anyfs</code> crate behind feature flags (<code>fuse</code>, <code>winfsp</code>), not a separate crate.</p>
<hr>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, FileStorage};

// Layer-based composition
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_permissions()
        .build());

let fs = FileStorage::new(backend);

fs.create_dir_all("/data")?;
fs.write("/data/file.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="how-to-use-this-manual"><a class="header" href="#how-to-use-this-manual">How to Use This Manual</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Section</th><th>Audience</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Overview</td><td>Stakeholders</td><td>One-page understanding</td></tr>
<tr><td>Getting Started</td><td>Developers</td><td>Practical examples</td></tr>
<tr><td>Design &amp; Architecture</td><td>Contributors</td><td>Detailed design</td></tr>
<tr><td>Traits &amp; APIs</td><td>Backend authors</td><td>Contract and types</td></tr>
<tr><td>Implementation</td><td>Implementers</td><td>Plan + backend guide</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="future-considerations"><a class="header" href="#future-considerations">Future Considerations</a></h2>
<p>These are optional extensions that fit the design but are out of scope for initial release:</p>
<ul>
<li>URL-based backend registry and bulk helpers (<code>FsExt</code>/utilities)</li>
<li>Async adapter for remote backends</li>
<li>Companion shell for interactive exploration</li>
<li>Copy-on-write overlay and archive backends (zip/tar)</li>
</ul>
<p>See <a href="#future-considerations-1">Design Overview</a> for the full list and rationale.</p>
<hr>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started (mounting roadmap defined)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="authoritative-documents"><a class="header" href="#authoritative-documents">Authoritative Documents</a></h2>
<ol>
<li><code>AGENTS.md</code> (for AI assistants)</li>
<li><code>src/architecture/design-overview.md</code></li>
<li><code>src/architecture/adrs.md</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---executive-summary"><a class="header" href="#anyfs---executive-summary">AnyFS - Executive Summary</a></h1>
<p>One-page overview for stakeholders and decision-makers.</p>
<hr>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust, using a <strong>Tower-style middleware pattern</strong> for composable functionality.</p>
<p>You get:</p>
<ul>
<li>A familiar <code>std::fs</code>-aligned API</li>
<li>Composable middleware for limits, logging, and security</li>
<li>Choice of storage: memory, SQLite, host filesystem, or custom</li>
</ul>
<hr>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage&lt;B, R, M&gt;                │  ← Ergonomics (std::fs API)
├─────────────────────────────────────────┤
│  Middleware (composable):               │
│    Quota&lt;B&gt;                    │  ← Quotas
│    Restrictions&lt;B&gt;               │  ← Security
│    Tracing&lt;B&gt;                    │  ← Audit
├─────────────────────────────────────────┤
│  Fs                             │  ← Storage
└─────────────────────────────────────────┘
</code></pre>
<hr>
<h2 id="why-does-it-matter"><a class="header" href="#why-does-it-matter">Why does it matter?</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Problem</th><th>How AnyFS helps</th></tr>
</thead>
<tbody>
<tr><td>Multi-tenant isolation</td><td>Separate backend instances per tenant</td></tr>
<tr><td>Portability</td><td>SQLite backend: tenant data = single <code>.db</code> file</td></tr>
<tr><td>Security</td><td>Restrictions blocks risky operations when composed</td></tr>
<tr><td>Resource control</td><td>Quota enforces quotas</td></tr>
<tr><td>Audit compliance</td><td>Tracing records all operations</td></tr>
<tr><td>Custom storage</td><td>Implement Fs for any medium</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="key-design-points"><a class="header" href="#key-design-points">Key design points</a></h2>
<ul>
<li>
<p><strong>Two-crate structure</strong></p>
<ul>
<li><code>anyfs-backend</code>: trait contract</li>
<li><code>anyfs</code>: backends + middleware + ergonomic wrapper</li>
</ul>
</li>
<li>
<p><strong>Middleware pattern</strong> (like Axum/Tower)</p>
<ul>
<li>Each middleware has one job</li>
<li>Compose only what you need</li>
<li>Complete separation of concerns</li>
</ul>
</li>
<li>
<p><strong>std::fs alignment</strong></p>
<ul>
<li>Familiar method names</li>
<li>Core traits use <code>&amp;Path</code>; <code>FileStorage</code>/<code>FsExt</code> accept <code>impl AsRef&lt;Path&gt;</code> for ergonomics</li>
</ul>
</li>
<li>
<p><strong>Developer experience first</strong></p>
<ul>
<li>Make storage composition easy, safe, and enjoyable to use</li>
</ul>
</li>
</ul>
<hr>
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, FileStorage};

// Layer-based composition
let backend = SqliteBackend::open("tenant.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_permissions()
        .build());

let fs = FileStorage::new(backend);

fs.create_dir_all("/documents")?;
fs.write("/documents/hello.txt", b"Hello!")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started (mounting roadmap defined)</td></tr>
</tbody>
</table>
</div>
<hr>
<p>For details, see <a href="#anyfs---design-overview">Design Overview</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---project-structure"><a class="header" href="#anyfs---project-structure">AnyFS - Project Structure</a></h1>
<p><strong>Status:</strong> Target layout (design spec)
<strong>Last updated:</strong> 2025-12-24</p>
<hr>
<p>This manual describes the intended code repository layout; this repository contains documentation only.</p>
<h2 id="repository-layout"><a class="header" href="#repository-layout">Repository Layout</a></h2>
<pre><code>anyfs-backend/              # Crate 1: traits + types (minimal dependencies)
  Cargo.toml
  src/
    lib.rs
    traits/
      fs_read.rs            # FsRead trait
      fs_write.rs           # FsWrite trait
      fs_dir.rs             # FsDir trait
      fs_link.rs            # FsLink trait
      fs_permissions.rs     # FsPermissions trait
      fs_sync.rs            # FsSync trait
      fs_stats.rs           # FsStats trait
      fs_path.rs            # FsPath trait (canonicalization, blanket impl)
      fs_inode.rs           # FsInode trait
      fs_handles.rs         # FsHandles trait
      fs_lock.rs            # FsLock trait
      fs_xattr.rs           # FsXattr trait
    layer.rs                # Layer trait (Tower-style)
    ext.rs                  # FsExt (extension methods)
    markers.rs              # SelfResolving marker trait
    path_resolver.rs        # PathResolver trait (pluggable resolution)
    types.rs                # Metadata, DirEntry, Permissions, StatFs
    error.rs                # FsError

anyfs/                      # Crate 2: backends + middleware + ergonomics
  Cargo.toml
  src/
    lib.rs
    backends/
      memory.rs             # MemoryBackend [feature: memory, default]
      sqlite.rs             # SqliteBackend [feature: sqlite]
      sqlite_cipher.rs      # SqliteCipherBackend [feature: sqlite-cipher]
      indexed.rs            # IndexedBackend [feature: indexed]
      stdfs.rs              # StdFsBackend [feature: stdfs]
      vrootfs.rs            # VRootFsBackend [feature: vrootfs]
    middleware/
      quota.rs              # Quota&lt;B&gt;
      restrictions.rs       # Restrictions&lt;B&gt;
      path_filter.rs        # PathFilter&lt;B&gt;
      read_only.rs          # ReadOnly&lt;B&gt;
      rate_limit.rs         # RateLimit&lt;B&gt;
      tracing.rs            # Tracing&lt;B&gt;
      dry_run.rs            # DryRun&lt;B&gt;
      cache.rs              # Cache&lt;B&gt;
      overlay.rs            # Overlay&lt;B1, B2&gt;
    resolvers/
      iterative.rs          # IterativeResolver (default)
      noop.rs               # NoOpResolver (for SelfResolving backends)
      caching.rs            # CachingResolver (LRU cache wrapper)
    container.rs            # FileStorage&lt;B, R, M&gt;
    stack.rs                # BackendStack builder
</code></pre>
<hr>
<h2 id="dependency-model"><a class="header" href="#dependency-model">Dependency Model</a></h2>
<pre><code>anyfs-backend (trait + types)
     ^
     |-- anyfs (backends + middleware + ergonomics)
     |     ^-- vrootfs feature uses strict-path
</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Custom backends depend only on <code>anyfs-backend</code></li>
<li><code>anyfs</code> provides built-in backends, middleware, mounting (behind feature flags), and the ergonomic <code>FileStorage&lt;B, R, M&gt;</code> wrapper</li>
</ul>
<hr>
<h2 id="middleware-pattern"><a class="header" href="#middleware-pattern">Middleware Pattern</a></h2>
<pre><code>FileStorage&lt;B, R, M&gt;
    wraps -&gt; Tracing&lt;B&gt;
        wraps -&gt; Restrictions&lt;B&gt;
            wraps -&gt; Quota&lt;B&gt;
                wraps -&gt; SqliteBackend (or any Fs)
</code></pre>
<p>Each layer implements <code>Fs</code>, enabling composition.</p>
<hr>
<h2 id="cargo-features"><a class="header" href="#cargo-features">Cargo Features</a></h2>
<h3 id="backends"><a class="header" href="#backends">Backends</a></h3>
<ul>
<li><code>memory</code> — In-memory storage (default)</li>
<li><code>sqlite</code> — SQLite-backed persistent storage</li>
<li><code>sqlite-cipher</code> — Encrypted SQLite via SQLCipher (mutually exclusive with <code>sqlite</code>)</li>
<li><code>indexed</code> — SQLite index + disk blobs for large file performance</li>
<li><code>stdfs</code> — Direct <code>std::fs</code> delegation (no containment)</li>
<li><code>vrootfs</code> — Host filesystem backend with path containment (uses <code>strict-path</code>)</li>
</ul>
<h3 id="middleware-mvp-scope"><a class="header" href="#middleware-mvp-scope">Middleware (MVP Scope)</a></h3>
<p>Following the <strong>Tower/Axum</strong> pattern, feature flags keep the core lightweight:</p>
<ul>
<li><code>quota</code> — Storage limits (default)</li>
<li><code>path-filter</code> — Glob-based access control (default)</li>
<li><code>restrictions</code> — Permission control (default)</li>
<li><code>read-only</code> — Write blocking (default)</li>
<li><code>rate-limit</code> — Fixed-window rate limiting (default)</li>
<li><code>tracing</code> — Detailed audit logging (requires <code>tracing</code> crate)</li>
</ul>
<p>Use <code>default-features = false</code> to cherry-pick exactly what you need.</p>
<h3 id="middleware-future-scope"><a class="header" href="#middleware-future-scope">Middleware (Future Scope)</a></h3>
<ul>
<li><code>metrics</code> — Prometheus integration (requires <code>prometheus</code> crate)</li>
</ul>
<hr>
<h2 id="where-to-start"><a class="header" href="#where-to-start">Where To Start</a></h2>
<ul>
<li>Application usage: <a href="#anyfs--getting-started-guide">Getting Started Guide</a></li>
<li>Trait details: <a href="#layered-traits-anyfs-backend">Layered Traits</a></li>
<li>Middleware: <a href="#anyfs---design-overview">Design Overview</a></li>
<li>Decisions: <a href="#anyfs---architecture-decision-records">Architecture Decision Records</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--getting-started-guide"><a class="header" href="#anyfs--getting-started-guide">AnyFS — Getting Started Guide</a></h1>
<p><strong>A practical introduction with examples</strong></p>
<hr>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
</code></pre>
<p>For additional backends:</p>
<pre><code class="language-toml">[dependencies]
anyfs = { version = "0.1", features = ["sqlite", "stdfs", "vrootfs"] }
</code></pre>
<p>Available features:</p>
<ul>
<li><code>memory</code> — In-memory storage (default)</li>
<li><code>sqlite</code> — SQLite-backed persistent storage</li>
<li><code>stdfs</code> — Direct <code>std::fs</code> delegation (no containment)</li>
<li><code>vrootfs</code> — Host filesystem backend with path containment</li>
</ul>
<hr>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Examples below use <code>FileStorage</code>, so you can pass paths as <code>&amp;str</code>. If you call core trait methods directly, use <code>&amp;Path</code>.</p>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{MemoryBackend, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/hello.txt", b"Hello, AnyFS!")?;
    let content = fs.read("/hello.txt")?;
    println!("{}", String::from_utf8_lossy(&amp;content));

    Ok(())
}</code></pre>
<h3 id="with-quotas"><a class="header" href="#with-quotas">With Quotas</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{SqliteBackend, Quota, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let backend = QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)  // 100 MB
        .max_file_size(10 * 1024 * 1024)    // 10 MB per file
        .build()
        .layer(SqliteBackend::open_or_create("data.db")?);

    let fs = FileStorage::new(backend);

    fs.create_dir_all("/documents")?;
    fs.write("/documents/notes.txt", b"Meeting notes")?;

    Ok(())
}</code></pre>
<h3 id="with-restrictions"><a class="header" href="#with-restrictions">With Restrictions</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{MemoryBackend, Restrictions, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Block permission changes for untrusted code
    let backend = RestrictionsLayer::builder()
        .deny_permissions()   // Block set_permissions() calls
        .build()
        .layer(MemoryBackend::new());

    let fs = FileStorage::new(backend);

    // All other operations work normally
    fs.write("/file.txt", b"content")?;

    Ok(())
}</code></pre>
<h3 id="full-stack-layer-based"><a class="header" href="#full-stack-layer-based">Full Stack (Layer-based)</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, TracingLayer, FileStorage};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let backend = SqliteBackend::open_or_create("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .max_file_size(10 * 1024 * 1024)
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_permissions()
            .build())
        .layer(TracingLayer::new());

    let fs = FileStorage::new(backend);

    fs.create_dir_all("/data")?;
    fs.write("/data/file.txt", b"hello")?;

    Ok(())
}</code></pre>
<hr>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="creating-directories"><a class="header" href="#creating-directories">Creating Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.create_dir("/documents")?;              // Single level
fs.create_dir_all("/documents/2024/q1")?;  // Recursive
<span class="boring">}</span></code></pre>
<h3 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and Writing Files</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.write("/data.txt", b"line 1\n")?;       // Create or overwrite
fs.append("/data.txt", b"line 2\n")?;      // Append

let content = fs.read("/data.txt")?;                    // Read all
let partial = fs.read_range("/data.txt", 0, 6)?;        // Read range
let text = fs.read_to_string("/data.txt")?;             // Read as String
<span class="boring">}</span></code></pre>
<h3 id="listing-directories"><a class="header" href="#listing-directories">Listing Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in fs.read_dir("/documents")? {
    println!("{}: {:?}", entry.name, entry.file_type);
}
<span class="boring">}</span></code></pre>
<h3 id="checking-existence-and-metadata"><a class="header" href="#checking-existence-and-metadata">Checking Existence and Metadata</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if fs.exists("/file.txt")? {
    let meta = fs.metadata("/file.txt")?;
    println!("Size: {} bytes", meta.size);
}
<span class="boring">}</span></code></pre>
<h3 id="copying-and-moving"><a class="header" href="#copying-and-moving">Copying and Moving</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.copy("/original.txt", "/copy.txt")?;
fs.rename("/original.txt", "/renamed.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="deleting"><a class="header" href="#deleting">Deleting</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.remove_file("/old-file.txt")?;
fs.remove_dir("/empty-folder")?;
fs.remove_dir_all("/old-folder")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware"><a class="header" href="#middleware">Middleware</a></h2>
<h3 id="quota--resource-limits"><a class="header" href="#quota--resource-limits">Quota — Resource Limits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Quota};

let backend = QuotaLayer::builder()
    .max_total_size(500 * 1024 * 1024)   // 500 MB total
    .max_file_size(50 * 1024 * 1024)     // 50 MB per file
    .max_node_count(100_000)             // 100K files/dirs
    .max_dir_entries(5_000)              // 5K per directory
    .max_path_depth(32)                  // Max nesting
    .build()
    .layer(MemoryBackend::new());

// Check usage
let usage = backend.usage();
println!("Using {} bytes", usage.total_size);

// Check remaining
let remaining = backend.remaining();
if !remaining.can_write {
    println!("Storage full!");
}
<span class="boring">}</span></code></pre>
<h3 id="restrictions--block-permission-changes"><a class="header" href="#restrictions--block-permission-changes">Restrictions — Block Permission Changes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Restrictions};

// Restrictions controls permission-related operations.
// Symlink/hard-link capability is determined by trait bounds (FsLink).
let backend = RestrictionsLayer::builder()
    .deny_permissions()   // Block set_permissions() calls
    .build()
    .layer(MemoryBackend::new());

// Blocked operations return FsError::FeatureNotEnabled
<span class="boring">}</span></code></pre>
<h3 id="tracing--instrumentation"><a class="header" href="#tracing--instrumentation">Tracing — Instrumentation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, TracingLayer};

// TracingLayer uses the global tracing subscriber by default
let backend = MemoryBackend::new().layer(TracingLayer::new());

// Or configure with custom settings
let backend = MemoryBackend::new()
    .layer(TracingLayer::new()
        .with_target("myapp::fs")
        .with_level(tracing::Level::DEBUG));
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;

match fs.write("/file.txt", &amp;large_data) {
    Ok(()) =&gt; println!("Written"),

    Err(FsError::NotFound { path, .. }) =&gt; println!("Not found: {}", path.display()),
    Err(FsError::AlreadyExists { path, .. }) =&gt; println!("Exists: {}", path.display()),
    Err(FsError::QuotaExceeded { .. }) =&gt; println!("Quota exceeded"),
    Err(FsError::FeatureNotEnabled { feature }) =&gt; println!("Feature disabled: {}", feature),

    Err(e) =&gt; println!("Error: {}", e),
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FileStorage};

#[test]
fn test_write_and_read() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/test.txt", b"test data").unwrap();
    let content = fs.read("/test.txt").unwrap();

    assert_eq!(content, b"test data");
}
<span class="boring">}</span></code></pre>
<p>With limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Quota, FileStorage};

#[test]
fn test_quota_exceeded() {
    let backend = QuotaLayer::builder()
        .max_total_size(1024)  // 1 KB
        .build()
        .layer(MemoryBackend::new());
    let fs = FileStorage::new(backend);

    let big_data = vec![0u8; 2048];  // 2 KB
    let result = fs.write("/big.bin", &amp;big_data);

    assert!(result.is_err());
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-use-appropriate-backend"><a class="header" href="#1-use-appropriate-backend">1. Use Appropriate Backend</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Backend</th></tr>
</thead>
<tbody>
<tr><td>Testing</td><td><code>MemoryBackend</code></td></tr>
<tr><td>Production (portable)</td><td><code>SqliteBackend</code></td></tr>
<tr><td>Host filesystem (with containment)</td><td><code>VRootFsBackend</code></td></tr>
<tr><td>Host filesystem (direct access)</td><td><code>StdFsBackend</code></td></tr>
</tbody>
</table>
</div>
<h3 id="2-compose-middleware-for-your-needs"><a class="header" href="#2-compose-middleware-for-your-needs">2. Compose Middleware for Your Needs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Minimal: just storage
let fs = FileStorage::new(MemoryBackend::new());

// With limits (layer-based)
let fs = FileStorage::new(
    MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .build())
);

// Sandboxed (layer-based)
let fs = FileStorage::new(
    SqliteBackend::open("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_permissions()
            .build())
);
<span class="boring">}</span></code></pre>
<h3 id="3-handle-errors-gracefully"><a class="header" href="#3-handle-errors-gracefully">3. Handle Errors Gracefully</a></h3>
<p>Always check for quota exceeded, feature not enabled, and other errors.</p>
<hr>
<h2 id="advanced-use-cases"><a class="header" href="#advanced-use-cases">Advanced Use Cases</a></h2>
<p>These use cases require the <code>fuse</code> or <code>winfsp</code> feature flags.</p>
<h3 id="database-backed-drive-with-live-monitoring"><a class="header" href="#database-backed-drive-with-live-monitoring">Database-Backed Drive with Live Monitoring</a></h3>
<p>Mount a database-backed filesystem and query it directly for real-time analytics:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  Database (SQLite, PostgreSQL, etc.)                        │
├─────────────────────────────────────────────────────────────┤
│                         │                                   │
│    MountHandle          │         Stats Dashboard           │
│    (write + read)       │         (direct DB queries)       │
│         │               │               │                   │
│         ▼               │               ▼                   │
│  /mnt/workspace         │    SELECT SUM(size) FROM nodes    │
│  $ cp file.txt ./       │    SELECT COUNT(*) FROM nodes     │
│  $ mkdir projects/      │    SELECT * FROM operations_log   │
│                         │               │                   │
│                         │               ▼                   │
│                         │        ┌──────────────┐           │
│                         │        │ Live Graphs  │           │
│                         │        │ - Disk usage │           │
│                         │        │ - File count │           │
│                         │        │ - Recent ops │           │
│                         │        └──────────────┘           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>SQLite Example (API sketch, planned):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, TracingLayer, MountHandle};

// Mount the drive
let backend = SqliteBackend::open("tenant.db")?
    .layer(TracingLayer::new())  // Logs operations to tracing subscriber
    .layer(QuotaLayer::builder()
        .max_total_size(1_000_000_000)
        .build());

let mount = MountHandle::mount(backend, "/mnt/workspace")?;
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Meanwhile, in a monitoring dashboard...
use rusqlite::{Connection, OpenFlags};

let conn = Connection::open_with_flags(
    "tenant.db",
    OpenFlags::SQLITE_OPEN_READ_ONLY,  // Safe concurrent reads
)?;

loop {
    let (file_count, total_bytes): (i64, i64) = conn.query_row(
        "SELECT COUNT(*), COALESCE(SUM(size), 0) FROM nodes WHERE type = 'file'",
        [],
        |row| Ok((row.get(0)?, row.get(1)?)),
    )?;

    let recent_ops: Vec&lt;String&gt; = conn
        .prepare("SELECT operation, path, timestamp FROM audit_log ORDER BY timestamp DESC LIMIT 10")?
        .query_map([], |row| Ok(format!("{}: {}", row.get::&lt;_, String&gt;(0)?, row.get::&lt;_, String&gt;(1)?)))?
        .collect::&lt;Result&lt;_, _&gt;&gt;()?;

    render_dashboard(file_count, total_bytes, &amp;recent_ops);
    std::thread::sleep(Duration::from_secs(1));
}
<span class="boring">}</span></code></pre>
<p><strong>Works with any database backend:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Direct Query Method</th></tr>
</thead>
<tbody>
<tr><td><code>SqliteBackend</code></td><td><code>rusqlite</code> with <code>SQLITE_OPEN_READ_ONLY</code></td></tr>
<tr><td><code>PostgresBackend</code> (future)</td><td>Standard <code>postgres</code> crate connection</td></tr>
<tr><td><code>MySqlBackend</code> (future)</td><td>Standard <code>mysql</code> crate connection</td></tr>
</tbody>
</table>
</div>
<p><strong>What you can visualize:</strong></p>
<ul>
<li>Real-time storage usage (gauges, bar charts)</li>
<li>File count over time (line graphs)</li>
<li>Operations log (live feed)</li>
<li>Most accessed files (heatmaps)</li>
<li>Directory tree maps (size visualization)</li>
<li>Per-tenant usage (multi-tenant dashboards)</li>
</ul>
<p>This pattern is powerful because the database is the source of truth — you get filesystem semantics via FUSE and SQL analytics via direct queries, from the same data.</p>
<h3 id="ram-drive"><a class="header" href="#ram-drive">RAM Drive</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, MountHandle};

// 4GB RAM drive
let mount = MountHandle::mount(
    MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(4 * 1024 * 1024 * 1024)
            .build()),
    "/mnt/ramdisk"
)?;

// Use for fast compilation, temp files, etc.
// $ TMPDIR=/mnt/ramdisk cargo build
<span class="boring">}</span></code></pre>
<h3 id="sandboxed-ai-agent-workspace"><a class="header" href="#sandboxed-ai-agent-workspace">Sandboxed AI Agent Workspace</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, RestrictionsLayer, TracingLayer, MountHandle};

let mount = MountHandle::mount(
    MemoryBackend::new()
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/..*")           // No hidden files
            .deny("**/.*")            // No dotfiles
            .build())
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .max_file_size(10 * 1024 * 1024)
            .build())
        .layer(TracingLayer::new()),  // Full audit trail
    "/mnt/agent"
)?;

// Agent uses standard filesystem APIs
// All operations are sandboxed, quota-limited, and logged
<span class="boring">}</span></code></pre>
<hr>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#anyfs--api-quick-reference">API Quick Reference</a></li>
<li><a href="#anyfs---design-overview">Design Overview</a></li>
<li><a href="#backend-implementers-guide">Backend Implementer’s Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--api-quick-reference"><a class="header" href="#anyfs--api-quick-reference">AnyFS — API Quick Reference</a></h1>
<p><strong>Condensed reference for developers</strong></p>
<hr>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
</code></pre>
<p>With backends and optional features:</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["sqlite", "vrootfs", "bytes"] }
</code></pre>
<hr>
<h2 id="creating-a-backend-stack"><a class="header" href="#creating-a-backend-stack">Creating a Backend Stack</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, QuotaLayer, RestrictionsLayer, TracingLayer, FileStorage};

// Simple
let fs = FileStorage::new(MemoryBackend::new());

// With limits
let fs = FileStorage::new(
    SqliteBackend::open("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .max_file_size(10 * 1024 * 1024)
            .build())
);

// Full stack (fluent composition)
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_permissions()
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(backend);

// BackendStack builder (fluent API)
use anyfs::BackendStack;

let fs = BackendStack::new(SqliteBackend::open("data.db")?)
    .limited(|l| l.max_total_size(100 * 1024 * 1024))
    .restricted(|g| g.deny_permissions())
    .traced()
    .into_container();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="quota-methods"><a class="header" href="#quota-methods">Quota Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - at least one limit must be set)
QuotaLayer::builder()
    .max_total_size(bytes)      // Total storage limit
    .max_file_size(bytes)       // Per-file limit
    .max_node_count(count)      // Max files/dirs
    .max_dir_entries(count)     // Max entries per dir
    .max_path_depth(depth)      // Max nesting
    .build()
    .layer(backend)

// Query
backend.usage()        // -&gt; Usage { total_size, file_count, ... }
backend.limits()       // -&gt; Limits { max_total_size, ... }
backend.remaining()    // -&gt; Remaining { bytes, can_write, ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="restrictions-methods"><a class="header" href="#restrictions-methods">Restrictions Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern
// Restrictions only controls permission-related operations.
// Symlink/hard-link capability is via trait bounds (FsLink), not middleware.
RestrictionsLayer::builder()
    .deny_permissions()    // Block set_permissions() calls
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="tracinglayer-methods"><a class="header" href="#tracinglayer-methods">TracingLayer Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TracingLayer configuration (applied via .layer())
TracingLayer::new()
    .with_target("anyfs")              // tracing target
    .with_level(tracing::Level::DEBUG)

// Usage
let backend = inner.layer(TracingLayer::new().with_target("anyfs"));
<span class="boring">}</span></code></pre>
<hr>
<h2 id="pathfilter-methods"><a class="header" href="#pathfilter-methods">PathFilter Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - at least one rule must be set)
PathFilterLayer::builder()
    .allow("/workspace/**")    // Allow glob pattern
    .deny("**/.env")           // Deny glob pattern
    .deny("**/secrets/**")
    .build()
    .layer(backend)

// Rules evaluated in order; first match wins
// No match = denied (deny by default)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="readonly-methods"><a class="header" href="#readonly-methods">ReadOnly Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ReadOnly::new(backend)

// All read operations pass through
// All write operations return FsError::ReadOnly
<span class="boring">}</span></code></pre>
<hr>
<h2 id="ratelimit-methods"><a class="header" href="#ratelimit-methods">RateLimit Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - must set ops and window)
RateLimitLayer::builder()
    .max_ops(1000)           // Operation limit
    .per_second()            // Window: 1 second
    // or
    .per_minute()            // Window: 60 seconds
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="dryrun-methods"><a class="header" href="#dryrun-methods">DryRun Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dry_run = DryRun::new(backend);
let fs = FileStorage::new(dry_run);

// Read operations execute normally
// Write operations are logged but not executed
fs.write("/file.txt", b"data")?;  // Logged, returns Ok

// Inspect logged operations (returns Vec&lt;String&gt;)
let ops: Vec&lt;String&gt; = dry_run.operations();
// e.g., ["write /file.txt (4 bytes)", "remove_file /old.txt"]

dry_run.clear();  // Clear the log
<span class="boring">}</span></code></pre>
<hr>
<h2 id="cache-methods"><a class="header" href="#cache-methods">Cache Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - at least max_entries must be set)
CacheLayer::builder()
    .max_entries(1000)                          // LRU cache size
    .max_entry_size(1024 * 1024)               // 1MB max per entry
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="indexlayer-methods-future"><a class="header" href="#indexlayer-methods-future">IndexLayer Methods (Future)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder pattern (required - set index path)
IndexLayer::builder()
    .index_file("index.db")             // Sidecar index file (SQLite default)
    .consistency(IndexConsistency::Strict)
    .track_reads(false)                 // Optional
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="overlay-methods"><a class="header" href="#overlay-methods">Overlay Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, MemoryBackend, Overlay};

let base = SqliteBackend::open("base.db")?;  // Read-only base
let upper = MemoryBackend::new();             // Writable upper

let overlay = Overlay::new(base, upper);

// Read: check upper first, fall back to base
// Write: always to upper layer
// Delete: whiteout marker in upper
<span class="boring">}</span></code></pre>
<hr>
<h2 id="fsext-methods"><a class="header" href="#fsext-methods">FsExt Methods</a></h2>
<p>Extension methods available on all backends:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsExt;

// JSON support
let config: Config = fs.read_json("/config.json")?;
fs.write_json("/config.json", &amp;config)?;

// Type checks
if fs.is_file("/path")? { ... }
if fs.is_dir("/path")? { ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h2>
<p>Examples below assume <code>FileStorage</code> (std::fs-style paths). If you call core trait methods directly, pass <code>&amp;Path</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check existence
fs.exists("/path")?                     // -&gt; bool

// Metadata
let meta = fs.metadata("/path")?;
meta.inode                               // unique identifier
meta.nlink                               // hard link count
meta.file_type                           // File | Directory | Symlink
meta.size                                // file size in bytes
meta.permissions                         // Permissions (default if unsupported)
meta.created                             // SystemTime (UNIX_EPOCH if unsupported)
meta.modified                            // SystemTime (UNIX_EPOCH if unsupported)
meta.accessed                            // SystemTime (UNIX_EPOCH if unsupported)

// Read
let bytes = fs.read("/path")?;           // -&gt; Vec&lt;u8&gt;
let text = fs.read_to_string("/path")?;  // -&gt; String
let chunk = fs.read_range("/path", 0, 1024)?;

// List directory
for entry in fs.read_dir("/path")? {
    let entry = entry?;
    entry.name                           // String (file/dir name only)
    entry.path                           // PathBuf (full path)
    entry.file_type                      // File | Directory | Symlink
    entry.size                           // u64 (0 for directories)
    entry.inode                          // u64 (0 if unsupported)
}

// Write
fs.write("/path", b"content")?;          // Create or overwrite
fs.append("/path", b"more")?;            // Append

// Directories
fs.create_dir("/path")?;
fs.create_dir_all("/path")?;

// Delete
fs.remove_file("/path")?;
fs.remove_dir("/path")?;                 // Empty only
fs.remove_dir_all("/path")?;             // Recursive

// Move/Copy
fs.rename("/from", "/to")?;
fs.copy("/from", "/to")?;

// Links
fs.symlink("/target", "/link")?;
fs.hard_link("/original", "/link")?;
fs.read_link("/link")?;                  // -&gt; PathBuf
fs.symlink_metadata("/link")?;           // Metadata of link itself, not target
// Symlink capability is determined by FsLink trait bounds, not middleware.

// Permissions (requires FsPermissions)
fs.set_permissions("/path", perms)?;

// File size
fs.truncate("/path", 1024)?;             // Resize to 1024 bytes

// Durability
fs.sync()?;                              // Flush all writes
fs.fsync("/path")?;                      // Flush writes for one file
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-canonicalization"><a class="header" href="#path-canonicalization">Path Canonicalization</a></h2>
<p><code>FileStorage</code> provides path canonicalization that works on the virtual filesystem.</p>
<p><strong>Note:</strong> Canonicalization requires <code>FsLink</code> because symlink resolution needs <code>read_link()</code> and <code>symlink_metadata()</code>. Backends that only implement <code>Fs</code> (without <code>FsLink</code>) cannot use these methods.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Strict canonicalization - path must exist
let canonical = fs.canonicalize("/some/../path/./file.txt")?;
// Returns fully resolved absolute path, follows symlinks

// Soft canonicalization - handles non-existent paths
let resolved = fs.soft_canonicalize("/existing/dir/new_file.txt")?;
// Resolves existing components, appends non-existent remainder lexically

// Anchored canonicalization - sandboxed resolution
let safe = fs.anchored_canonicalize("/workspace/../etc/passwd", "/workspace")?;
// Clamps result within anchor directory (returns error if escape attempted)
<span class="boring">}</span></code></pre>
<p><strong>Standalone utility (no backend needed):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::normalize;

// Lexical path cleanup only
let clean = normalize("//foo///bar//");  // -&gt; "/foo/bar"
// Does NOT resolve . or .. (those require filesystem context)
// Does NOT follow symlinks
<span class="boring">}</span></code></pre>
<p><strong>Comparison:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Path Must Exist?</th><th>Follows Symlinks?</th><th>Resolves <code>..</code>?</th></tr>
</thead>
<tbody>
<tr><td><code>canonicalize</code></td><td>Yes (all components)</td><td>Yes</td><td>Yes (symlink-aware)</td></tr>
<tr><td><code>soft_canonicalize</code></td><td>No (appends non-existent)</td><td>Yes (for existing)</td><td>Yes (symlink-aware)</td></tr>
<tr><td><code>anchored_canonicalize</code></td><td>No</td><td>Yes (for existing)</td><td>Yes (clamped to anchor)</td></tr>
<tr><td><code>normalize</code></td><td>N/A (lexical only)</td><td>No</td><td>No</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="inode-operations-fsinode-trait"><a class="header" href="#inode-operations-fsinode-trait">Inode Operations (<code>FsInode</code> trait)</a></h2>
<p>Backends implementing <code>FsInode</code> track inodes internally for hardlink support and FUSE mounting:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::FileStorage;

// Convert between paths and inodes
let fs = FileStorage::new(backend);
let inode: u64 = fs.path_to_inode("/some/path")?;
let path: PathBuf = fs.inode_to_path(inode)?;

// Lookup child by name within a directory (FUSE-style)
let root_inode = fs.path_to_inode("/")?;
let child_inode = fs.lookup(root_inode, "filename.txt")?;

// Get metadata by inode (avoids path resolution)
let meta = fs.metadata_by_inode(inode)?;

// Hardlinks share the same inode
fs.hard_link("/original", "/link")?;
let ino1 = fs.path_to_inode("/original")?;
let ino2 = fs.path_to_inode("/link")?;
assert_eq!(ino1, ino2);  // Same inode!
<span class="boring">}</span></code></pre>
<p><strong>Inode sources by backend:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Inode Source</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Internal node IDs (incrementing counter)</td></tr>
<tr><td><code>SqliteBackend</code></td><td>SQLite row IDs (<code>INTEGER PRIMARY KEY</code>)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>OS inode numbers (<code>Metadata::ino()</code>)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;

match result {
    // Path errors
    Err(FsError::NotFound { path }) =&gt; {
        // e.g., path="/file.txt"
    }
    Err(FsError::AlreadyExists { path, operation }) =&gt; ...
    Err(FsError::NotADirectory { path }) =&gt; ...
    Err(FsError::NotAFile { path }) =&gt; ...
    Err(FsError::DirectoryNotEmpty { path }) =&gt; ...

    // Quota middleware errors
    Err(FsError::QuotaExceeded { limit, requested, usage }) =&gt; ...
    Err(FsError::FileSizeExceeded { path, size, limit }) =&gt; ...

    // Restrictions middleware errors
    Err(FsError::FeatureNotEnabled { feature, operation }) =&gt; ...

    // PathFilter middleware errors
    Err(FsError::AccessDenied { path, reason }) =&gt; ...

    // ReadOnly middleware errors
    Err(FsError::ReadOnly { operation }) =&gt; ...

    // RateLimit middleware errors
    Err(FsError::RateLimitExceeded { limit, window_secs }) =&gt; ...

    // FsExt errors
    Err(FsError::Serialization(msg)) =&gt; ...
    Err(FsError::Deserialization(msg)) =&gt; ...

    // Optional feature not supported
    Err(FsError::NotSupported { operation }) =&gt; ...

    Err(e) =&gt; ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="built-in-backends"><a class="header" href="#built-in-backends">Built-in Backends</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td><code>memory</code> (default)</td><td>In-memory</td></tr>
<tr><td><code>SqliteBackend</code></td><td><code>sqlite</code></td><td>Persistent single-file database</td></tr>
<tr><td><code>SqliteCipherBackend</code></td><td><code>sqlite-cipher</code></td><td>Encrypted SQLite (AES-256 via SQLCipher)</td></tr>
<tr><td><code>IndexedBackend</code></td><td><code>indexed</code></td><td>Virtual paths + disk blobs (large file support)</td></tr>
<tr><td><code>StdFsBackend</code></td><td><code>stdfs</code></td><td>Direct <code>std::fs</code> (no containment)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td><code>vrootfs</code></td><td>Host filesystem (with containment)</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> <code>sqlite</code> and <code>sqlite-cipher</code> are mutually exclusive features.</p>
<hr>
<h2 id="sqlitecipherbackend-methods"><a class="header" href="#sqlitecipherbackend-methods">SqliteCipherBackend Methods</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteCipherBackend;

// Open with password (key derived via PBKDF2)
let backend = SqliteCipherBackend::open("encrypted.db", "password")?;

// Open with raw 256-bit key
let backend = SqliteCipherBackend::open_with_key("encrypted.db", &amp;key)?;

// Create new encrypted database
let backend = SqliteCipherBackend::create("new.db", "password")?;

// Change password on open database
backend.change_password("new-password")?;
<span class="boring">}</span></code></pre>
<p>Without the correct password, the <code>.db</code> file appears as random bytes.</p>
<hr>
<h2 id="middleware-1"><a class="header" href="#middleware-1">Middleware</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Quota enforcement</td></tr>
<tr><td><code>Restrictions&lt;B&gt;</code></td><td>Least privilege</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Path-based access control</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Prevent write operations</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Operation throttling</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Instrumentation (tracing ecosystem)</td></tr>
<tr><td><code>DryRun&lt;B&gt;</code></td><td>Log without executing</td></tr>
<tr><td><code>Cache&lt;B&gt;</code></td><td>LRU read caching</td></tr>
<tr><td><code>Overlay&lt;B1,B2&gt;</code></td><td>Union filesystem</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Creates</th></tr>
</thead>
<tbody>
<tr><td><code>QuotaLayer</code></td><td><code>Quota&lt;B&gt;</code></td></tr>
<tr><td><code>RestrictionsLayer</code></td><td><code>Restrictions&lt;B&gt;</code></td></tr>
<tr><td><code>PathFilterLayer</code></td><td><code>PathFilter&lt;B&gt;</code></td></tr>
<tr><td><code>ReadOnlyLayer</code></td><td><code>ReadOnly&lt;B&gt;</code></td></tr>
<tr><td><code>RateLimitLayer</code></td><td><code>RateLimit&lt;B&gt;</code></td></tr>
<tr><td><code>TracingLayer</code></td><td><code>Tracing&lt;B&gt;</code></td></tr>
<tr><td><code>DryRunLayer</code></td><td><code>DryRun&lt;B&gt;</code></td></tr>
<tr><td><code>CacheLayer</code></td><td><code>Cache&lt;B&gt;</code></td></tr>
<tr><td><code>OverlayLayer</code></td><td><code>Overlay&lt;B1,B2&gt;</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="type-reference"><a class="header" href="#type-reference">Type Reference</a></h2>
<h3 id="from-anyfs-backend"><a class="header" href="#from-anyfs-backend">From <code>anyfs-backend</code></a></h3>
<p><strong>Core Traits (Layer 1):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsRead</code></td><td>Read operations: <code>read</code>, <code>exists</code>, <code>metadata</code>, <code>open_read</code></td></tr>
<tr><td><code>FsWrite</code></td><td>Write operations: <code>write</code>, <code>append</code>, <code>remove_file</code>, <code>rename</code>, <code>copy</code>, <code>truncate</code></td></tr>
<tr><td><code>FsDir</code></td><td>Directory operations: <code>read_dir</code>, <code>create_dir*</code>, <code>remove_dir*</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Extended Traits (Layer 2):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsLink</code></td><td>Link operations: <code>symlink</code>, <code>hard_link</code>, <code>read_link</code></td></tr>
<tr><td><code>FsPermissions</code></td><td>Permission operations: <code>set_permissions</code></td></tr>
<tr><td><code>FsSync</code></td><td>Sync operations: <code>sync</code>, <code>fsync</code></td></tr>
<tr><td><code>FsStats</code></td><td>Stats operations: <code>statfs</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Inode Trait (Layer 3):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsInode</code></td><td>Inode operations: <code>path_to_inode</code>, <code>inode_to_path</code>, <code>lookup</code>, <code>metadata_by_inode</code></td></tr>
</tbody>
</table>
</div>
<p><strong>POSIX Traits (Layer 4):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FsHandles</code></td><td>Handle operations: <code>open</code>, <code>read_at</code>, <code>write_at</code>, <code>close</code></td></tr>
<tr><td><code>FsLock</code></td><td>Lock operations: <code>lock</code>, <code>try_lock</code>, <code>unlock</code></td></tr>
<tr><td><code>FsXattr</code></td><td>Extended attribute operations: <code>get_xattr</code>, <code>set_xattr</code>, <code>list_xattr</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Convenience Supertraits:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Combines</th></tr>
</thead>
<tbody>
<tr><td><code>Fs</code></td><td><code>FsRead</code> + <code>FsWrite</code> + <code>FsDir</code> (90% of use cases)</td></tr>
<tr><td><code>FsFull</code></td><td><code>Fs</code> + <code>FsLink</code> + <code>FsPermissions</code> + <code>FsSync</code> + <code>FsStats</code></td></tr>
<tr><td><code>FsFuse</code></td><td><code>FsFull</code> + <code>FsInode</code> (FUSE-mountable)</td></tr>
<tr><td><code>FsPosix</code></td><td><code>FsFuse</code> + <code>FsHandles</code> + <code>FsLock</code> + <code>FsXattr</code> (full POSIX)</td></tr>
</tbody>
</table>
</div>
<p><strong>Other Types:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Layer</code></td><td>Middleware composition trait</td></tr>
<tr><td><code>FsExt</code></td><td>Extension methods trait (JSON, type checks)</td></tr>
<tr><td><code>FsError</code></td><td>Error type (with context)</td></tr>
<tr><td><code>ROOT_INODE</code></td><td>Constant: root directory inode (= 1)</td></tr>
<tr><td><code>FileType</code></td><td><code>File</code>, <code>Directory</code>, <code>Symlink</code></td></tr>
<tr><td><code>Metadata</code></td><td>File/dir metadata (inode, nlink, size, times, permissions)</td></tr>
<tr><td><code>DirEntry</code></td><td>Directory entry (name, inode, file_type)</td></tr>
<tr><td><code>Permissions</code></td><td>File permissions (mode: u32)</td></tr>
<tr><td><code>StatFs</code></td><td>Filesystem stats (bytes, inodes, block_size)</td></tr>
</tbody>
</table>
</div>
<h3 id="from-anyfs"><a class="header" href="#from-anyfs">From <code>anyfs</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>In-memory backend</td></tr>
<tr><td><code>SqliteBackend</code></td><td>SQLite backend</td></tr>
<tr><td><code>StdFsBackend</code></td><td>Direct <code>std::fs</code> backend (no containment)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Host FS backend (with containment)</td></tr>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Quota middleware</td></tr>
<tr><td><code>Restrictions&lt;B&gt;</code></td><td>Feature gate middleware</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Path access control middleware</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Read-only middleware</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Rate limiting middleware</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Tracing middleware</td></tr>
<tr><td><code>DryRun&lt;B&gt;</code></td><td>Dry-run middleware</td></tr>
<tr><td><code>Cache&lt;B&gt;</code></td><td>Caching middleware</td></tr>
<tr><td><code>Overlay&lt;B1,B2&gt;</code></td><td>Union filesystem middleware</td></tr>
<tr><td><code>QuotaLayer</code></td><td>Layer for Quota</td></tr>
<tr><td><code>RestrictionsLayer</code></td><td>Layer for Restrictions</td></tr>
<tr><td><code>PathFilterLayer</code></td><td>Layer for PathFilter</td></tr>
<tr><td><code>ReadOnlyLayer</code></td><td>Layer for ReadOnly</td></tr>
<tr><td><code>RateLimitLayer</code></td><td>Layer for RateLimit</td></tr>
<tr><td><code>TracingLayer</code></td><td>Layer for Tracing</td></tr>
<tr><td><code>DryRunLayer</code></td><td>Layer for DryRun</td></tr>
<tr><td><code>CacheLayer</code></td><td>Layer for Cache</td></tr>
<tr><td><code>OverlayLayer</code></td><td>Layer for Overlay</td></tr>
</tbody>
</table>
</div>
<p><strong>Ergonomic Wrappers (in <code>anyfs</code>):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FileStorage&lt;B, R, M&gt;</code></td><td>Zero-cost ergonomic wrapper (generic backend, resolver, marker)</td></tr>
<tr><td><code>BackendStack</code></td><td>Fluent builder for middleware stacks</td></tr>
<tr><td><code>.boxed()</code></td><td>Opt-in type erasure for <code>FileStorage</code></td></tr>
<tr><td><code>IterativeResolver</code></td><td>Default path resolver (symlink-aware for backends with <code>FsLink</code>)</td></tr>
<tr><td><code>NoOpResolver</code></td><td>No-op resolver for <code>SelfResolving</code> backends</td></tr>
<tr><td><code>CachingResolver&lt;R&gt;</code></td><td>LRU cache wrapper around another resolver</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---design-overview"><a class="header" href="#anyfs---design-overview">AnyFS - Design Overview</a></h1>
<p><strong>Status:</strong> Current
<strong>Last updated:</strong> 2025-12-24</p>
<hr>
<h2 id="what-this-project-is"><a class="header" href="#what-this-project-is">What This Project Is</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust. It uses a <strong>middleware/decorator pattern</strong> (like Axum/Tower) for composable functionality with complete separation of concerns.</p>
<h3 id="philosophy-focused-app-smart-storage"><a class="header" href="#philosophy-focused-app-smart-storage">Philosophy: Focused App, Smart Storage</a></h3>
<p>It decouples application logic from storage policy, enabling a <strong>Data Mesh</strong> at the filesystem level.</p>
<ul>
<li><strong>The App</strong> focuses on business value (“save the document”).</li>
<li><strong>The Storage Layer</strong> enforces non-functional requirements (“encrypt, audit, limit, index”).</li>
</ul>
<p>Anyone can:</p>
<ul>
<li><strong>Control how a drive acts, looks, and protects itself.</strong></li>
<li>Implement a custom backend for their specific storage needs (Cloud, DB, RAM).</li>
<li>Compose middleware to add limits, logging, and security.</li>
<li>Use the ergonomic <code>FileStorage&lt;B, R, M&gt;</code> wrapper for a standard <code>std::fs</code>-like API.</li>
</ul>
<hr>
<h2 id="architecture-tower-style-middleware"><a class="header" href="#architecture-tower-style-middleware">Architecture (Tower-style Middleware)</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage&lt;B, R, M&gt;                   │  ← Ergonomics + type-safe marker
├─────────────────────────────────────────┤
│  Middleware (optional, composable):     │
│                                         │
│  Policy:                                │
│    Quota&lt;B&gt;         - Resource limits   │
│    Restrictions&lt;B&gt;  - Least privilege   │
│    PathFilter&lt;B&gt;    - Sandbox paths     │
│    ReadOnly&lt;B&gt;      - Prevent writes    │
│    RateLimit&lt;B&gt;     - Ops/sec limit     │
│                                         │
│  Observability:                         │
│    Tracing&lt;B&gt;       - Instrumentation   │
│    DryRun&lt;B&gt;        - Test mode         │
│                                         │
│  Performance:                           │
│    Cache&lt;B&gt;         - LRU caching       │
│                                         │
│  Composition:                           │
│    Overlay&lt;B1,B2&gt;   - Layered FS        │
│                                         │
├─────────────────────────────────────────┤
│  Backend (implements Fs, FsFull,        │  ← Pure storage + fs semantics
│           FsFuse, or FsPosix)           │
│  (Memory, SQLite, VRootFs, custom...)   │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Each layer has exactly one responsibility:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td>Backend (<code>Fs</code>+)</td><td>Storage + filesystem semantics</td></tr>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Resource limits (size, count, depth)</td></tr>
<tr><td><code>Restrictions&lt;B&gt;</code></td><td>Opt-in operation restrictions</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Path-based access control</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Prevent all write operations</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Limit operations per second</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Instrumentation / audit trail</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="design-principle-predictable-defaults-opt-in-security"><a class="header" href="#design-principle-predictable-defaults-opt-in-security">Design Principle: Predictable Defaults, Opt-in Security</a></h2>
<p><strong>The <code>Fs</code> traits mimic <code>std::fs</code> with predictable, permissive defaults.</strong></p>
<p>See ADR-027 for the decision rationale.</p>
<p>The traits are low-level interfaces that any backend can implement - memory, SQLite, real filesystem, network storage, etc. To maintain consistent behavior across all backends:</p>
<ul>
<li>All operations work by default (<code>symlink()</code>, <code>hard_link()</code>, <code>set_permissions()</code>)</li>
<li>No security restrictions at the trait level</li>
<li>Behavior matches what you’d expect from a real filesystem</li>
</ul>
<p><strong>Why not secure-by-default at this layer?</strong></p>
<ol>
<li><strong>Predictability</strong>: A backend should behave like a filesystem. Surprising restrictions break expectations.</li>
<li><strong>Backend-agnostic</strong>: The traits don’t know if they’re wrapping a sandboxed memory store or a real filesystem. Restrictions that make sense for one may not for another.</li>
<li><strong>Composition</strong>: Security is achieved by layering middleware, not by baking it into the storage layer.</li>
</ol>
<p><strong>Security is the responsibility of higher-level APIs:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Security Responsibility</th></tr>
</thead>
<tbody>
<tr><td>Backend (<code>Fs</code>+)</td><td>None - pure filesystem semantics</td></tr>
<tr><td>Middleware (<code>Restrictions</code>, <code>PathFilter</code>, etc.)</td><td>Opt-in restrictions</td></tr>
<tr><td><code>FileStorage</code> or application code</td><td>Configure appropriate middleware</td></tr>
</tbody>
</table>
</div>
<p><strong>Example: Secure AI Agent Sandbox</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, FileStorage};

struct AiSandbox;  // Marker type

// Application composes secure defaults (marker in type annotation)
let sandbox: FileStorage&lt;_, _, AiSandbox&gt; = FileStorage::new(
    MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(50 * 1024 * 1024)
            .build())
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/.env")
            .build())
);
<span class="boring">}</span></code></pre>
<p>The backend is permissive. The application adds restrictions appropriate for its use case.</p>
<hr>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th><th>Contains</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract</td><td>Layered traits (<code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>, <code>FsPosix</code>), <code>Layer</code> trait, types, <code>FsExt</code></td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + ergonomics</td><td>Built-in backends, all middleware layers, <code>FileStorage&lt;B, R, M&gt;</code>, <code>BackendStack</code> builder</td></tr>
</tbody>
</table>
</div>
<h3 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h3>
<pre><code>anyfs-backend (trait + types)
     ^
     |-- anyfs (backends + middleware + ergonomics)
           ^-- vrootfs feature may use strict-path
</code></pre>
<hr>
<h2 id="future-considerations-1"><a class="header" href="#future-considerations-1">Future Considerations</a></h2>
<p>These are optional extensions to explore after the core is stable.</p>
<p><strong>Keep (add-ons that fit the current design):</strong></p>
<ul>
<li>URL-based backend registry (<code>sqlite://</code>, <code>mem://</code>, <code>stdfs://</code>) as a helper crate, not in core APIs.</li>
<li>Bulk operation helpers (<code>read_many</code>, <code>write_many</code>, <code>copy_many</code>, <code>glob</code>, <code>walk</code>) as <code>FsExt</code> or a utilities crate.</li>
<li>Early async adapter crate (<code>anyfs-async</code>) to support remote backends without changing sync traits.</li>
<li>Bash-style shell (example app or <code>anyfs-shell</code> crate) that routes <code>ls/cd/cat/cp/mv/rm/mkdir/stat</code> through <code>FileStorage</code> to demonstrate middleware and backend neutrality (navigation and file management only, not full bash scripting).</li>
<li>Copy-on-write overlay middleware (Afero-style <code>CopyOnWriteFs</code>) as a specialized <code>Overlay</code> variant.</li>
<li>Archive backends (zip/tar) as separate crates implementing <code>Fs</code> (inspired by PyFilesystem/fsspec).</li>
<li>Indexing middleware (<code>Indexing&lt;B&gt;</code> + <code>IndexLayer</code>) with pluggable index engines (SQLite default). See <a href="#indexing-middleware-design-plan">Indexing Middleware</a>.</li>
</ul>
<p><strong>Defer (valuable, but needs data or wider review):</strong></p>
<ul>
<li>Range/block caching middleware for <code>read_range</code> heavy workloads (fsspec-style block cache).</li>
<li>Runtime capability discovery (<code>Capabilities</code> struct) for feature detection (symlink control, case sensitivity, max path length).</li>
<li>Lint/analyzer to discourage direct <code>std::fs</code> usage in app code (System.IO.Abstractions-style).</li>
<li>Retry/timeout middleware for remote backends (when network backends are real).</li>
</ul>
<p><strong>Drop for now (adds noise or cross-platform complexity):</strong></p>
<ul>
<li>Change notification support (optional <code>FsWatch</code> trait or polling middleware).</li>
</ul>
<p>Detailed rationale lives in <code>src/comparisons/prior-art-analysis.md</code>.</p>
<hr>
<h3 id="language-bindings-python-c-etc"><a class="header" href="#language-bindings-python-c-etc">Language Bindings (Python, C, etc.)</a></h3>
<p>The AnyFS design is <strong>FFI-friendly</strong> and can be exposed to other languages with minimal friction.</p>
<p><strong>Why the design works well for FFI:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Design Choice</th><th>FFI Benefit</th></tr>
</thead>
<tbody>
<tr><td><code>&amp;self</code> methods (ADR-023)</td><td>Interior mutability allows holding a single <code>Arc&lt;FileStorage&lt;...&gt;&gt;</code> across FFI</td></tr>
<tr><td><code>Box&lt;dyn Fs&gt;</code> type erasure</td><td><code>FileStorage::boxed()</code> provides a concrete type suitable for FFI</td></tr>
<tr><td>Owned return types</td><td><code>Vec&lt;u8&gt;</code>, <code>String</code>, <code>bool</code> - no lifetime issues across FFI boundary</td></tr>
<tr><td>Simple structs</td><td><code>Metadata</code>, <code>DirEntry</code>, <code>Permissions</code> map directly to Python/C structs</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommended approach for Python (PyO3):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// anyfs-python/src/lib.rs
use pyo3::prelude::*;
use anyfs::{FileStorage, MemoryBackend, SqliteBackend, Fs};

#[pyclass]
struct PyFileStorage {
    inner: FileStorage&lt;Box&lt;dyn Fs&gt;&gt;,  // Type-erased for FFI
}

#[pymethods]
impl PyFileStorage {
    #[staticmethod]
    fn memory() -&gt; Self {
        Self { inner: FileStorage::new(MemoryBackend::new()).boxed() }
    }

    #[staticmethod]
    fn sqlite(path: &amp;str) -&gt; PyResult&lt;Self&gt; {
        let backend = SqliteBackend::open(path)
            .map_err(|e| PyErr::new::&lt;pyo3::exceptions::PyIOError, _&gt;(e.to_string()))?;
        Ok(Self { inner: FileStorage::new(backend).boxed() })
    }

    fn read(&amp;self, path: &amp;str) -&gt; PyResult&lt;Vec&lt;u8&gt;&gt; {
        self.inner.read(path)
            .map_err(|e| PyErr::new::&lt;pyo3::exceptions::PyIOError, _&gt;(e.to_string()))
    }

    fn write(&amp;self, path: &amp;str, data: &amp;[u8]) -&gt; PyResult&lt;()&gt; {
        self.inner.write(path, data)
            .map_err(|e| PyErr::new::&lt;pyo3::exceptions::PyIOError, _&gt;(e.to_string()))
    }
}

#[pymodule]
fn anyfs_python(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;PyFileStorage&gt;()?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<p><strong>Python usage:</strong></p>
<pre><code class="language-python">from anyfs_python import PyFileStorage

fs = PyFileStorage.memory()
fs.write("/hello.txt", b"Hello from Python!")
data = fs.read("/hello.txt")
print(data)  # b"Hello from Python!"
</code></pre>
<p><strong>Key considerations for FFI:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td>Generics (<code>FileStorage&lt;B, R, M&gt;</code>)</td><td>Use <code>FileStorage&lt;Box&lt;dyn Fs&gt;, R, M&gt;</code> (boxed form) for FFI layer</td></tr>
<tr><td>Streaming (<code>Box&lt;dyn Read&gt;</code>)</td><td>Wrap in language-native class with <code>read(n)</code> method</td></tr>
<tr><td>Middleware composition</td><td>Pre-build common stacks, expose as factory functions</td></tr>
<tr><td>Error handling</td><td>Convert <code>FsError</code> to language-native exceptions</td></tr>
</tbody>
</table>
</div>
<p><strong>Future crate:</strong> <code>anyfs-python</code></p>
<h3 id="dynamic-middleware"><a class="header" href="#dynamic-middleware">Dynamic Middleware</a></h3>
<p>The current design uses <strong>compile-time generics</strong> for zero-cost middleware composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Static: type known at compile time
let fs: Tracing&lt;Quota&lt;MemoryBackend&gt;&gt; = MemoryBackend::new()
    .layer(QuotaLayer::builder().max_total_size(100).build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<p>For <strong>runtime-configured</strong> middleware (e.g., based on config files), use <code>Box&lt;dyn Fs&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_from_config(config: &amp;Config) -&gt; FileStorage&lt;Box&lt;dyn Fs&gt;&gt; {
    let mut backend: Box&lt;dyn Fs&gt; = Box::new(MemoryBackend::new());

    if config.enable_quota {
        backend = Box::new(Quota::new(backend, config.quota_limit));
    }

    if config.enable_antivirus {
        backend = Box::new(AntivirusMiddleware::new(backend, config.av_scanner_path));
    }

    if config.enable_tracing {
        backend = Box::new(Tracing::new(backend));
    }

    FileStorage::new(backend)
}
<span class="boring">}</span></code></pre>
<p><strong>Trade-off:</strong> One <code>Box</code> allocation per layer + vtable dispatch. For I/O-bound workloads, this overhead is negligible (&lt;1% of operation time).</p>
<p><strong>Example: Antivirus Middleware</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Antivirus&lt;B&gt; {
    inner: B,
    scanner: Arc&lt;dyn VirusScanner + Send + Sync&gt;,
}

pub trait VirusScanner: Send + Sync {
    fn scan(&amp;self, data: &amp;[u8]) -&gt; Option&lt;String&gt;;  // Returns threat name if detected
}

impl&lt;B: FsWrite&gt; FsWrite for Antivirus&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        if let Some(threat) = self.scanner.scan(data) {
            return Err(FsError::ThreatDetected { 
                path: path.to_path_buf(), 
                threat_name: threat,
            });
        }
        self.inner.write(path, data)
    }

    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        let inner = self.inner.open_write(path)?;
        Ok(Box::new(ScanningWriter::new(inner, self.scanner.clone())))
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Future: Plugin System</strong></p>
<p>For true runtime-loaded plugins (<code>.so</code>/<code>.dll</code>), a future <code>MiddlewarePlugin</code> trait could enable:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MiddlewarePlugin: Send + Sync {
    fn name(&amp;self) -&gt; &amp;str;
    fn wrap(&amp;self, backend: Box&lt;dyn Fs&gt;) -&gt; Box&lt;dyn Fs&gt;;
}

// Load at runtime
let plugin = libloading::Library::new("antivirus_plugin.so")?;
let create_plugin: fn() -&gt; Box&lt;dyn MiddlewarePlugin&gt; = plugin.get(b"create_plugin")?;
let av_plugin = create_plugin();

let backend = av_plugin.wrap(backend);
<span class="boring">}</span></code></pre>
<p><strong>When to use each approach:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Approach</th><th>Overhead</th></tr>
</thead>
<tbody>
<tr><td>Fixed middleware stack</td><td>Generics (compile-time)</td><td>Zero-cost</td></tr>
<tr><td>Config-driven middleware</td><td><code>Box&lt;dyn Fs&gt;</code> chaining</td><td>~50ns per layer</td></tr>
<tr><td>Runtime-loaded plugins</td><td><code>MiddlewarePlugin</code> trait</td><td>~50ns + plugin load</td></tr>
</tbody>
</table>
</div>
<p><strong>Verdict:</strong> The current design supports dynamic middleware via <code>Box&lt;dyn Fs&gt;</code>. A formal <code>MiddlewarePlugin</code> trait for hot-loading is a future enhancement.</p>
<h3 id="middleware-with-configurable-backends"><a class="header" href="#middleware-with-configurable-backends">Middleware with Configurable Backends</a></h3>
<p>Some middleware benefit from pluggable backends for their own storage or output. The pattern is to inject a trait object or configuration at construction time.</p>
<p><strong>Metrics Middleware with Prometheus Exporter:</strong>
<em>(Requires <code>features = ["metrics"]</code>)</em></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, Registry};

pub struct Metrics&lt;B&gt; {
    inner: B,
    reads: Counter,
    writes: Counter,
    read_bytes: Counter,
    write_bytes: Counter,
    latency: Histogram,
}

impl&lt;B&gt; Metrics&lt;B&gt; {
    pub fn new(inner: B, registry: &amp;Registry) -&gt; Self {
        let reads = Counter::new("anyfs_reads_total", "Total read operations").unwrap();
        let writes = Counter::new("anyfs_writes_total", "Total write operations").unwrap();
        registry.register(Box::new(reads.clone())).unwrap();
        registry.register(Box::new(writes.clone())).unwrap();
        // ... register all metrics
        Self { inner, reads, writes, /* ... */ }
    }
}

impl&lt;B: FsRead&gt; FsRead for Metrics&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.reads.inc();
        let start = Instant::now();
        let result = self.inner.read(path);
        self.latency.observe(start.elapsed().as_secs_f64());
        if let Ok(ref data) = result {
            self.read_bytes.inc_by(data.len() as u64);
        }
        result
    }
}

// Expose via HTTP endpoint
async fn metrics_handler(registry: web::Data&lt;Registry&gt;) -&gt; impl Responder {
    let encoder = TextEncoder::new();
    let metrics = registry.gather();
    encoder.encode_to_string(&amp;metrics).unwrap()
}
<span class="boring">}</span></code></pre>
<p><strong>Indexing Middleware with Remote Database:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IndexBackend: Send + Sync {
    fn record_write(&amp;self, path: &amp;Path, size: u64, hash: &amp;str) -&gt; Result&lt;(), IndexError&gt;;
    fn record_delete(&amp;self, path: &amp;Path) -&gt; Result&lt;(), IndexError&gt;;
    fn query(&amp;self, pattern: &amp;str) -&gt; Result&lt;Vec&lt;IndexEntry&gt;, IndexError&gt;;
}

// SQLite implementation
pub struct SqliteIndex { conn: Connection }

// PostgreSQL implementation  
pub struct PostgresIndex { pool: PgPool }

// MariaDB implementation
pub struct MariaDbIndex { pool: MySqlPool }

pub struct Indexing&lt;B, I: IndexBackend&gt; {
    inner: B,
    index: I,
}

impl&lt;B: FsWrite, I: IndexBackend&gt; FsWrite for Indexing&lt;B, I&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.inner.write(path, data)?;
        let hash = sha256(data);
        self.index.record_write(path, data.len() as u64, &amp;hash)
            .map_err(|e| FsError::Backend(e.to_string()))?;
        Ok(())
    }
}

// Usage with PostgreSQL
let index = PostgresIndex::connect("postgres://user:pass@db.example.com/files").await?;
let backend = MemoryBackend::new()
    .layer(IndexingLayer::new(index));
<span class="boring">}</span></code></pre>
<p><strong>Configurable Tracing with Multiple Sinks:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TraceSink: Send + Sync {
    fn log_operation(&amp;self, op: &amp;Operation);
}

// Structured JSON logs
pub struct JsonSink { writer: Box&lt;dyn Write + Send&gt; }

// CEF (Common Event Format) for SIEM integration
pub struct CefSink { 
    host: String,
    port: u16,
    device_vendor: String 
}

impl TraceSink for CefSink {
    fn log_operation(&amp;self, op: &amp;Operation) {
        let cef = format!(
            "CEF:0|AnyFS|FileStorage|1.0|{}|{}|{}|src={} dst={}",
            op.event_id, op.name, op.severity, op.source_path, op.dest_path
        );
        self.send_syslog(&amp;cef);
    }
}

// Remote sink (e.g., Loki, Elasticsearch)
pub struct RemoteSink { endpoint: String, client: reqwest::Client }

pub struct Tracing&lt;B, S: TraceSink&gt; {
    inner: B,
    sink: S,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="performance-strategic-boxing-adr-025"><a class="header" href="#performance-strategic-boxing-adr-025">Performance: Strategic Boxing (ADR-025)</a></h2>
<p>AnyFS follows Tower/Axum’s approach to dynamic dispatch: <strong>zero-cost on the hot path, box at boundaries where flexibility is needed</strong>. We avoid heap allocations and dynamic dispatch unless they add flexibility without meaningful performance impact.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Operations</th><th>Cost</th></tr>
</thead>
<tbody>
<tr><td><strong>Hot path</strong> (zero-cost)</td><td><code>read()</code>, <code>write()</code>, <code>metadata()</code>, <code>exists()</code></td><td>Concrete types, no boxing</td></tr>
<tr><td><strong>Hot path</strong> (zero-cost)</td><td>Middleware composition: <code>Quota&lt;Tracing&lt;B&gt;&gt;</code></td><td>Generics, monomorphized</td></tr>
<tr><td><strong>Cold path</strong> (boxed)</td><td><code>open_read()</code>, <code>open_write()</code>, <code>read_dir()</code></td><td>One <code>Box</code> allocation per call</td></tr>
<tr><td><strong>Opt-in</strong></td><td><code>FileStorage::boxed()</code></td><td>Explicit type erasure</td></tr>
</tbody>
</table>
</div>
<p><strong>Hot-loop guidance:</strong> If you open many small files and care about micro-overhead (especially on virtual backends), prefer <code>read()</code>/<code>write()</code> or the typed streaming extension (<code>FsReadTyped</code>/<code>FsWriteTyped</code>) when the backend type is known. These are the zero-allocation fast paths.</p>
<p><strong>Why box streams and iterators?</strong></p>
<ol>
<li>Middleware needs to wrap them (<code>QuotaWriter</code> counts bytes, <code>PathFilter</code> filters entries)</li>
<li>Box allocation (~50ns) is &lt;1% of actual I/O time</li>
<li>Avoids type explosion: <code>QuotaReader&lt;PathFilterReader&lt;TracingReader&lt;Cursor&lt;...&gt;&gt;&gt;&gt;</code></li>
</ol>
<p><strong>Why NOT box bulk operations?</strong></p>
<ol>
<li><code>read()</code> and <code>write()</code> are the most common operations</li>
<li>They return concrete types (<code>Vec&lt;u8&gt;</code>, <code>()</code>)</li>
<li>Zero overhead for the typical use case</li>
</ol>
<p>See <a href="#adr-025-strategic-boxing-tower-style">ADR-025</a> and <a href="#zero-cost-alternatives-for-io-operations">Zero-Cost Alternatives</a> for full analysis.</p>
<hr>
<h2 id="trait-architecture-in-anyfs-backend"><a class="header" href="#trait-architecture-in-anyfs-backend">Trait Architecture (in <code>anyfs-backend</code>)</a></h2>
<p>AnyFS uses <strong>layered traits</strong> for maximum flexibility with minimal complexity.</p>
<p>See ADR-030 for the rationale behind the layered hierarchy.</p>
<pre><code>                        FsPosix
                           │
            ┌──────────────┼──────────────┐
            │              │              │
       FsHandles      FsLock       FsXattr
            │              │              │
            └──────────────┼──────────────┘
                           │
                        FsFuse
                           │
                       FsInode
                           │
                        FsFull
                           │
            ┌──────┬───────┼───────┬──────┐
            │      │       │       │      │
       FsLink  FsPerm  FsSync FsStats │
            │      │       │       │      │
            └──────┴───────┼───────┴──────┘
                           │
                           Fs  ← Most users only need this
                           │
               ┌───────────┼───────────┐
               │           │           │
            FsRead    FsWrite     FsDir
</code></pre>
<p><strong>Simple rule:</strong> Import <code>Fs</code> for basic use. Add traits as needed for advanced features.</p>
<hr>
<h2 id="core-traits-layer-1"><a class="header" href="#core-traits-layer-1">Core Traits (Layer 1)</a></h2>
<h3 id="fsread---read-operations"><a class="header" href="#fsread---read-operations">FsRead - Read Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt;;
    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt;;
    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt;;
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fswrite---write-operations"><a class="header" href="#fswrite---write-operations">FsWrite - Write Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsWrite: Send + Sync {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn append(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn truncate(&amp;self, path: &amp;Path, size: u64) -&gt; Result&lt;(), FsError&gt;;
    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<blockquote>
<p><strong>Note:</strong> All methods use <code>&amp;self</code> (interior mutability). Backends manage their own synchronization. See ADR-023.</p>
</blockquote>
<h3 id="fsdir---directory-operations"><a class="header" href="#fsdir---directory-operations">FsDir - Directory Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsDir: Send + Sync {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt;;
    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="extended-traits-layer-2---optional"><a class="header" href="#extended-traits-layer-2---optional">Extended Traits (Layer 2 - Optional)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLink: Send + Sync {
    fn symlink(&amp;self, original: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn hard_link(&amp;self, original: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn read_link(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn symlink_metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt;;
}

pub trait FsPermissions: Send + Sync {
    fn set_permissions(&amp;self, path: &amp;Path, perm: Permissions) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsSync: Send + Sync {
    fn sync(&amp;self) -&gt; Result&lt;(), FsError&gt;;
    fn fsync(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsStats: Send + Sync {
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="inode-traits-layer-3---for-fuse"><a class="header" href="#inode-traits-layer-3---for-fuse">Inode Traits (Layer 3 - For FUSE)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsInode: Send + Sync {
    fn path_to_inode(&amp;self, path: &amp;Path) -&gt; Result&lt;u64, FsError&gt;;
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt;;
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="posix-traits-layer-4---full-posix"><a class="header" href="#posix-traits-layer-4---full-posix">POSIX Traits (Layer 4 - Full POSIX)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsHandles: Send + Sync {
    fn open(&amp;self, path: &amp;Path, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt;;
    fn read_at(&amp;self, handle: Handle, buf: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn write_at(&amp;self, handle: Handle, data: &amp;[u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsLock: Send + Sync {
    fn lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;(), FsError&gt;;
    fn try_lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;bool, FsError&gt;;
    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}

pub trait FsXattr: Send + Sync {
    fn get_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn set_xattr(&amp;self, path: &amp;Path, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;(), FsError&gt;;
    fn list_xattr(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="convenience-supertraits-simple-api"><a class="header" href="#convenience-supertraits-simple-api">Convenience Supertraits (Simple API)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Basic filesystem - covers 90% of use cases
pub trait Fs: FsRead + FsWrite + FsDir {}
impl&lt;T: FsRead + FsWrite + FsDir&gt; Fs for T {}

/// Full filesystem with all std::fs features
pub trait FsFull: Fs + FsLink + FsPermissions + FsSync + FsStats {}
impl&lt;T: Fs + FsLink + FsPermissions + FsSync + FsStats&gt; FsFull for T {}

/// FUSE-mountable filesystem
pub trait FsFuse: FsFull + FsInode {}
impl&lt;T: FsFull + FsInode&gt; FsFuse for T {}

/// Full POSIX filesystem
pub trait FsPosix: FsFuse + FsHandles + FsLock + FsXattr {}
impl&lt;T: FsFuse + FsHandles + FsLock + FsXattr&gt; FsPosix for T {}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<p>Application code should use <code>FileStorage</code> for the std::fs-style DX (string paths). Core trait examples are shown separately for implementers and generic code.</p>
<h3 id="most-users-filestorage"><a class="header" href="#most-users-filestorage">Most Users: FileStorage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, MemoryBackend};

fn process_files() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fs = FileStorage::new(MemoryBackend::new());
    let data = fs.read("/input.txt")?;
    fs.write("/output.txt", &amp;processed(data))?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="generic-code-over-core-traits"><a class="header" href="#generic-code-over-core-traits">Generic Code over Core Traits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, Fs};

fn process_files&lt;B: Fs&gt;(fs: &amp;FileStorage&lt;B&gt;) {
    let data = fs.read("/input.txt")?;
    fs.write("/output.txt", &amp;processed(data))?;
}
<span class="boring">}</span></code></pre>
<h3 id="need-links-add-the-trait"><a class="header" href="#need-links-add-the-trait">Need Links? Add the Trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, Fs, FsLink};

fn with_symlinks&lt;B: Fs + FsLink&gt;(fs: &amp;FileStorage&lt;B&gt;) {
    fs.write("/target.txt", b"content")?;
    fs.symlink("/target.txt", "/link.txt")?;
}
<span class="boring">}</span></code></pre>
<h3 id="fuse-mount"><a class="header" href="#fuse-mount">FUSE Mount</a></h3>
<p>Mounting is part of <code>anyfs</code> crate with <code>fuse</code> and <code>winfsp</code> feature flags; see <code>src/guides/mounting.md</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FsFuse, MountHandle};

fn mount_filesystem(fs: impl FsFuse) {
    MountHandle::mount(fs, "/mnt/myfs")?;
}
<span class="boring">}</span></code></pre>
<h3 id="full-posix-application"><a class="header" href="#full-posix-application">Full POSIX Application</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, FsPosix};

fn database_app&lt;B: FsPosix&gt;(fs: &amp;FileStorage&lt;B&gt;) {
    let handle = fs.open("/data.db", OpenFlags::READ_WRITE)?;
    fs.lock(handle, LockType::Exclusive)?;
    fs.write_at(handle, data, offset)?;
    fs.unlock(handle)?;
    fs.close(handle)?;
}

---

# Core Types (in `anyfs-backend`)

## Constants

```rust
/// Root directory inode. FUSE convention.
pub const ROOT_INODE: u64 = 1;
<span class="boring">}</span></code></pre>
<h3 id="metadata"><a class="header" href="#metadata">Metadata</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// File or directory metadata.
#[derive(Debug, Clone)]
pub struct Metadata {
    /// Type: File, Directory, or Symlink.
    pub file_type: FileType,

    /// Size in bytes (0 for directories).
    pub size: u64,

    /// Permission mode bits. Default to 0o755/0o644 if unsupported.
    pub permissions: Permissions,

    /// Creation time (UNIX_EPOCH if unsupported).
    pub created: SystemTime,

    /// Last modification time.
    pub modified: SystemTime,

    /// Last access time.
    pub accessed: SystemTime,

    /// Inode number (0 if unsupported).
    pub inode: u64,

    /// Number of hard links (1 if unsupported).
    pub nlink: u64,
}

impl Metadata {
    /// Check if this is a file.
    pub fn is_file(&amp;self) -&gt; bool { self.file_type == FileType::File }

    /// Check if this is a directory.
    pub fn is_dir(&amp;self) -&gt; bool { self.file_type == FileType::Directory }

    /// Check if this is a symlink.
    pub fn is_symlink(&amp;self) -&gt; bool { self.file_type == FileType::Symlink }
}
<span class="boring">}</span></code></pre>
<h3 id="filetype"><a class="header" href="#filetype">FileType</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FileType {
    File,
    Directory,
    Symlink,
}
<span class="boring">}</span></code></pre>
<h3 id="direntry"><a class="header" href="#direntry">DirEntry</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Entry in a directory listing.
#[derive(Debug, Clone)]
pub struct DirEntry {
    /// File or directory name (not full path).
    pub name: String,

    /// Full path to the entry.
    pub path: PathBuf,

    /// Type: File, Directory, or Symlink.
    pub file_type: FileType,

    /// Size in bytes (0 for directories, can be lazy).
    pub size: u64,

    /// Inode number (0 if unsupported).
    pub inode: u64,
}
<span class="boring">}</span></code></pre>
<h3 id="permissions"><a class="header" href="#permissions">Permissions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Unix-style permission bits.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Permissions(u32);

impl Permissions {
    /// Create permissions from a mode (e.g., 0o755).
    pub fn from_mode(mode: u32) -&gt; Self { Permissions(mode) }

    /// Get the mode bits.
    pub fn mode(&amp;self) -&gt; u32 { self.0 }

    /// Read-only permissions (0o444).
    pub fn readonly() -&gt; Self { Permissions(0o444) }

    /// Default file permissions (0o644).
    pub fn default_file() -&gt; Self { Permissions(0o644) }

    /// Default directory permissions (0o755).
    pub fn default_dir() -&gt; Self { Permissions(0o755) }
}
<span class="boring">}</span></code></pre>
<h3 id="statfs"><a class="header" href="#statfs">StatFs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Filesystem statistics.
#[derive(Debug, Clone)]
pub struct StatFs {
    /// Total size in bytes (0 = unlimited).
    pub total_bytes: u64,

    /// Used bytes.
    pub used_bytes: u64,

    /// Available bytes.
    pub available_bytes: u64,

    /// Total number of inodes (0 = unlimited).
    pub total_inodes: u64,

    /// Used inodes.
    pub used_inodes: u64,

    /// Available inodes.
    pub available_inodes: u64,

    /// Filesystem block size.
    pub block_size: u64,

    /// Maximum filename length.
    pub max_name_len: u64,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware-in-anyfs"><a class="header" href="#middleware-in-anyfs">Middleware (in <code>anyfs</code>)</a></h2>
<p>Each middleware implements the same traits as its inner backend. This enables composition while preserving capabilities.</p>
<h3 id="quota"><a class="header" href="#quota">Quota<b></b></a></h3>
<p>Enforces quota limits. Tracks usage and rejects operations that would exceed limits.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota};

let backend = QuotaLayer::builder()
    .max_total_size(100 * 1024 * 1024)   // 100 MB
    .max_file_size(10 * 1024 * 1024)     // 10 MB per file
    .max_node_count(10_000)              // 10K files/dirs
    .max_dir_entries(1_000)              // 1K entries per dir
    .max_path_depth(64)
    .build()
    .layer(SqliteBackend::open("data.db")?);

// Check usage
let usage = backend.usage();
let remaining = backend.remaining();
<span class="boring">}</span></code></pre>
<h3 id="restrictions"><a class="header" href="#restrictions">Restrictions<b></b></a></h3>
<p>Blocks permission-related operations when needed.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Restrictions};

// Symlink/hard-link capability is determined by trait bounds (FsLink).
// Restrictions only controls permission changes.
let backend = RestrictionsLayer::builder()
    .deny_permissions()    // Block set_permissions() calls
    .build()
    .layer(MemoryBackend::new());
<span class="boring">}</span></code></pre>
<p>When blocked, operations return <code>FsError::FeatureNotEnabled</code>.</p>
<h3 id="tracing"><a class="header" href="#tracing">Tracing<b></b></a></h3>
<p>Integrates with the <a href="https://docs.rs/tracing">tracing</a> ecosystem for structured logging and instrumentation.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, TracingLayer};

let backend = SqliteBackend::open("data.db")?
    .layer(TracingLayer::new()
        .with_target("anyfs")
        .with_level(tracing::Level::DEBUG));

// Users configure tracing subscribers as they prefer
tracing_subscriber::fmt::init();
<span class="boring">}</span></code></pre>
<p><strong>Why tracing instead of custom logging?</strong></p>
<ul>
<li>Works with existing tracing infrastructure</li>
<li>Structured logging with spans</li>
<li>Compatible with OpenTelemetry, Jaeger, etc.</li>
<li>Users choose their subscriber (console, file, distributed tracing)</li>
</ul>
<h3 id="pathfilter"><a class="header" href="#pathfilter">PathFilter<b></b></a></h3>
<p>Restricts access to specific paths. Essential for sandboxing.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, PathFilter};

let backend = PathFilterLayer::builder()
    .allow("/workspace/**")           // Allow all under /workspace
    .allow("/tmp/**")                  // Allow temp files
    .deny("/workspace/.env")           // But deny .env files
    .deny("**/.git/**")               // Deny all .git directories
    .build()
    .layer(MemoryBackend::new());
<span class="boring">}</span></code></pre>
<p>When a path is denied, operations return <code>FsError::AccessDenied</code>.</p>
<h3 id="readonly"><a class="header" href="#readonly">ReadOnly<b></b></a></h3>
<p>Prevents all write operations. Useful for publishing immutable data.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, ReadOnly, FileStorage};

// Wrap any backend to make it read-only
let backend = ReadOnly::new(SqliteBackend::open("published.db")?);
let fs = FileStorage::new(backend);

fs.read("/doc.txt")?;     // OK
fs.write("/doc.txt", b"x"); // Error: FsError::ReadOnly
<span class="boring">}</span></code></pre>
<h3 id="ratelimit"><a class="header" href="#ratelimit">RateLimit<b></b></a></h3>
<p>Limits operations per second. Prevents runaway agents.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, RateLimit};
use std::time::Duration;

let backend = RateLimitLayer::builder()
    .max_ops(100)                        // 100 ops per window
    .window(Duration::from_secs(1))      // 1 second window
    .max_burst(10)                       // Allow bursts up to 10
    .build()
    .layer(MemoryBackend::new());

// When rate exceeded: FsError::RateLimitExceeded
<span class="boring">}</span></code></pre>
<h3 id="dryrun"><a class="header" href="#dryrun">DryRun<b></b></a></h3>
<p>Logs operations without executing writes. Great for testing and debugging.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, DryRun, FileStorage};

let backend = DryRun::new(MemoryBackend::new());
let fs = FileStorage::new(backend);

fs.write("/test.txt", b"hello")?;  // Logged but not written
let _ = fs.read("/test.txt");       // Error: file doesn't exist

// To inspect recorded operations, keep the DryRun handle before wrapping it.
<span class="boring">}</span></code></pre>
<h3 id="cache"><a class="header" href="#cache">Cache<b></b></a></h3>
<p>LRU cache for read operations. Essential for slow backends (S3, network).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Cache, FileStorage};

let backend = CacheLayer::builder()
    .max_size(100 * 1024 * 1024)      // 100 MB cache
    .max_entries(10_000)              // Max 10K entries
    .build()
    .layer(SqliteBackend::open("data.db")?);
let fs = FileStorage::new(backend);

// First read: hits backend, caches result
let data = fs.read("/file.txt")?;

// Second read: served from cache (fast!)
let data = fs.read("/file.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="overlaybase-upper"><a class="header" href="#overlaybase-upper">Overlay&lt;Base, Upper&gt;</a></h3>
<p>Union filesystem with a read-only base and writable upper layer. Like Docker.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, MemoryBackend, Overlay};

// Base: read-only template
let base = SqliteBackend::open("template.db")?;

// Upper: writable layer for changes
let upper = MemoryBackend::new();

let backend = Overlay::new(base, upper);

// Reads check upper first, then base
// Writes always go to upper
// Deletes in upper "shadow" base files
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Container images (base image + writable layer)</li>
<li>Template filesystems with per-user modifications</li>
<li>Testing with rollback capability</li>
</ul>
<hr>
<h2 id="filestorageb-r-m-in-anyfs"><a class="header" href="#filestorageb-r-m-in-anyfs">FileStorage&lt;B, R, M&gt; (in <code>anyfs</code>)</a></h2>
<p><code>FileStorage&lt;B, R, M&gt;</code> is a <strong>zero-cost ergonomic wrapper</strong> with:</p>
<ul>
<li><strong><code>B</code></strong> - Backend type (generic, no boxing)</li>
<li><strong><code>R</code></strong> - PathResolver type (default: <code>IterativeResolver</code>)</li>
<li><strong><code>M</code></strong> - Optional marker type for compile-time safety</li>
</ul>
<p><strong>Axum-style design:</strong> Zero-cost by default, type erasure opt-in via <code>.boxed()</code>.</p>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FileStorage};

// Type is inferred - no need to write it out
let fs = FileStorage::new(MemoryBackend::new());

fs.create_dir_all("/documents")?;
fs.write("/documents/hello.txt", b"Hello!")?;
let content = fs.read("/documents/hello.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="marker-types-type-safe-containers"><a class="header" href="#marker-types-type-safe-containers">Marker Types (Type-Safe Containers)</a></h3>
<p>Use <code>_</code> to infer backend while specifying marker:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, FileStorage};

// Define marker types for your domains
struct Sandbox;
struct UserData;

// Specify marker, infer backend and resolver with _
let sandbox: FileStorage&lt;_, _, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
let userdata: FileStorage&lt;_, _, UserData&gt; = FileStorage::new(SqliteBackend::open("data.db")?);

// Type-safe function signatures prevent mixing containers
fn process_sandbox(fs: &amp;FileStorage&lt;impl Fs, IterativeResolver, Sandbox&gt;) {
    // Can only accept Sandbox-marked containers
}

fn save_user_file(fs: &amp;FileStorage&lt;impl Fs, IterativeResolver, UserData&gt;, name: &amp;str, data: &amp;[u8]) {
    // Can only accept UserData-marked containers
}

// Compile-time safety:
process_sandbox(&amp;sandbox);   // OK
process_sandbox(&amp;userdata);  // Compile error! Type mismatch
<span class="boring">}</span></code></pre>
<h3 id="self-documenting-types"><a class="header" href="#self-documenting-types">Self-Documenting Types</a></h3>
<p>Both type parameters are meaningful:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FileStorage&lt;SqliteBackend, IterativeResolver, TenantA&gt;   // SQLite storage for TenantA
FileStorage&lt;MemoryBackend, IterativeResolver, Sandbox&gt;   // In-memory sandbox
FileStorage&lt;StdFsBackend, IterativeResolver, Production&gt; // Real filesystem, production
<span class="boring">}</span></code></pre>
<h3 id="type-aliases-for-clean-code"><a class="header" href="#type-aliases-for-clean-code">Type Aliases for Clean Code</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define your standard secure stack
type SecureBackend = Tracing&lt;Restrictions&lt;Quota&lt;SqliteBackend&gt;&gt;&gt;;

// Type aliases for common combinations
type SandboxFs = FileStorage&lt;MemoryBackend, IterativeResolver, Sandbox&gt;;
type UserDataFs = FileStorage&lt;SecureBackend, IterativeResolver, UserData&gt;;

// Clean function signatures
fn run_agent(fs: &amp;SandboxFs) { ... }
<span class="boring">}</span></code></pre>
<h3 id="filestorage-implementation"><a class="header" href="#filestorage-implementation">FileStorage Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;
use anyfs_backend::PathResolver;
use anyfs::resolvers::IterativeResolver;

/// Zero-cost ergonomic wrapper.
/// Generic over backend (B), resolver (R), and marker (M).
pub struct FileStorage&lt;B, R = IterativeResolver, M = ()&gt; {
    backend: B,
    resolver: R,
    _marker: PhantomData&lt;M&gt;,
}

impl&lt;B: Fs, M&gt; FileStorage&lt;B, IterativeResolver, M&gt; {
    /// Create with default resolver (IterativeResolver).
    /// Marker type is specified via type annotation:
    /// `let fs: FileStorage&lt;_, _, MyMarker&gt; = FileStorage::new(backend);`
    pub fn new(backend: B) -&gt; Self { ... }
}

impl&lt;B: Fs, R: PathResolver, M&gt; FileStorage&lt;B, R, M&gt; {
    /// Create with custom path resolver (see ADR-033).
    pub fn with_resolver(backend: B, resolver: R) -&gt; Self { ... }

    /// Type-erase the backend (opt-in boxing).
    /// Note: resolver type is preserved.
    pub fn boxed(self) -&gt; FileStorage&lt;Box&lt;dyn Fs&gt;, R, M&gt; { ... }
}
<span class="boring">}</span></code></pre>
<h3 id="type-erasure-opt-in"><a class="header" href="#type-erasure-opt-in">Type Erasure (Opt-in)</a></h3>
<p>When you need uniform types (e.g., collections), use <code>.boxed()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type-erased for uniform storage
let filesystems: Vec&lt;FileStorage&lt;Box&lt;dyn Fs&gt;&gt;&gt; = vec![
    FileStorage::new(MemoryBackend::new()).boxed(),
    FileStorage::new(SqliteBackend::open("a.db")?).boxed(),
];
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-trait-in-anyfs-backend"><a class="header" href="#layer-trait-in-anyfs-backend">Layer Trait (in <code>anyfs-backend</code>)</a></h2>
<p>The <code>Layer</code> trait (inspired by Tower) standardizes middleware composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A layer that wraps a backend to add functionality.
pub trait Layer&lt;B: Fs&gt; {
    type Backend: Fs;
    fn layer(self, backend: B) -&gt; Self::Backend;
}
<span class="boring">}</span></code></pre>
<p>Each middleware provides a corresponding <code>Layer</code> implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// QuotaLayer, TracingLayer, RestrictionsLayer, etc.
pub struct QuotaLayer { limits: QuotaLimits }

impl&lt;B: Fs&gt; Layer&lt;B&gt; for QuotaLayer {
    type Backend = Quota&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend {
        Quota::from_limits(self.limits).layer(backend)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> Middleware that implements additional traits (like <code>FsInode</code>) can use more specific bounds to preserve capabilities through the layer.</p>
<hr>
<h2 id="composing-middleware"><a class="header" href="#composing-middleware">Composing Middleware</a></h2>
<p>Middleware composes by wrapping. Order matters - innermost applies first.</p>
<h3 id="fluent-composition"><a class="header" href="#fluent-composition">Fluent Composition</a></h3>
<p>Use the <code>.layer()</code> extension method for Axum-style composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, TracingLayer};

let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(RestrictionsLayer::builder()
        .deny_permissions()  // Block set_permissions()
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<h3 id="backendstack-builder"><a class="header" href="#backendstack-builder">BackendStack Builder</a></h3>
<p>For complex stacks, use <code>BackendStack</code> for a fluent API:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::BackendStack;

let fs = BackendStack::new(SqliteBackend::open("data.db")?)
    .limited(|l| l
        .max_total_size(100 * 1024 * 1024)
        .max_file_size(10 * 1024 * 1024))
    .restricted(|g| g
        .deny_permissions())    // Block set_permissions() calls
    .traced()
    .into_container();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="built-in-backends-1"><a class="header" href="#built-in-backends-1">Built-in Backends</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td><code>memory</code> (default)</td><td>In-memory storage</td></tr>
<tr><td><code>SqliteBackend</code></td><td><code>sqlite</code></td><td>Single-file portable database</td></tr>
<tr><td><code>SqliteCipherBackend</code></td><td><code>sqlite-cipher</code></td><td>Encrypted SQLite via SQLCipher (AES-256)</td></tr>
<tr><td><code>IndexedBackend</code></td><td><code>indexed</code></td><td>Virtual paths + disk blobs (large file support with isolation)</td></tr>
<tr><td><code>StdFsBackend</code></td><td><code>stdfs</code></td><td>Direct <code>std::fs</code> delegation (no containment)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td><code>vrootfs</code></td><td>Host filesystem with path containment (via strict-path)</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> <code>sqlite</code> and <code>sqlite-cipher</code> features are mutually exclusive (both use rusqlite with different SQLite builds).</p>
<hr>
<h2 id="path-handling"><a class="header" href="#path-handling">Path Handling</a></h2>
<p>Core traits take <code>&amp;Path</code> so they are object-safe (<code>dyn Fs</code> works). The ergonomic layer (<code>FileStorage</code> and <code>FsExt</code>) accepts <code>impl AsRef&lt;Path&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These work via FileStorage/FsExt
fs.write("/file.txt", data)?;
fs.write(String::from("/file.txt"), data)?;
fs.write(PathBuf::from("/file.txt"), data)?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-resolution"><a class="header" href="#path-resolution">Path Resolution</a></h2>
<p>Path resolution (walking directory structure, following symlinks) operates on the <strong><code>Fs</code> abstraction</strong>, not reimplemented per-backend.</p>
<p>See ADR-029 for the path-resolution decision.</p>
<h3 id="why-abstract-path-resolution"><a class="header" href="#why-abstract-path-resolution">Why Abstract Path Resolution?</a></h3>
<p>We simulate inodes - that’s the whole point of virtualizing a filesystem. Path resolution must work on that abstraction:</p>
<ul>
<li><code>/foo/../bar</code> cannot be resolved lexically - <code>foo</code> might be a symlink to <code>/other/place</code>, making <code>..</code> resolve to <code>/other</code></li>
<li>Resolution requires following the actual directory structure (inodes)</li>
<li>The <code>Fs</code> traits have the needed methods: <code>metadata()</code>, <code>read_link()</code>, <code>read_dir()</code></li>
</ul>
<h3 id="path-resolution-via-pathresolver-trait"><a class="header" href="#path-resolution-via-pathresolver-trait">Path Resolution via PathResolver Trait</a></h3>
<p><code>FileStorage</code> delegates path resolution to a pluggable <code>PathResolver</code> (see ADR-033). The default <code>IterativeResolver</code> walks paths component by component:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Default resolver algorithm (simplified):
/// - Walk path component by component
/// - Use backend.metadata() to check node types
/// - If backend implements FsLink, use read_link() to follow symlinks
/// - Detect circular symlinks (max depth: 40)
/// - Return fully resolved canonical path
pub struct IterativeResolver {
    max_symlink_depth: usize,  // Default: 40
}
<span class="boring">}</span></code></pre>
<p><strong>Resolution behavior depends on the resolver used.</strong> The default <code>IterativeResolver</code> follows symlinks when the backend implements <code>FsLink</code>. For backends without <code>FsLink</code>, it traverses directories but treats symlinks as regular files. Users can provide custom resolvers for case-insensitive matching, caching, or other behaviors.</p>
<p><strong>Note:</strong> All built-in virtual backends (MemoryBackend, SqliteBackend) implement <code>FsLink</code>, so symlink-aware resolution works out of the box.</p>
<h3 id="when-resolution-is-needed"><a class="header" href="#when-resolution-is-needed">When Resolution Is Needed</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Needs Our Resolution?</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Yes</td><td>Storage (HashMap) has no FS semantics</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Yes</td><td>Storage (SQL tables) has no FS semantics</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>No</td><td>OS handles resolution; <code>strict-path</code> prevents escapes</td></tr>
</tbody>
</table>
</div>
<h3 id="opt-out-mechanism"><a class="header" href="#opt-out-mechanism">Opt-out Mechanism</a></h3>
<p>Virtual backends need resolution by default. Real filesystem backends opt out via a marker trait or associated constant:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Marker trait for backends that handle their own path resolution.
/// VRootFsBackend implements this because the OS handles resolution.
pub trait SelfResolving {}

impl SelfResolving for VRootFsBackend {}
<span class="boring">}</span></code></pre>
<p><code>FileStorage</code> applies resolution via its <code>PathResolver</code> for backends that don’t implement <code>SelfResolving</code>. The default <code>IterativeResolver</code> follows symlinks when <code>FsLink</code> is available. Custom resolvers can implement different behaviors (e.g., no symlink following, caching, case-insensitivity).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: Fs, M&gt; FileStorage&lt;B, IterativeResolver, M&gt; {
    pub fn new(backend: B) -&gt; Self { /* uses IterativeResolver */ }
}

impl&lt;B: Fs, R: PathResolver, M&gt; FileStorage&lt;B, R, M&gt; {
    pub fn with_resolver(backend: B, resolver: R) -&gt; Self { /* custom resolver */ }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-canonicalization-utilities"><a class="header" href="#path-canonicalization-utilities">Path Canonicalization Utilities</a></h2>
<p><code>FileStorage</code> provides path canonicalization methods modeled after the <a href="https://crates.io/crates/soft-canonicalize">soft-canonicalize</a> crate, adapted to work on the virtual filesystem abstraction.</p>
<h3 id="why-we-need-our-own-canonicalization"><a class="header" href="#why-we-need-our-own-canonicalization">Why We Need Our Own Canonicalization</a></h3>
<p><code>std::fs::canonicalize</code> operates on the <strong>real</strong> filesystem. For virtual backends (<code>MemoryBackend</code>, <code>SqliteBackend</code>), there is no real filesystem - we need canonicalization that queries the virtual structure via <code>metadata()</code> and <code>read_link()</code>.</p>
<h3 id="core-methods"><a class="header" href="#core-methods">Core Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: Fs, R: PathResolver, M&gt; FileStorage&lt;B, R, M&gt; {
    /// Strict canonicalization - entire path must exist.
    ///
    /// Delegates to the PathResolver to resolve symlinks and normalize the path.
    /// Returns error if any component doesn't exist.
    pub fn canonicalize(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.resolver.canonicalize(path.as_ref(), &amp;self.backend)
    }

    /// Soft canonicalization - resolves existing components,
    /// appends non-existent remainder lexically.
    ///
    /// Delegates to the PathResolver.
    pub fn soft_canonicalize(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.resolver.soft_canonicalize(path.as_ref(), &amp;self.backend)
    }
}
    ///
    /// Walks path component-by-component via the resolver:
    /// 1. For existing components → resolve symlinks, follow them
    /// 2. When hitting non-existent component → append remainder lexically
    ///
    /// Inspired by Python's `pathlib.Path.resolve(strict=False)`.
    pub fn soft_canonicalize(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt;;

    /// Anchored soft canonicalization - like soft_canonicalize but
    /// clamps result within a boundary directory.
    ///
    /// Useful for sandboxing: ensures the resolved path never escapes
    /// the anchor directory, even via symlinks or `..` traversal.
    pub fn anchored_canonicalize(
        &amp;self,
        path: impl AsRef&lt;Path&gt;,
        anchor: impl AsRef&lt;Path&gt;
    ) -&gt; Result&lt;PathBuf, FsError&gt;;
}

/// Standalone lexical normalization (no backend needed).
///
/// Pure string manipulation:
/// - Collapses `//` to `/`
/// - Removes trailing slashes
/// - Does NOT resolve `.` or `..` (those require filesystem context)
/// - Does NOT follow symlinks
pub fn normalize(path: impl AsRef&lt;Path&gt;) -&gt; PathBuf;
<span class="boring">}</span></code></pre>
<h3 id="algorithm-component-by-component-resolution"><a class="header" href="#algorithm-component-by-component-resolution">Algorithm: Component-by-Component Resolution</a></h3>
<p>The canonicalization algorithm walks the path one component at a time:</p>
<pre><code>Input: /a/b/c/d/e

1. Start at root (/)
2. Check /a exists?
   - Yes, and it's a symlink → follow to target
   - Yes, and it's a directory → continue
3. Check /a/b exists?
   - Yes → continue
4. Check /a/b/c exists?
   - No → stop resolution, append "c/d/e" lexically
5. Result: /resolved/path/to/b/c/d/e
</code></pre>
<p><strong>Key behaviors:</strong></p>
<ul>
<li><strong>Symlink following</strong>: Existing symlinks are resolved to their targets</li>
<li><strong>Non-existent handling</strong>: When a component doesn’t exist, the remainder is appended as-is</li>
<li><strong>Cycle detection</strong>: Bounded depth tracking prevents infinite loops from circular symlinks</li>
<li><strong>Root boundary</strong>: Never ascends past the filesystem root</li>
</ul>
<h3 id="comparison-with-stdfs"><a class="header" href="#comparison-with-stdfs">Comparison with std::fs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th><code>std::fs</code></th><th><code>FileStorage</code></th></tr>
</thead>
<tbody>
<tr><td><code>canonicalize</code></td><td>Requires all components exist</td><td>Same - returns error if path doesn’t exist</td></tr>
<tr><td>N/A</td><td>N/A</td><td><code>soft_canonicalize</code> - handles non-existent paths</td></tr>
<tr><td>N/A</td><td>N/A</td><td><code>anchored_canonicalize</code> - sandboxed resolution</td></tr>
</tbody>
</table>
</div>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<p><strong>For virtual backends:</strong> Canonicalization happens entirely within the virtual structure. There is no host filesystem to escape to.</p>
<p><strong>For <code>VRootFsBackend</code>:</strong> Delegates to OS canonicalization + <code>strict-path</code> containment. The <code>anchored_canonicalize</code> provides additional safety by clamping paths within a boundary.</p>
<h3 id="platform-notes-vrootfsbackend-only"><a class="header" href="#platform-notes-vrootfsbackend-only">Platform Notes (VRootFsBackend only)</a></h3>
<p>When delegating to OS canonicalization:</p>
<ul>
<li><strong>Windows</strong>: Returns extended-length UNC paths (<code>\\?\C:\path</code>) by default</li>
<li><strong>Linux/macOS</strong>: Standard canonical paths</li>
</ul>
<h4 id="windows-unc-path-simplification"><a class="header" href="#windows-unc-path-simplification">Windows UNC Path Simplification</a></h4>
<p>The <code>dunce</code> crate provides <code>simplified()</code> - a <strong>lexical</strong> function that converts UNC paths to regular paths without filesystem access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dunce::simplified;

// \\?\C:\Users\foo\bar.txt → C:\Users\foo\bar.txt
let path = simplified(r"\\?\C:\Users\foo\bar.txt");
<span class="boring">}</span></code></pre>
<p><strong>Why this matters for <code>soft_canonicalize</code>:</strong></p>
<ul>
<li><code>soft_canonicalize</code> works with non-existent paths</li>
<li>We can’t use <code>dunce::canonicalize</code> (requires path to exist)</li>
<li><code>dunce::simplified</code> is pure string manipulation - works on any path</li>
</ul>
<p><strong>When UNC can be simplified:</strong></p>
<ul>
<li>Path is on a local drive (C:, D:, etc.)</li>
<li>Path doesn’t exceed MAX_PATH (260 chars)</li>
<li>No reserved names (CON, PRN, etc.)</li>
</ul>
<p><strong>When UNC must be kept:</strong></p>
<ul>
<li>Network paths (<code>\\?\UNC\server\share</code>)</li>
<li>Paths exceeding MAX_PATH</li>
<li>Paths with reserved device names</li>
</ul>
<p>Virtual backends have no platform differences - paths are just strings.</p>
<hr>
<h2 id="filesystem-semantics-linux-like-by-default"><a class="header" href="#filesystem-semantics-linux-like-by-default">Filesystem Semantics: Linux-like by Default</a></h2>
<p><strong>Design principle:</strong> Simple, secure defaults. Don’t close doors for alternative semantics.</p>
<p>See ADR-028 for the decision rationale.</p>
<h3 id="default-behavior-built-in-backends"><a class="header" href="#default-behavior-built-in-backends">Default Behavior (Built-in Backends)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Behavior</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Case sensitivity</td><td><strong>Case-sensitive</strong></td><td>Simpler, more secure, Unix standard</td></tr>
<tr><td>Path separator</td><td><strong><code>/</code> internally</strong></td><td>Cross-platform consistency</td></tr>
<tr><td>Reserved names</td><td><strong>None</strong></td><td>No artificial restrictions</td></tr>
<tr><td>Max path length</td><td><strong>No limit</strong></td><td>Virtual, no OS constraints</td></tr>
<tr><td>ADS (<code>:stream</code>)</td><td><strong>Not supported</strong></td><td>Security risk, complexity</td></tr>
</tbody>
</table>
</div>
<h3 id="trait-is-agnostic"><a class="header" href="#trait-is-agnostic">Trait is Agnostic</a></h3>
<p>The <code>Fs</code> trait doesn’t enforce filesystem semantics - backends decide their behavior:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, MemoryBackend};
use std::path::Path;

// Built-in backends: Linux-like (case-sensitive)
let linux_fs = FileStorage::new(MemoryBackend::new());
assert!(linux_fs.exists("/Foo.txt")? != linux_fs.exists("/foo.txt")?);

// For case-insensitive behavior, implement a custom PathResolver:
// (Not built-in because real-world demand is minimal - VRootFsBackend on 
// Windows/macOS already gets case-insensitivity from the OS)
struct CaseFoldingResolver;
impl PathResolver for CaseFoldingResolver {
    fn canonicalize(&amp;self, path: &amp;Path, fs: &amp;dyn Fs) -&gt; Result&lt;PathBuf, FsError&gt; {
        // Normalize path components to lowercase during lookup
        todo!()
    }
    
    fn soft_canonicalize(&amp;self, path: &amp;Path, fs: &amp;dyn Fs) -&gt; Result&lt;PathBuf, FsError&gt; {
        // Same but allows non-existent final component
        todo!()
    }
}

let ntfs_like = FileStorage::with_resolver(
    MemoryBackend::new(),
    CaseFoldingResolver  // User-implemented
);
<span class="boring">}</span></code></pre>
<h3 id="fuse-mount-report-what-you-support"><a class="header" href="#fuse-mount-report-what-you-support">FUSE Mount: Report What You Support</a></h3>
<p>When mounting, the FUSE layer reports backend capabilities to the OS:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FuseOps for AnyFsFuse&lt;B&gt; {
    fn get_volume_params(&amp;self) -&gt; VolumeParams {
        VolumeParams {
            case_sensitive: self.backend.is_case_sensitive(),
            supports_hard_links: /* check if B: FsLink */,
            supports_symlinks: /* check if B: FsLink */,
            // ...
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Windows respects these flags - a case-sensitive mounted filesystem works correctly (modern Windows/WSL handle this).</p>
<h3 id="illustrative-custom-middleware-for-windows-compatibility"><a class="header" href="#illustrative-custom-middleware-for-windows-compatibility">Illustrative: Custom Middleware for Windows Compatibility</a></h3>
<p>For users who need Windows-safe paths in virtual backends, here are example middleware patterns (not built-in - implement as needed):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Example: Middleware that validates paths are Windows-compatible.
/// Rejects: CON, PRN, NUL, COM1-9, LPT1-9, trailing dots/spaces, ADS.
pub struct NtfsValidation&lt;B&gt; { /* user-implemented */ }

/// Example: Middleware that makes a backend case-insensitive.
/// Stores canonical (lowercase) keys, preserves original case in metadata.
pub struct CaseInsensitive&lt;B&gt; { /* user-implemented */ }
<span class="boring">}</span></code></pre>
<p><strong>Not built-in</strong> - these are illustrative patterns for users who need NTFS-like behavior.</p>
<hr>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>Security is achieved through composition:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td>Path containment</td><td><code>PathFilter</code> + VRootFsBackend</td></tr>
<tr><td>Resource exhaustion</td><td><code>Quota</code> enforces quotas</td></tr>
<tr><td>Rate limiting</td><td><code>RateLimit</code> prevents abuse</td></tr>
<tr><td>Feature restriction</td><td><code>Restrictions</code> disables dangerous features</td></tr>
<tr><td>Read-only access</td><td><code>ReadOnly</code> prevents writes</td></tr>
<tr><td>Audit trail</td><td><code>Tracing</code> instruments operations</td></tr>
<tr><td>Tenant isolation</td><td>Separate backend instances</td></tr>
<tr><td>Testing</td><td><code>DryRun</code> logs without executing</td></tr>
</tbody>
</table>
</div>
<p><strong>Defense in depth:</strong> Compose multiple middleware layers for comprehensive security.</p>
<h3 id="ai-agent-sandbox-example"><a class="header" href="#ai-agent-sandbox-example">AI Agent Sandbox Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, Quota, PathFilter, RateLimit, Tracing};

// Build a secure sandbox for an AI agent
let sandbox = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(50 * 1024 * 1024)  // 50 MB
        .max_file_size(5 * 1024 * 1024)    // 5 MB per file
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .deny("**/secrets/**")
        .build())
    .layer(RateLimitLayer::builder()
        .max_ops(1000)
        .per_second()
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="extension-traits-in-anyfs-backend"><a class="header" href="#extension-traits-in-anyfs-backend">Extension Traits (in <code>anyfs-backend</code>)</a></h2>
<p>The <code>FsExt</code> trait provides convenience methods for any <code>Fs</code> backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Extension methods for Fs (auto-implemented for all backends).
pub trait FsExt: Fs {
    /// Check if path is a file.
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.metadata(path).map(|m| m.file_type == FileType::File)
    }

    /// Check if path is a directory.
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt; {
        self.metadata(path).map(|m| m.file_type == FileType::Directory)
    }

    // JSON methods require `serde` feature (see below)
    #[cfg(feature = "serde")]
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt;;
    #[cfg(feature = "serde")]
    fn write_json&lt;T: Serialize&gt;(&amp;self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt;;
}

// Blanket implementation for all Fs backends
impl&lt;B: Fs&gt; FsExt for B {}
<span class="boring">}</span></code></pre>
<h3 id="json-methods-feature-serde"><a class="header" href="#json-methods-feature-serde">JSON Methods (feature: <code>serde</code>)</a></h3>
<p>The <code>read_json</code> and <code>write_json</code> methods require the <code>serde</code> feature:</p>
<pre><code class="language-toml">anyfs-backend = { version = "0.1", features = ["serde"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, de::DeserializeOwned};

#[cfg(feature = "serde")]
impl&lt;B: Fs&gt; FsExt for B {
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt; {
        let bytes = self.read(path)?;
        serde_json::from_slice(&amp;bytes).map_err(|e| FsError::Deserialization(e.to_string()))
    }

    fn write_json&lt;T: Serialize&gt;(&amp;self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt; {
        let bytes = serde_json::to_vec(value).map_err(|e| FsError::Serialization(e.to_string()))?;
        self.write(path, &amp;bytes)
    }
}
<span class="boring">}</span></code></pre>
<p>Users can define their own extension traits for domain-specific operations.</p>
<hr>
<h2 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h2>
<h3 id="bytes-support-feature-bytes"><a class="header" href="#bytes-support-feature-bytes">Bytes Support (feature: <code>bytes</code>)</a></h3>
<p>For zero-copy efficiency, enable the <code>bytes</code> feature to get <code>Bytes</code>-returning convenience methods on <code>FileStorage</code>:</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["bytes"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, MemoryBackend};
use bytes::Bytes;

let fs = FileStorage::new(MemoryBackend::new());

// With bytes feature, FileStorage provides read_bytes() convenience method
let data: Bytes = fs.read_bytes("/large-file.bin")?;
let slice = data.slice(1000..2000);  // Zero-copy!

// Core trait still uses Vec&lt;u8&gt; for object safety
// read_bytes() wraps the Vec&lt;u8&gt; in Bytes::from()
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> Core traits (<code>FsRead</code>, etc.) always use <code>Vec&lt;u8&gt;</code> for object safety (<code>dyn Fs</code>). The <code>bytes</code> feature adds convenience methods to <code>FileStorage</code> that wrap results in <code>Bytes</code>.</p>
<p><strong>When to use:</strong></p>
<ul>
<li>Large file handling with frequent slicing</li>
<li>Network-backed storage</li>
<li>Streaming scenarios</li>
</ul>
<p><strong>Default:</strong> <code>Vec&lt;u8&gt;</code> (no extra dependency)</p>
<hr>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<p><code>FsError</code> includes context for better debugging. It implements <code>std::error::Error</code> via <code>thiserror</code> and uses <code>#[non_exhaustive]</code> for forward compatibility.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Filesystem error with context.
///
/// All variants include enough information for meaningful error messages.
/// Use `#[non_exhaustive]` to allow adding variants in minor versions.
#[non_exhaustive]
#[derive(Debug, thiserror::Error)]
pub enum FsError {
    // ========================================================================
    // Path/File Errors
    // ========================================================================

    /// Path not found.
    #[error("not found: {path}")]
    NotFound {
        path: PathBuf,
    },

    /// Security threat detected (e.g., virus).
    #[error("threat detected: {reason} in {path}")]
    ThreatDetected {
        path: PathBuf,
        reason: String,
    },

    /// Path already exists.
    #[error("{operation}: already exists: {path}")]
    AlreadyExists {
        path: PathBuf,
        operation: &amp;'static str,
    },

    /// Expected a file, found directory.
    NotAFile { path: PathBuf },

    /// Expected a directory, found file.
    NotADirectory { path: PathBuf },

    /// Directory not empty (for remove_dir).
    DirectoryNotEmpty { path: PathBuf },

    // ========================================================================
    // Permission/Access Errors
    // ========================================================================

    /// Permission denied (general filesystem permission error).
    PermissionDenied {
        path: PathBuf,
        operation: &amp;'static str,
    },

    /// Access denied (from PathFilter or RBAC).
    AccessDenied {
        path: PathBuf,
        reason: String,  // Dynamic reason string
    },

    /// Read-only filesystem (from ReadOnly middleware).
    ReadOnly {
        operation: &amp;'static str,
    },

    /// Feature not enabled (from Restrictions middleware).
    /// Note: Symlink/hard-link capability is determined by trait bounds (FsLink),
    /// not middleware. Restrictions only controls "permissions".
    FeatureNotEnabled {
        feature: &amp;'static str,  // "permissions"
        operation: &amp;'static str,
    },

    // ========================================================================
    // Resource Limit Errors
    // ========================================================================

    /// Quota exceeded (total storage).
    QuotaExceeded {
        limit: u64,
        requested: u64,
        usage: u64,
    },

    /// File size limit exceeded.
    FileSizeExceeded {
        path: PathBuf,
        size: u64,
        limit: u64,
    },

    /// Rate limit exceeded (from RateLimit middleware).
    RateLimitExceeded {
        limit: u32,
        window_secs: u64,
    },

    // ========================================================================
    // Data Errors
    // ========================================================================

    /// Invalid data (e.g., not valid UTF-8 when string expected).
    InvalidData {
        path: PathBuf,
        details: String,
    },

    /// Corrupted data (e.g., failed checksum, parse error).
    CorruptedData {
        path: PathBuf,
        details: String,
    },

    /// Data integrity verification failed (AEAD tag mismatch, HMAC failure).
    IntegrityError {
        path: PathBuf,
    },

    /// Serialization error (from FsExt JSON methods).
    Serialization(String),

    /// Deserialization error (from FsExt JSON methods).
    Deserialization(String),

    // ========================================================================
    // Backend/Operation Errors
    // ========================================================================

    /// Operation not supported by this backend.
    NotSupported {
        operation: &amp;'static str,
    },

    /// Invalid password or encryption key (from SqliteCipherBackend).
    InvalidPassword,

    /// Conflict during sync (from offline mode).
    Conflict {
        path: PathBuf,
    },

    /// Backend-specific error (catch-all for custom backends).
    Backend(String),

    /// I/O error wrapper.
    Io {
        operation: &amp;'static str,
        path: PathBuf,
        source: std::io::Error,
    },
}

// Required implementations
impl From&lt;std::io::Error&gt; for FsError {
    fn from(err: std::io::Error) -&gt; Self {
        FsError::Io {
            operation: "io",
            path: PathBuf::new(),
            source: err,
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>All variants have <code>#[error("...")]</code> attributes (shown for first two, omitted for brevity)</li>
<li><code>#[non_exhaustive]</code> allows adding variants in minor versions without breaking changes</li>
<li><code>From&lt;std::io::Error&gt;</code> enables <code>?</code> operator with std::io functions</li>
<li>Consider <code>#[must_use]</code> on functions returning <code>Result&lt;_, FsError&gt;</code></li>
</ul>
<hr>
<h2 id="cross-platform-compatibility"><a class="header" href="#cross-platform-compatibility">Cross-Platform Compatibility</a></h2>
<p>AnyFS is designed for cross-platform use. Virtual backends work everywhere; real filesystem backends have platform considerations.</p>
<h3 id="backend-compatibility"><a class="header" href="#backend-compatibility">Backend Compatibility</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th style="text-align: center">Windows</th><th style="text-align: center">Linux</th><th style="text-align: center">macOS</th><th style="text-align: center">WASM</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td><code>SqliteBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅*</td></tr>
<tr><td><code>SqliteCipherBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td><code>IndexedBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td><code>StdFsBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td><code>VRootFsBackend</code></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
</tbody>
</table>
</div>
<p>*SQLite on WASM requires <code>wasm32</code> build of rusqlite with bundled SQLite.</p>
<h3 id="feature-compatibility"><a class="header" href="#feature-compatibility">Feature Compatibility</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center">Virtual Backends</th><th style="text-align: center">VRootFsBackend</th></tr>
</thead>
<tbody>
<tr><td>Basic I/O (<code>Fs</code>)</td><td style="text-align: center">✅ All platforms</td><td style="text-align: center">✅ All platforms</td></tr>
<tr><td>Symlinks</td><td style="text-align: center">✅ All platforms</td><td style="text-align: center">Platform-dependent (see below)</td></tr>
<tr><td>Hard links</td><td style="text-align: center">✅ All platforms</td><td style="text-align: center">Platform-dependent</td></tr>
<tr><td>Permissions</td><td style="text-align: center">✅ Stored as metadata</td><td style="text-align: center">Platform-dependent</td></tr>
<tr><td>Extended attributes</td><td style="text-align: center">✅ Stored as metadata</td><td style="text-align: center">Platform-dependent</td></tr>
<tr><td>FUSE mounting</td><td style="text-align: center">N/A</td><td style="text-align: center">Platform-dependent</td></tr>
</tbody>
</table>
</div>
<h3 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h3>
<h4 id="virtual-backends-memorybackend-sqlitebackend"><a class="header" href="#virtual-backends-memorybackend-sqlitebackend">Virtual Backends (MemoryBackend, SqliteBackend)</a></h4>
<p><strong>Fully cross-platform.</strong> All features work identically everywhere because:</p>
<ul>
<li>Paths are just strings/keys - no OS path resolution</li>
<li>Symlinks are stored data, not OS constructs</li>
<li>Permissions are metadata, not enforced by OS</li>
<li>No filesystem syscalls involved</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This works identically on Windows, Linux, macOS, and WASM
let fs = FileStorage::new(MemoryBackend::new());
fs.symlink("/target", "/link")?;           // Just stores the link
fs.set_permissions("/file", 0o755.into())?; // Just stores metadata
<span class="boring">}</span></code></pre>
<h4 id="vrootfsbackend-real-filesystem"><a class="header" href="#vrootfsbackend-real-filesystem">VRootFsBackend (Real Filesystem)</a></h4>
<p>Wraps the host filesystem. Platform differences apply:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Linux</th><th>macOS</th><th>Windows</th></tr>
</thead>
<tbody>
<tr><td>Symlinks</td><td>✅</td><td>✅</td><td>⚠️ Requires privileges*</td></tr>
<tr><td>Hard links</td><td>✅</td><td>✅</td><td>✅ (NTFS only)</td></tr>
<tr><td>Permissions (mode bits)</td><td>✅</td><td>✅</td><td>⚠️ Limited mapping</td></tr>
<tr><td>Extended attributes</td><td>✅ xattr</td><td>✅ xattr</td><td>⚠️ ADS (different API)</td></tr>
<tr><td>Case sensitivity</td><td>✅</td><td>⚠️ Default insensitive</td><td>⚠️ Insensitive</td></tr>
</tbody>
</table>
</div>
<p>*Windows requires <code>SeCreateSymbolicLinkPrivilege</code> or Developer Mode for symlinks.</p>
<h4 id="fuse-mounting"><a class="header" href="#fuse-mounting">FUSE Mounting</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Support</th><th>Library</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>✅ Native</td><td>libfuse</td></tr>
<tr><td>macOS</td><td>⚠️ Third-party</td><td>macFUSE</td></tr>
<tr><td>Windows</td><td>⚠️ Third-party</td><td>WinFsp or Dokan</td></tr>
<tr><td>WASM</td><td>❌</td><td>N/A</td></tr>
</tbody>
</table>
</div>
<h3 id="path-handling-1"><a class="header" href="#path-handling-1">Path Handling</a></h3>
<p>Virtual backends use <code>/</code> as separator internally, regardless of platform:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Always use forward slashes with virtual backends
fs.write("/project/src/main.rs", code)?;  // Works everywhere
<span class="boring">}</span></code></pre>
<p><code>VRootFsBackend</code> translates to native paths internally:</p>
<ul>
<li>Linux/macOS: <code>/</code> stays <code>/</code></li>
<li>Windows: <code>/project/file.txt</code> → <code>C:\root\project\file.txt</code></li>
</ul>
<h3 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommended Backend</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>Cross-platform app</td><td><code>MemoryBackend</code> or <code>SqliteBackend</code></td><td>No platform differences</td></tr>
<tr><td>Portable storage</td><td><code>SqliteBackend</code></td><td>Single file, works everywhere</td></tr>
<tr><td>WASM/browser</td><td><code>MemoryBackend</code> or <code>SqliteBackend</code></td><td>No filesystem access needed</td></tr>
<tr><td>Host filesystem access</td><td><code>VRootFsBackend</code></td><td>With awareness of platform limits</td></tr>
<tr><td>Testing</td><td><code>MemoryBackend</code></td><td>Fast, no cleanup, deterministic</td></tr>
</tbody>
</table>
</div>
<h3 id="feature-detection"><a class="header" href="#feature-detection">Feature Detection</a></h3>
<p>Check platform capabilities at runtime if needed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Check if symlinks are supported on the current platform.
pub fn symlinks_available() -&gt; bool {
    #[cfg(unix)]
    return true;

    #[cfg(windows)]
    {
        // Check for Developer Mode or symlink privilege
        // ...
    }
}
<span class="boring">}</span></code></pre>
<p>On platforms without symlink support, use a backend that doesn’t implement <code>FsLink</code>, or check <code>symlinks_available()</code> before calling symlink operations.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layered-design-backends--middleware--ergonomics"><a class="header" href="#layered-design-backends--middleware--ergonomics">Layered Design: Backends + Middleware + Ergonomics</a></h1>
<p>AnyFS uses a layered architecture that separates concerns:</p>
<ol>
<li><strong>Backends</strong>: Pure storage + filesystem semantics</li>
<li><strong>Middleware</strong>: Composable policy layers</li>
<li><strong>FileStorage</strong>: Ergonomic wrapper</li>
</ol>
<hr>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│  FileStorage                         │  ← Ergonomics only
├─────────────────────────────────────────┤
│  Middleware Stack (composable):         │  ← Policy enforcement
│    Tracing → PathFilter → Restrictions  │
│    → Quota → Backend                    │
├─────────────────────────────────────────┤
│  Fs                             │  ← Pure storage
│  (Memory, SQLite, VRootFs, custom)      │
└─────────────────────────────────────────┘
</code></pre>
<hr>
<h2 id="layer-responsibilities"><a class="header" href="#layer-responsibilities">Layer Responsibilities</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Responsibility</th><th>Path Handling</th></tr>
</thead>
<tbody>
<tr><td><code>FileStorage</code></td><td>Ergonomic API + path resolution</td><td>Accepts <code>impl AsRef&lt;Path&gt;</code>; resolves paths via pluggable <code>PathResolver</code></td></tr>
<tr><td>Middleware</td><td>Policy enforcement</td><td><code>&amp;Path</code> (object-safe core traits)</td></tr>
<tr><td>Backend</td><td>Storage + FS semantics</td><td><code>&amp;Path</code> (object-safe core traits)</td></tr>
</tbody>
</table>
</div>
<p>Core traits use <code>&amp;Path</code> for object safety; <code>FileStorage</code>/<code>FsExt</code> provide <code>impl AsRef&lt;Path&gt;</code> ergonomics. Path resolution is pluggable via <code>PathResolver</code> trait (see ADR-033). Backends that wrap a real filesystem implement <code>SelfResolving</code> so FileStorage can skip resolution.</p>
<hr>
<h2 id="policy-via-middleware"><a class="header" href="#policy-via-middleware">Policy via Middleware</a></h2>
<p><strong>Old design (rejected):</strong> FileStorage contained quota/feature logic.</p>
<p><strong>Current design:</strong> Policy is handled by composable middleware:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Middleware enforces policy
let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .build())
    .layer(TracingLayer::new());

// FileStorage is ergonomics + path resolution (no policy)
let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-containment"><a class="header" href="#path-containment">Path Containment</a></h2>
<p>For <code>VRootFsBackend</code> (real filesystem), path containment uses <code>strict-path::VirtualRoot</code> internally:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Fs for VRootFsBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // VirtualRoot ensures paths can't escape
        let safe_path = self.root.join(path)?;
        std::fs::read(safe_path).map_err(Into::into)
    }
}
<span class="boring">}</span></code></pre>
<p>For virtual backends (Memory, SQLite), paths are just keys - no OS path traversal possible. FileStorage performs symlink-aware resolution for these backends so normalization is consistent across virtual implementations.</p>
<p>For sandboxing across all backends, use <code>PathFilter</code> middleware:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathFilterLayer::builder()
    .allow("/workspace/**")
    .deny("**/.env")
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<ul>
<li><strong>Separation of concerns</strong>: Backends focus on storage, middleware handles policy</li>
<li><strong>Composability</strong>: Add/remove policies without touching storage code</li>
<li><strong>Flexibility</strong>: Same middleware works with any backend</li>
<li><strong>Simplicity</strong>: Each layer has one job</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---architecture-decision-records"><a class="header" href="#anyfs---architecture-decision-records">AnyFS - Architecture Decision Records</a></h1>
<p>This file captures the decisions for the current AnyFS design.</p>
<hr>
<h2 id="decision-map"><a class="header" href="#decision-map">Decision Map</a></h2>
<p>Primary docs are where each decision is explained in narrative form. ADRs remain the source of truth for the decision itself.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ADR</th><th>Primary doc</th></tr>
</thead>
<tbody>
<tr><td>ADR-001</td><td><a href="#anyfs---design-overview">Design Overview</a></td></tr>
<tr><td>ADR-002</td><td><a href="#anyfs---project-structure">Project Structure</a></td></tr>
<tr><td>ADR-003</td><td><a href="#layered-traits-anyfs-backend">Layered Traits</a></td></tr>
<tr><td>ADR-004</td><td><a href="#anyfs---design-overview">Design Overview</a></td></tr>
<tr><td>ADR-005</td><td><a href="#anyfs--api-quick-reference">API Quick Reference</a></td></tr>
<tr><td>ADR-006</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-007</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-008</td><td><a href="#filestorageb-r-m-anyfs">FileStorage</a></td></tr>
<tr><td>ADR-009</td><td><a href="#anyfs---project-structure">Project Structure</a></td></tr>
<tr><td>ADR-010</td><td><a href="#implementation-plan">Implementation Plan</a></td></tr>
<tr><td>ADR-011</td><td><a href="#anyfs---design-overview">Design Overview</a></td></tr>
<tr><td>ADR-012</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-013</td><td><a href="#layered-traits-anyfs-backend">Layered Traits</a></td></tr>
<tr><td>ADR-014</td><td><a href="#anyfs---design-overview">Design Overview</a></td></tr>
<tr><td>ADR-015</td><td><a href="#anyfs---design-overview">Design Overview</a></td></tr>
<tr><td>ADR-016</td><td><a href="#security-considerations-1">Security Considerations</a></td></tr>
<tr><td>ADR-017</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-018</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-019</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-020</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-021</td><td><a href="#middleware-implementation-guide">Middleware Implementation</a></td></tr>
<tr><td>ADR-022</td><td><a href="#anyfs--api-quick-reference">API Quick Reference</a></td></tr>
<tr><td>ADR-023</td><td><a href="#layered-traits-anyfs-backend">Layered Traits</a></td></tr>
<tr><td>ADR-024</td><td><a href="#implementation-plan">Implementation Plan</a></td></tr>
<tr><td>ADR-025</td><td><a href="#zero-cost-alternatives-for-io-operations">Zero-Cost Alternatives</a></td></tr>
<tr><td>ADR-026</td><td><a href="#implementation-plan">Implementation Plan</a></td></tr>
<tr><td>ADR-027</td><td><a href="#anyfs---design-overview">Design Overview</a></td></tr>
<tr><td>ADR-028</td><td><a href="#anyfs---design-overview">Design Overview</a></td></tr>
<tr><td>ADR-029</td><td><a href="#layered-design-backends--middleware--ergonomics">Two-Layer Path Handling</a></td></tr>
<tr><td>ADR-030</td><td><a href="#layered-traits-anyfs-backend">Layered Traits</a></td></tr>
<tr><td>ADR-031</td><td><a href="#indexing-middleware-design-plan">Indexing Middleware</a></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="adr-index"><a class="header" href="#adr-index">ADR Index</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ADR</th><th>Title</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>ADR-001</td><td>Path-based <code>Fs</code> trait</td><td>Accepted</td></tr>
<tr><td>ADR-002</td><td>Two-crate structure</td><td>Accepted</td></tr>
<tr><td>ADR-003</td><td>Object-safe path parameters</td><td>Accepted</td></tr>
<tr><td>ADR-004</td><td>Tower-style middleware pattern</td><td>Accepted</td></tr>
<tr><td>ADR-005</td><td><code>std::fs</code>-aligned method names</td><td>Accepted</td></tr>
<tr><td>ADR-006</td><td>Quota for quota enforcement</td><td>Accepted</td></tr>
<tr><td>ADR-007</td><td>Restrictions for least-privilege</td><td>Accepted</td></tr>
<tr><td>ADR-008</td><td>FileStorage as thin ergonomic wrapper</td><td>Accepted</td></tr>
<tr><td>ADR-009</td><td>Built-in backends are feature-gated</td><td>Accepted</td></tr>
<tr><td>ADR-010</td><td>Sync-first, async-ready design</td><td>Accepted</td></tr>
<tr><td>ADR-011</td><td>Layer trait for standardized composition</td><td>Accepted</td></tr>
<tr><td>ADR-012</td><td>Tracing for instrumentation</td><td>Accepted</td></tr>
<tr><td>ADR-013</td><td>FsExt for extension methods</td><td>Accepted</td></tr>
<tr><td>ADR-014</td><td>Optional Bytes support</td><td>Accepted</td></tr>
<tr><td>ADR-015</td><td>Contextual FsError</td><td>Accepted</td></tr>
<tr><td>ADR-016</td><td>PathFilter for path-based access control</td><td>Accepted</td></tr>
<tr><td>ADR-017</td><td>ReadOnly for preventing writes</td><td>Accepted</td></tr>
<tr><td>ADR-018</td><td>RateLimit for operation throttling</td><td>Accepted</td></tr>
<tr><td>ADR-019</td><td>DryRun for testing and debugging</td><td>Accepted</td></tr>
<tr><td>ADR-020</td><td>Cache for read performance</td><td>Accepted</td></tr>
<tr><td>ADR-021</td><td>Overlay for union filesystem</td><td>Accepted</td></tr>
<tr><td>ADR-022</td><td>Builder pattern for configurable middleware</td><td>Accepted</td></tr>
<tr><td>ADR-023</td><td>Interior mutability for all trait methods</td><td>Accepted</td></tr>
<tr><td>ADR-024</td><td>Async Strategy</td><td>Accepted</td></tr>
<tr><td>ADR-025</td><td>Strategic Boxing (Tower-style)</td><td>Accepted</td></tr>
<tr><td>ADR-026</td><td>Companion shell (anyfs-shell)</td><td>Accepted (Future)</td></tr>
<tr><td>ADR-027</td><td>Permissive core; security via middleware</td><td>Accepted</td></tr>
<tr><td>ADR-028</td><td>Linux-like semantics for virtual backends</td><td>Accepted</td></tr>
<tr><td>ADR-029</td><td>Path resolution in FileStorage</td><td>Accepted</td></tr>
<tr><td>ADR-030</td><td>Layered trait hierarchy</td><td>Accepted</td></tr>
<tr><td>ADR-031</td><td>Indexing as middleware</td><td>Accepted (Future)</td></tr>
<tr><td>ADR-032</td><td>Path Canonicalization via FsPath Trait</td><td>Accepted</td></tr>
<tr><td>ADR-033</td><td>PathResolver Trait for Pluggable Resolution</td><td>Accepted</td></tr>
<tr><td>ADR-034</td><td>LLM-Oriented Architecture (LOA)</td><td>Accepted</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="adr-001-path-based-fs-trait"><a class="header" href="#adr-001-path-based-fs-trait">ADR-001: Path-based <code>Fs</code> trait</a></h2>
<p><strong>Decision:</strong> Backends implement a path-based trait aligned with <code>std::fs</code> method naming.</p>
<p><strong>Why:</strong> Filesystem operations are naturally path-oriented; a single, familiar trait surface is easier to implement and adopt than graph-store or inode models.</p>
<hr>
<h2 id="adr-002-two-crate-structure"><a class="header" href="#adr-002-two-crate-structure">ADR-002: Two-crate structure</a></h2>
<p><strong>Decision:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>Fs</code> trait, <code>Layer</code> trait, <code>FsExt</code>, types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + ergonomics (<code>FileStorage&lt;B, R, M&gt;</code>, <code>BackendStack</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Why:</strong></p>
<ul>
<li>Backend authors only need <code>anyfs-backend</code> (no heavy dependencies).</li>
<li>Middleware is composable and lives with backends in <code>anyfs</code>.</li>
<li><code>FileStorage</code> provides ergonomics plus centralized path resolution for virtual backends - no policy logic - included in <code>anyfs</code> for convenience.</li>
</ul>
<hr>
<h2 id="adr-003-object-safe-path-parameters"><a class="header" href="#adr-003-object-safe-path-parameters">ADR-003: Object-safe path parameters</a></h2>
<p><strong>Decision:</strong> Core <code>Fs</code> traits take <code>&amp;Path</code> so they remain object-safe (<code>dyn Fs</code> works). For ergonomics, <code>FileStorage</code> and <code>FsExt</code> accept <code>impl AsRef&lt;Path&gt;</code> and forward to the core traits.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Object safety enables opt-in type erasure (<code>FileStorage::boxed()</code>).</li>
<li>Keeps hot-path calls zero-cost; dynamic dispatch is explicit and optional.</li>
<li>Ergonomics preserved via <code>FileStorage</code>/<code>FsExt</code> (<code>&amp;str</code>, <code>String</code>, <code>PathBuf</code>).</li>
</ul>
<hr>
<h2 id="adr-004-tower-style-middleware-pattern"><a class="header" href="#adr-004-tower-style-middleware-pattern">ADR-004: Tower-style middleware pattern</a></h2>
<p><strong>Decision:</strong> Use composable middleware (decorator pattern) for cross-cutting concerns like limits, logging, and feature gates. Each middleware implements <code>Fs</code> by wrapping another <code>Fs</code>.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Complete separation of concerns - each layer has one job.</li>
<li>Composable - use only what you need.</li>
<li>Familiar pattern (Axum/Tower use the same approach).</li>
<li>No code duplication - middleware written once, works with any backend.</li>
<li>Testable - each layer can be tested in isolation.</li>
</ul>
<p><strong>Example:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-005-stdfs-aligned-method-names"><a class="header" href="#adr-005-stdfs-aligned-method-names">ADR-005: <code>std::fs</code>-aligned method names</a></h2>
<p><strong>Decision:</strong> Prefer <code>read_dir</code>, <code>create_dir_all</code>, <code>remove_file</code>, etc.</p>
<p><strong>Why:</strong> Familiarity and reduced cognitive overhead.</p>
<hr>
<h2 id="adr-006-quota-for-quota-enforcement"><a class="header" href="#adr-006-quota-for-quota-enforcement">ADR-006: Quota for quota enforcement</a></h2>
<p><strong>Decision:</strong> Quota/limit enforcement is handled by <code>Quota&lt;B&gt;</code> middleware, not by backends or FileStorage.</p>
<p><strong>Configuration:</strong></p>
<ul>
<li><code>with_max_total_size(bytes)</code> - total storage limit</li>
<li><code>with_max_file_size(bytes)</code> - per-file limit</li>
<li><code>with_max_node_count(count)</code> - max files/directories</li>
<li><code>with_max_dir_entries(count)</code> - max entries per directory</li>
<li><code>with_max_path_depth(depth)</code> - max directory nesting</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Limits are policy, not storage semantics.</li>
<li>Written once, works with any backend.</li>
<li>Optional - users who don’t need limits skip this middleware.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>On construction, scan existing backend to initialize usage counters.</li>
<li>Wrap <code>open_write</code> streams with <code>CountingWriter</code> to track streamed bytes.</li>
<li>Check limits before operations, update usage after successful operations.</li>
</ul>
<hr>
<h2 id="adr-007-capability-via-trait-bounds"><a class="header" href="#adr-007-capability-via-trait-bounds">ADR-007: Capability via Trait Bounds</a></h2>
<p><strong>Decision:</strong> Symlink and hard-link capability is determined by whether the backend implements <code>FsLink</code>. The default <code>PathResolver</code> (IterativeResolver) follows symlinks when <code>FsLink</code> is available.</p>
<h3 id="the-rule"><a class="header" href="#the-rule">The Rule</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend implements <code>FsLink</code>?</th><th>Symlinks work?</th></tr>
</thead>
<tbody>
<tr><td>Yes (<code>B: FsLink</code>)</td><td>Yes</td></tr>
<tr><td>No</td><td>No (won’t compile)</td></tr>
</tbody>
</table>
</div>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MemoryBackend implements FsLink
let fs = FileStorage::new(MemoryBackend::new());
fs.symlink("/target", "/link")?;  // ✅ Works

// Custom backend that doesn't implement FsLink
let fs = FileStorage::new(MySimpleBackend::new());
fs.symlink("/target", "/link")?;  // ❌ Won't compile - no FsLink impl
<span class="boring">}</span></code></pre>
<h3 id="why-not-runtime-blocking"><a class="header" href="#why-not-runtime-blocking">Why Not Runtime Blocking?</a></h3>
<p>A hypothetical <code>deny_symlinks()</code> middleware would create type/behavior mismatch:</p>
<ul>
<li>Type says “I implement FsLink”</li>
<li>Runtime says “but symlink() errors”</li>
</ul>
<p>This is confusing and defeats the purpose of Rust’s type system. Instead, symlink capability is determined at compile time by trait bounds.</p>
<h3 id="restrictions-middleware"><a class="header" href="#restrictions-middleware">Restrictions Middleware</a></h3>
<p><code>Restrictions&lt;B&gt;</code> is limited to operations where runtime policy makes sense:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = RestrictionsLayer::builder()
    .deny_permissions()  // Prevent metadata changes
    .build()
    .layer(backend);
<span class="boring">}</span></code></pre>
<p><strong>Symlink following:</strong> Controlled by the <code>PathResolver</code>. The default <code>IterativeResolver</code> follows symlinks when <code>FsLink</code> is available. Custom resolvers can implement different behaviors. OS-backed backends delegate to the OS (strict-path prevents escapes).</p>
<hr>
<h2 id="adr-008-filestorage-as-thin-ergonomic-wrapper"><a class="header" href="#adr-008-filestorage-as-thin-ergonomic-wrapper">ADR-008: FileStorage as thin ergonomic wrapper</a></h2>
<p><strong>Decision:</strong> <code>FileStorage&lt;B, R, M&gt;</code> is a thin wrapper that provides std::fs-aligned ergonomics and centralized path resolution for virtual backends. It contains NO policy logic.</p>
<p><strong>What it does:</strong></p>
<ul>
<li>Provides familiar method names</li>
<li>Accepts <code>impl AsRef&lt;Path&gt;</code> for convenience and forwards to the core <code>&amp;Path</code> traits</li>
<li>Supports an optional marker type <code>M</code> for compile-time segregation of containers</li>
<li>Delegates all operations to the wrapped backend</li>
</ul>
<p><strong>What it does NOT do:</strong></p>
<ul>
<li>Quota enforcement (use Quota)</li>
<li>Feature gating (use Restrictions)</li>
<li>Instrumentation (use Tracing)</li>
<li>Any other policy</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Single responsibility - ergonomics + path resolution (no policy).</li>
<li>Users who don’t need ergonomics can use backends directly.</li>
<li>Policy is composable via middleware, not hardcoded.</li>
<li>Marker types prevent accidental mixing of different storage domains without runtime tags.</li>
</ul>
<hr>
<h2 id="adr-009-built-in-backends-are-feature-gated"><a class="header" href="#adr-009-built-in-backends-are-feature-gated">ADR-009: Built-in backends are feature-gated</a></h2>
<p><strong>Decision:</strong> <code>anyfs</code> uses Cargo features so users only pull the dependencies they need.</p>
<ul>
<li><code>memory</code> (default)</li>
<li><code>sqlite</code> (optional)</li>
<li><code>vrootfs</code> (optional)</li>
</ul>
<p><strong>Why:</strong> Minimizes binary size and compile time for users who don’t need all backends.</p>
<hr>
<h2 id="adr-010-sync-first-async-ready-design"><a class="header" href="#adr-010-sync-first-async-ready-design">ADR-010: Sync-first, async-ready design</a></h2>
<p><strong>Decision:</strong> <code>Fs</code> traits are synchronous. The API is designed to allow adding <code>AsyncFs</code> later without breaking changes.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All built-in backends are naturally synchronous:
<ul>
<li><code>MemoryBackend</code> - in-memory, instant</li>
<li><code>SqliteBackend</code> - rusqlite is sync</li>
<li><code>VRootFsBackend</code> - std::fs is sync</li>
</ul>
</li>
<li>Sync is simpler - no runtime dependency (tokio/async-std)</li>
<li>Users can wrap sync backends in <code>spawn_blocking</code> if needed</li>
</ul>
<p><strong>Async-ready design principles:</strong></p>
<ul>
<li>Traits require <code>Send</code> - compatible with async executors</li>
<li>Return types are <code>Result&lt;T, FsError&gt;</code> - works with async</li>
<li>No internal blocking assumptions</li>
<li>Methods are stateless per-call - no hidden blocking state</li>
</ul>
<p><strong>Future async path (Option 2):</strong>
When async is needed (e.g., network-backed storage), add a parallel trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-backend
pub trait AsyncFs: Send + Sync {
    async fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    async fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    // ... mirrors Fs with async

    // Streaming uses AsyncRead/AsyncWrite
    async fn open_read(&amp;self, path: &amp;Path)
        -&gt; Result&lt;Box&lt;dyn AsyncRead + Send + Unpin&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Migration notes:</strong></p>
<ul>
<li><code>AsyncFs</code> would be a separate trait, not replacing <code>Fs</code></li>
<li>Blanket impl possible: <code>impl&lt;T: Fs&gt; AsyncFs for T</code> using <code>spawn_blocking</code></li>
<li>Middleware would need async variants: <code>AsyncQuota&lt;B&gt;</code>, etc.</li>
<li>No breaking changes to existing sync API</li>
</ul>
<p><strong>Why not async now:</strong></p>
<ul>
<li>Complexity without benefit - all current backends are sync</li>
<li>Rust 1.75 makes async traits easy, so adding later is low-cost</li>
<li>Better to wait for real async backend requirements</li>
</ul>
<hr>
<h2 id="adr-011-layer-trait-for-standardized-composition"><a class="header" href="#adr-011-layer-trait-for-standardized-composition">ADR-011: Layer trait for standardized composition</a></h2>
<p><strong>Decision:</strong> Provide a <code>Layer</code> trait (inspired by Tower) that standardizes middleware composition.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Layer&lt;B: Fs&gt; {
    type Backend: Fs;
    fn layer(self, backend: B) -&gt; Self::Backend;
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li>Standardized composition pattern familiar to Tower/Axum users.</li>
<li>IDE autocomplete for available layers.</li>
<li>Enables <code>BackendStack</code> fluent builder in anyfs.</li>
<li>Each middleware provides a corresponding <code>*Layer</code> type.</li>
</ul>
<p><strong>Example:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100_000)
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-012-tracing-for-instrumentation"><a class="header" href="#adr-012-tracing-for-instrumentation">ADR-012: Tracing for instrumentation</a></h2>
<p><strong>Decision:</strong> Use <code>Tracing&lt;B&gt;</code> integrated with the <code>tracing</code> ecosystem instead of a custom logging solution.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Works with existing tracing infrastructure (tracing-subscriber, OpenTelemetry, Jaeger).</li>
<li>Structured logging with spans for each operation.</li>
<li>Users choose their subscriber - no logging framework lock-in.</li>
<li>Consistent with modern Rust ecosystem practices.</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>backend.layer(TracingLayer::new()
    .with_target("anyfs")
    .with_level(tracing::Level::DEBUG))
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-013-fsext-for-extension-methods"><a class="header" href="#adr-013-fsext-for-extension-methods">ADR-013: FsExt for extension methods</a></h2>
<p><strong>Decision:</strong> Provide <code>FsExt</code> trait with convenience methods, auto-implemented for all backends.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsExt: Fs {
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;

    // JSON methods require `serde` feature
    #[cfg(feature = "serde")]
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt;;
    #[cfg(feature = "serde")]
    fn write_json&lt;T: Serialize&gt;(&amp;self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt;;
}

impl&lt;B: Fs&gt; FsExt for B {}
<span class="boring">}</span></code></pre>
<p><strong>Feature gating:</strong></p>
<ul>
<li><code>is_file()</code> and <code>is_dir()</code> are always available.</li>
<li><code>read_json()</code> and <code>write_json()</code> require <code>anyfs-backend = { features = ["serde"] }</code>.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Adds convenience without bloating <code>Fs</code> trait.</li>
<li>Blanket impl means all backends get these methods for free.</li>
<li>Users can define their own extension traits for domain-specific operations.</li>
<li>Follows Rust convention (e.g., <code>IteratorExt</code>, <code>StreamExt</code>).</li>
<li>Serde is optional - users who don’t need JSON avoid the dependency.</li>
</ul>
<hr>
<h2 id="adr-014-optional-bytes-support"><a class="header" href="#adr-014-optional-bytes-support">ADR-014: Optional Bytes support</a></h2>
<p><strong>Decision:</strong> Support the <code>bytes</code> crate via an optional feature for zero-copy efficiency.</p>
<pre><code class="language-toml">anyfs = { version = "0.1", features = ["bytes"] }
</code></pre>
<p><strong>Why:</strong></p>
<ul>
<li><code>Bytes</code> provides O(1) slicing via reference counting.</li>
<li>Beneficial for large file handling, network backends, streaming.</li>
<li>Optional - users who don’t need it avoid the dependency.</li>
<li>Default remains <code>Vec&lt;u8&gt;</code> for simplicity.</li>
</ul>
<p><strong>Implementation:</strong> Use a type alias to avoid breaking API:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-backend/src/types.rs

#[cfg(feature = "bytes")]
pub type FileContent = bytes::Bytes;

#[cfg(not(feature = "bytes"))]
pub type FileContent = Vec&lt;u8&gt;;

// In trait definition
pub trait FsRead: Send {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;FileContent, FsError&gt;;
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Middleware compatibility:</strong> Middleware passes <code>FileContent</code> through unchanged. No special handling needed - both <code>Vec&lt;u8&gt;</code> and <code>Bytes</code> implement <code>AsRef&lt;[u8]&gt;</code> and <code>Deref&lt;Target=[u8]&gt;</code>.</p>
<hr>
<h2 id="adr-015-contextual-fserror"><a class="header" href="#adr-015-contextual-fserror">ADR-015: Contextual FsError</a></h2>
<p><strong>Decision:</strong> <code>FsError</code> variants include context for better debugging.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FsError::NotFound {
    path: PathBuf,
}

FsError::QuotaExceeded {
    limit: u64,
    requested: u64,
    usage: u64,
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li>Error messages include enough context to understand what failed.</li>
<li>No need for separate error context crate (like anyhow) for basic usage.</li>
<li>Path is sufficient for NotFound - the call site knows the operation.</li>
<li>Quota errors include all relevant numbers for debugging.</li>
</ul>
<hr>
<h2 id="adr-016-pathfilter-for-path-based-access-control"><a class="header" href="#adr-016-pathfilter-for-path-based-access-control">ADR-016: PathFilter for path-based access control</a></h2>
<p><strong>Decision:</strong> Provide <code>PathFilter&lt;B&gt;</code> middleware for glob-based path access control.</p>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathFilterLayer::builder()
    .allow("/workspace/**")    // Allow workspace access
    .deny("**/.env")           // Deny .env files anywhere
    .deny("**/secrets/**")     // Deny secrets directories
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Rules are evaluated in order; first match wins.</li>
<li>If no rules match, access is denied (deny by default).</li>
<li>Uses glob patterns (e.g., <code>**</code> for recursive, <code>*</code> for single segment).</li>
<li>Returns <code>FsError::AccessDenied</code> for denied paths.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Essential for AI agent sandboxing - restrict to specific directories.</li>
<li>Prevents access to sensitive files (.env, secrets, credentials).</li>
<li>Separate from backend - works with any backend.</li>
<li>Inspired by AgentFS and similar AI sandbox patterns.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Use <code>globset</code> crate for efficient glob pattern matching.</li>
<li><code>read_dir</code> filters out denied entries from results (don’t expose existence of denied files).</li>
<li>Check path at operation start, then delegate to inner backend.</li>
</ul>
<hr>
<h2 id="adr-017-readonly-for-preventing-writes"><a class="header" href="#adr-017-readonly-for-preventing-writes">ADR-017: ReadOnly for preventing writes</a></h2>
<p><strong>Decision:</strong> Provide <code>ReadOnly&lt;B&gt;</code> middleware that blocks all write operations.</p>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let readonly_fs = ReadOnly::new(backend);
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>All read operations pass through to inner backend.</li>
<li>All write operations return <code>FsError::ReadOnly</code>.</li>
<li>Simple, no configuration needed.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Safe browsing of container contents without modification risk.</li>
<li>Useful for debugging, inspection, auditing.</li>
<li>Simpler than configuring Restrictions for read-only use case.</li>
</ul>
<hr>
<h2 id="adr-018-ratelimit-for-operation-throttling"><a class="header" href="#adr-018-ratelimit-for-operation-throttling">ADR-018: RateLimit for operation throttling</a></h2>
<p><strong>Decision:</strong> Provide <code>RateLimit&lt;B&gt;</code> middleware to limit operations per time window.</p>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RateLimitLayer::builder()
    .max_ops(1000)
    .per_second()
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Tracks operation count in sliding time window.</li>
<li>Returns <code>FsError::RateLimitExceeded</code> when limit exceeded.</li>
<li>Counter resets after window expires.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Protects against runaway processes consuming resources.</li>
<li>Essential for multi-tenant environments.</li>
<li>Prevents denial-of-service from misbehaving code.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Use <code>std::time::Instant</code> for timing.</li>
<li>Store window start time and counter; reset when window expires.</li>
<li>Count operation calls (including <code>open_read</code>/<code>open_write</code>), not bytes transferred.</li>
<li>Return error immediately when limit exceeded (no blocking/waiting).</li>
</ul>
<hr>
<h2 id="adr-019-dryrun-for-testing-and-debugging"><a class="header" href="#adr-019-dryrun-for-testing-and-debugging">ADR-019: DryRun for testing and debugging</a></h2>
<p><strong>Decision:</strong> Provide <code>DryRun&lt;B&gt;</code> middleware that logs write operations without executing them.</p>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dry_run = DryRun::new(backend);
let fs = FileStorage::new(dry_run);

fs.write("/test.txt", b"hello")?;  // Logged but not written
// To inspect recorded operations, keep the DryRun handle before wrapping it.
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Read operations execute normally against inner backend.</li>
<li>Write operations are logged but return <code>Ok(())</code> without executing.</li>
<li>Operations log can be inspected for verification.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Test code paths without side effects.</li>
<li>Debug complex operation sequences.</li>
<li>Audit what would happen before committing.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Read operations delegate to inner backend (test against real state).</li>
<li>Write operations log and return <code>Ok(())</code> without executing.</li>
<li><code>open_write</code> returns <code>std::io::sink()</code> - writes are discarded.</li>
<li>Useful for: “What would this code do?” not “Run this in isolation.”</li>
</ul>
<hr>
<h2 id="adr-020-cache-for-read-performance"><a class="header" href="#adr-020-cache-for-read-performance">ADR-020: Cache for read performance</a></h2>
<p><strong>Decision:</strong> Provide <code>Cache&lt;B&gt;</code> middleware with LRU caching for read operations.</p>
<p><strong>Configuration:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CacheLayer::builder()
    .max_entries(1000)
    .max_entry_size(1024 * 1024)  // 1MB max per entry
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Read operations check cache first, populate on miss.</li>
<li>Write operations invalidate relevant cache entries.</li>
<li>LRU eviction when max entries exceeded.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Improves performance for repeated reads.</li>
<li>Reduces load on underlying backend (especially for SQLite/network).</li>
<li>Configurable to balance memory vs performance.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Cache bulk reads only: <code>read()</code>, <code>read_to_string()</code>, <code>read_range()</code>, <code>metadata()</code>, <code>exists()</code>.</li>
<li>Do NOT cache <code>open_read()</code> - streams are for large files that shouldn’t be cached.</li>
<li>Invalidate cache entry on any write to that path.</li>
<li>Use <code>lru</code> crate or similar for LRU eviction.</li>
<li>Check TTL on cache hits; evict expired entries.</li>
</ul>
<hr>
<h2 id="adr-021-overlay-for-union-filesystem"><a class="header" href="#adr-021-overlay-for-union-filesystem">ADR-021: Overlay for union filesystem</a></h2>
<p><strong>Decision:</strong> Provide <code>Overlay&lt;B1, B2&gt;</code> middleware for copy-on-write layered filesystems.</p>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let base = SqliteBackend::open("base.db")?;  // Read-only base
let upper = MemoryBackend::new();             // Writable upper layer

let overlay = Overlay::new(base, upper);
<span class="boring">}</span></code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>Read: check upper layer first, fall back to base if not found.</li>
<li>Write: always to upper layer (copy-on-write).</li>
<li>Delete: create whiteout marker in upper layer (file appears deleted but base unchanged).</li>
<li>Directory listing: merge results from both layers.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Docker-like layered filesystem for containers.</li>
<li>Base image with per-instance modifications.</li>
<li>Testing with isolated changes over shared baseline.</li>
<li>Inspired by OverlayFS and VFS crate patterns.</li>
</ul>
<p><strong>Implementation notes:</strong></p>
<ul>
<li>Whiteout convention: <code>.wh.&lt;filename&gt;</code> marks deleted files from base layer.</li>
<li><code>read_dir</code> must merge results from both layers, excluding whiteouts and whited-out files.</li>
<li><code>exists</code> checks upper first, then base (respecting whiteouts).</li>
<li>All writes go to upper layer; base is never modified.</li>
<li>Consider <code>opaque</code> directories (<code>.wh..wh..opq</code>) to hide entire base directories.</li>
</ul>
<hr>
<h2 id="adr-022-builder-pattern-for-configurable-middleware"><a class="header" href="#adr-022-builder-pattern-for-configurable-middleware">ADR-022: Builder pattern for configurable middleware</a></h2>
<p><strong>Decision:</strong> Middleware that requires configuration MUST use a builder pattern that prevents construction without meaningful values. <code>::new()</code> constructors are NOT allowed for middleware where a default configuration is nonsensical.</p>
<p><strong>Problem:</strong> A constructor like <code>QuotaLayer::new()</code> raises the question: “What quota?” An unlimited quota is pointless - you wouldn’t use <code>QuotaLayer</code> at all. Similarly, <code>RestrictionsLayer::new()</code> with no restrictions, <code>PathFilterLayer::new()</code> with no rules, and <code>RateLimitLayer::new()</code> with no rate limit are all nonsensical.</p>
<p><strong>Solution:</strong> Use builders that enforce at least one meaningful configuration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// QuotaLayer - requires at least one limit
let quota = QuotaLayer::builder()
    .max_total_size(100 * 1024 * 1024)
    .build();

// Can also set multiple limits
let quota = QuotaLayer::builder()
    .max_total_size(1_000_000)
    .max_file_size(100_000)
    .max_node_count(1000)
    .build();

// RestrictionsLayer - requires at least one restriction
let restrictions = RestrictionsLayer::builder()
    .deny_permissions()
    .build();

// PathFilterLayer - requires at least one rule
let filter = PathFilterLayer::builder()
    .allow("/workspace/**")
    .deny("**/.env")
    .build();

// RateLimitLayer - requires rate limit parameters
let rate_limit = RateLimitLayer::builder()
    .max_ops(1000)
    .per_second()
    .build();

// CacheLayer - requires cache configuration
let cache = CacheLayer::builder()
    .max_entries(1000)
    .build();
<span class="boring">}</span></code></pre>
<p><strong>Middleware that MAY keep <code>::new()</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td><code>TracingLayer</code></td><td>Default (global tracing subscriber) is meaningful</td></tr>
<tr><td><code>ReadOnlyLayer</code></td><td>No configuration needed</td></tr>
<tr><td><code>DryRunLayer</code></td><td>No configuration needed</td></tr>
<tr><td><code>OverlayLayer</code></td><td>Takes two backends as required params: <code>Overlay::new(lower, upper)</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Builder with typestate pattern for compile-time enforcement
pub struct QuotaLayerBuilder&lt;State = Unconfigured&gt; {
    max_total_size: Option&lt;u64&gt;,
    max_file_size: Option&lt;u64&gt;,
    max_node_count: Option&lt;u64&gt;,
    _state: PhantomData&lt;State&gt;,
}

pub struct Unconfigured;
pub struct Configured;

impl QuotaLayerBuilder&lt;Unconfigured&gt; {
    pub fn max_total_size(mut self, bytes: u64) -&gt; QuotaLayerBuilder&lt;Configured&gt; {
        self.max_total_size = Some(bytes);
        QuotaLayerBuilder {
            max_total_size: self.max_total_size,
            max_file_size: self.max_file_size,
            max_node_count: self.max_node_count,
            _state: PhantomData,
        }
    }

    pub fn max_file_size(mut self, bytes: u64) -&gt; QuotaLayerBuilder&lt;Configured&gt; {
        // Similar transition to Configured state
    }

    pub fn max_node_count(mut self, count: u64) -&gt; QuotaLayerBuilder&lt;Configured&gt; {
        // Similar transition to Configured state
    }

    // Note: NO build() method on Unconfigured state!
}

impl QuotaLayerBuilder&lt;Configured&gt; {
    // Additional configuration methods stay in Configured state
    pub fn max_total_size(mut self, bytes: u64) -&gt; Self {
        self.max_total_size = Some(bytes);
        self
    }

    // Only Configured state has build()
    pub fn build(self) -&gt; QuotaLayer {
        QuotaLayer { /* ... */ }
    }
}

impl QuotaLayer {
    pub fn builder() -&gt; QuotaLayerBuilder&lt;Unconfigured&gt; {
        QuotaLayerBuilder {
            max_total_size: None,
            max_file_size: None,
            max_node_count: None,
            _state: PhantomData,
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ul>
<li><strong>Compile-time safety:</strong> Invalid configurations don’t compile.</li>
<li><strong>Self-documenting API:</strong> Users must explicitly choose configuration.</li>
<li><strong>No meaningless defaults:</strong> Eliminates “what does this default to?” confusion.</li>
<li><strong>IDE guidance:</strong> Autocomplete shows required methods before <code>build()</code>.</li>
<li><strong>Familiar pattern:</strong> Rust builders are idiomatic and widely understood.</li>
</ul>
<p><strong>Error prevention:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile - no build() on Unconfigured
let quota = QuotaLayer::builder().build();  // ❌ Error!

// This compiles - at least one limit set
let quota = QuotaLayer::builder()
    .max_total_size(1_000_000)
    .build();  // ✅ OK
<span class="boring">}</span></code></pre>
<hr>
<h2 id="adr-023-interior-mutability-for-all-trait-methods"><a class="header" href="#adr-023-interior-mutability-for-all-trait-methods">ADR-023: Interior mutability for all trait methods</a></h2>
<p><strong>Decision:</strong> All <code>Fs</code> trait methods use <code>&amp;self</code>, not <code>&amp;mut self</code>. Backends manage their own synchronization internally (interior mutability).</p>
<p><strong>Previous design:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
}

pub trait FsWrite: Send {
    fn write(&amp;mut self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>New design:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
}

pub trait FsWrite: Send + Sync {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ol>
<li>
<p><strong>Filesystems are conceptually always mutable.</strong> A filesystem doesn’t become “borrowed” when you write to it - the underlying storage manages concurrency itself.</p>
</li>
<li>
<p><strong>Enables concurrent access patterns.</strong> With <code>&amp;mut self</code>, you cannot have concurrent readers and writers even when the backend supports it (e.g., SQLite with WAL mode, real filesystems).</p>
</li>
<li>
<p><strong>Matches real-world filesystem semantics.</strong> <code>std::fs::write()</code> takes a path, not a mutable reference to some filesystem object. Files are shared resources.</p>
</li>
<li>
<p><strong>Simplifies middleware implementation.</strong> Middleware no longer needs to worry about propagating mutability - all operations use <code>&amp;self</code>.</p>
</li>
<li>
<p><strong>Common pattern in Rust.</strong> Many I/O abstractions use interior mutability: <code>std::io::Write</code> for <code>File</code> (via OS handles), <code>tokio::fs</code>, database connection pools, etc.</p>
</li>
</ol>
<p><strong>Implementation:</strong></p>
<p>Backends use appropriate synchronization primitives:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MemoryBackend {
    // Interior mutability via Mutex/RwLock
    data: RwLock&lt;HashMap&lt;PathBuf, Vec&lt;u8&gt;&gt;&gt;,
}

impl FsWrite for MemoryBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let mut guard = self.data.write().unwrap();
        guard.insert(path.as_ref().to_path_buf(), data.to_vec());
        Ok(())
    }
}

pub struct SqliteBackend {
    // SQLite handles its own locking
    conn: Connection,  // rusqlite::Connection is internally synchronized
}
<span class="boring">}</span></code></pre>
<p><strong>Trade-offs:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>&amp;mut self</th><th>&amp;self (interior mutability)</th></tr>
</thead>
<tbody>
<tr><td>Compile-time safety</td><td>Single writer enforced</td><td>Runtime synchronization</td></tr>
<tr><td>Concurrent access</td><td>Not possible</td><td>Backend decides</td></tr>
<tr><td>API simplicity</td><td>Simple</td><td>Slightly more complex backends</td></tr>
<tr><td>Real-world match</td><td>Poor</td><td>Good</td></tr>
</tbody>
</table>
</div>
<p><strong>Backend implementer responsibility:</strong></p>
<p>Backends MUST use interior mutability (<code>RwLock</code>, <code>Mutex</code>, etc.) to ensure thread-safe concurrent access. This guarantees:</p>
<ul>
<li>Memory safety (no data corruption)</li>
<li>Atomic operations (a single <code>write()</code> won’t produce partial results)</li>
</ul>
<p>This does NOT guarantee:</p>
<ul>
<li>Order of concurrent writes to the same path (last write wins - standard FS behavior)</li>
</ul>
<p><strong>Conclusion:</strong> The benefits of matching filesystem semantics and enabling concurrent access outweigh the loss of compile-time single-writer enforcement. Backends are responsible for their own thread safety via interior mutability.</p>
<hr>
<h2 id="adr-024-async-strategy"><a class="header" href="#adr-024-async-strategy">ADR-024: Async Strategy</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Context:</strong> Async/await is prevalent in Rust networking and I/O. While AnyFS is primarily sync-focused (matching <code>std::fs</code>), we may need async support in the future for:</p>
<ul>
<li>Network-backed storage (S3, WebDAV, etc.)</li>
<li>High-concurrency scenarios</li>
<li>Integration with async runtimes (tokio, async-std)</li>
</ul>
<p><strong>Decision:</strong> Plan for a <strong>parallel async trait hierarchy</strong> that mirrors the sync traits.</p>
<p><strong>Strategy:</strong></p>
<pre><code>Sync Traits          Async Traits
-----------          ------------
FsRead        →      AsyncFsRead
FsWrite       →      AsyncFsWrite
FsDir         →      AsyncFsDir
Fs            →      AsyncFs
FsFull        →      AsyncFsFull
FsFuse        →      AsyncFsFuse
FsPosix       →      AsyncFsPosix
</code></pre>
<p><strong>Design principles:</strong></p>
<ol>
<li>
<p><strong>Separate crate:</strong> Async traits live in <code>anyfs-async</code> to avoid pulling async dependencies into the core.</p>
</li>
<li>
<p><strong>Method parity:</strong> Each async trait method corresponds 1:1 with its sync counterpart:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sync (anyfs-backend)
pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
}

// Async (anyfs-async)
#[async_trait]
pub trait AsyncFsRead: Send + Sync {
    async fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Layer trait compatibility:</strong> The <code>Layer</code> trait works for both sync and async:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Layer&lt;B&gt; {
    type Backend;
    fn layer(self, backend: B) -&gt; Self::Backend;
}

// Middleware can implement for both:
impl&lt;B: Fs&gt; Layer&lt;B&gt; for QuotaLayer {
    type Backend = Quota&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend { ... }
}

impl&lt;B: AsyncFs&gt; Layer&lt;B&gt; for QuotaLayer {
    type Backend = AsyncQuota&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend { ... }
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Sync-to-async bridge:</strong> Provide adapters for using sync backends in async contexts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wraps sync backend for use in async code (uses spawn_blocking)
pub struct SyncToAsync&lt;B&gt;(B);

impl&lt;B: Fs&gt; AsyncFsRead for SyncToAsync&lt;B&gt; {
    async fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let backend = self.0.clone(); // requires Clone
        tokio::task::spawn_blocking(move || backend.read(&amp;path)).await?
    }
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>No async-to-sync bridge:</strong> We intentionally don’t provide async-to-sync adapters (would require blocking on async runtime, which is problematic).</p>
</li>
</ol>
<p><strong>Implementation phases:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Scope</th><th>Dependency</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>Sync traits stable</td><td>Now</td></tr>
<tr><td>2</td><td>Design async traits</td><td>When needed</td></tr>
<tr><td>3</td><td><code>anyfs-async</code> crate</td><td>When needed</td></tr>
<tr><td>4</td><td>Async middleware</td><td>When needed</td></tr>
</tbody>
</table>
</div>
<p><strong>Why parallel traits (not feature flags):</strong></p>
<ul>
<li><strong>No conditional compilation complexity</strong> - sync and async are separate, clean codebases</li>
<li><strong>No trait object issues</strong> - async traits have different object safety requirements</li>
<li><strong>Clear dependency boundaries</strong> - sync code doesn’t pull in tokio/async-std</li>
<li><strong>Ecosystem alignment</strong> - mirrors how <code>std::io</code> vs <code>tokio::io</code> work</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>Parallel traits</td><td>Clean separation, no async deps in core</td><td>Code duplication in middleware</td></tr>
<tr><td>Feature flags</td><td>Single codebase</td><td>Complex conditional compilation</td></tr>
<tr><td>Async-only</td><td>Modern, no duplication</td><td>Forces async runtime on sync users</td></tr>
<tr><td>Sync-only</td><td>Simple</td><td>Can’t support network backends efficiently</td></tr>
</tbody>
</table>
</div>
<p><strong>Conclusion:</strong> Parallel async traits provide the best balance of simplicity now (sync-only core) with a clear migration path for async support later. The <code>Layer</code> trait design already accommodates this pattern.</p>
<hr>
<h2 id="adr-025-strategic-boxing-tower-style"><a class="header" href="#adr-025-strategic-boxing-tower-style">ADR-025: Strategic Boxing (Tower-style)</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> Dynamic dispatch (<code>Box&lt;dyn Trait&gt;</code>) adds heap allocation and vtable indirection. We need to decide where boxing is acceptable vs. where zero-cost abstractions are required.</p>
<p><strong>Decision:</strong> Follow Tower/Axum’s battle-tested strategy: <strong>zero-cost on the hot path, box at boundaries where flexibility is needed and I/O cost dominates.</strong></p>
<p><strong>Principle:</strong> Avoid heap allocations and dynamic dispatch unless they buy real flexibility with negligible performance impact. Box only at cold boundaries (streams/iterators), and make type erasure explicit and opt-in.</p>
<p><strong>DX stance:</strong> Application code uses <code>FileStorage</code>/<code>FsExt</code> (std::fs-style paths). Core traits stay object-safe for <code>dyn Fs</code>. For hot loops on known concrete backends, we provide a typed streaming extension as the first-class zero-alloc fast path.</p>
<h3 id="boxing-strategy"><a class="header" href="#boxing-strategy">Boxing Strategy</a></h3>
<pre><code>HOT PATH (many calls per operation - must be zero-cost):
┌─────────────────────────────────────────────────────┐
│  read(), write(), metadata(), exists()              │  ← Returns concrete types
│  Read::read() / Write::write() on streams           │  ← Vtable dispatch only
│  Iterator::next() on ReadDirIter                    │  ← Vtable dispatch only
│  Middleware composition                             │  ← Generics, monomorphized
└─────────────────────────────────────────────────────┘

COLD PATH (once per operation - boxing acceptable):
┌─────────────────────────────────────────────────────┐
│  open_read(), open_write()                          │  ← Box&lt;dyn Read/Write&gt;
│  read_dir()                                         │  ← ReadDirIter (boxed inner)
└─────────────────────────────────────────────────────┘

SETUP (once at startup - zero-cost):
┌─────────────────────────────────────────────────────┐
│  Middleware stacking: Quota&lt;Tracing&lt;B&gt;&gt;             │  ← Generics, no boxing
│  FileStorage::new(backend)                          │  ← Zero-cost wrapper
└─────────────────────────────────────────────────────┘

OPT-IN TYPE ERASURE (when explicitly needed):
┌─────────────────────────────────────────────────────────────┐
│  FileStorage::boxed() -&gt; FileStorage&lt;Box&lt;dyn Fs&gt;, R, M&gt;    │  ← Like Tower's BoxService
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="what-gets-boxed-and-why"><a class="header" href="#what-gets-boxed-and-why">What Gets Boxed and Why</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>API</th><th>Boxed?</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td><code>read()</code> → <code>Vec&lt;u8&gt;</code></td><td>No</td><td>Hot path, most common operation</td></tr>
<tr><td><code>write(data)</code> → <code>()</code></td><td>No</td><td>Hot path, most common operation</td></tr>
<tr><td><code>metadata()</code> → <code>Metadata</code></td><td>No</td><td>Hot path, frequently called</td></tr>
<tr><td><code>exists()</code> → <code>bool</code></td><td>No</td><td>Hot path, frequently called</td></tr>
<tr><td><code>open_read()</code> → <code>Box&lt;dyn Read&gt;</code></td><td>Yes</td><td>Cold path (once per file), enables middleware wrappers</td></tr>
<tr><td><code>open_write()</code> → <code>Box&lt;dyn Write&gt;</code></td><td>Yes</td><td>Cold path (once per file), enables <code>QuotaWriter</code></td></tr>
<tr><td><code>read_dir()</code> → <code>ReadDirIter</code></td><td>Yes (inner)</td><td>Enables filtering in PathFilter, merging in Overlay</td></tr>
<tr><td>Middleware stack</td><td>No</td><td>Generics compose at compile time</td></tr>
<tr><td><code>FileStorage::boxed()</code></td><td>Opt-in</td><td>Explicit type erasure when needed</td></tr>
</tbody>
</table>
</div>
<h3 id="why-this-works"><a class="header" href="#why-this-works">Why This Works</a></h3>
<p><strong>1. Bulk operations are the common case:</strong>
Most code uses <code>read()</code> and <code>write()</code>, not streaming. These are zero-cost.</p>
<p><strong>2. Streaming is for large files:</strong>
<code>open_read()</code> / <code>open_write()</code> are for files too large to load into memory. For large files, I/O time (1-100ms) dwarfs box allocation (~50ns).</p>
<p><strong>3. Box once, vtable many:</strong>
After <code>open_read()</code> allocates once, subsequent <code>Read::read()</code> calls are just vtable dispatch - no further allocations.</p>
<p><strong>4. Middleware needs flexibility:</strong></p>
<ul>
<li><code>Quota</code> wraps streams with <code>QuotaWriter</code> to count bytes</li>
<li><code>PathFilter</code> filters <code>ReadDirIter</code> to hide denied entries</li>
<li><code>Overlay</code> merges directory listings from two backends
Boxing enables this without type explosion.</li>
</ul>
<h3 id="comparison-to-toweraxum"><a class="header" href="#comparison-to-toweraxum">Comparison to Tower/Axum</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>AnyFS</th><th>Tower/Axum</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Quota&lt;Tracing&lt;B&gt;&gt;</code></td><td><code>Timeout&lt;RateLimit&lt;S&gt;&gt;</code></td><td>Zero-cost middleware composition</td></tr>
<tr><td><code>Box&lt;dyn Read&gt;</code></td><td><code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code></td><td>Flexibility at boundaries</td></tr>
<tr><td><code>ReadDirIter</code></td><td><code>BoxedIntoRoute</code></td><td>Type erasure for storage</td></tr>
<tr><td><code>FileStorage::boxed()</code></td><td><code>BoxService</code> / <code>BoxCloneService</code></td><td>Opt-in type erasure</td></tr>
</tbody>
</table>
</div>
<p>Tower’s Timeout middleware <a href="https://docs.rs/tower/latest/tower/trait.Service.html">uses <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code></a> in practice. Axum’s Router <a href="https://github.com/tokio-rs/axum/discussions/1438">uses <code>BoxedIntoRoute</code></a> to store handlers. We follow the same pattern.</p>
<h3 id="cost-analysis"><a class="header" href="#cost-analysis">Cost Analysis</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Box Allocation</th><th>Actual I/O</th><th>Box % of Total</th></tr>
</thead>
<tbody>
<tr><td>Open + read 4KB file</td><td>~50ns</td><td>~10,000ns</td><td>0.5%</td></tr>
<tr><td>Open + read 1MB file</td><td>~50ns</td><td>~1,000,000ns</td><td>0.005%</td></tr>
<tr><td>List directory (10 entries)</td><td>~50ns</td><td>~5,000ns</td><td>1%</td></tr>
</tbody>
</table>
</div>
<p><strong>The boxing cost is negligible relative to actual I/O.</strong></p>
<h3 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives Considered</a></h3>
<p><strong>1. Associated types everywhere:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead {
    type Reader: Read + Send;
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>Rejected: Causes type explosion. <code>QuotaReader&lt;PathFilterReader&lt;TracingReader&lt;Cursor&lt;Vec&lt;u8&gt;&gt;&gt;&gt;&gt;</code> is unwieldy and every middleware needs a custom wrapper type.</p>
<p><strong>2. RPITIT (Rust 1.75+):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;impl Read + Send, FsError&gt;;
<span class="boring">}</span></code></pre>
<p>Rejected as default: Loses object safety. Can’t use <code>dyn Fs</code> for runtime backend selection.</p>
<p><strong>3. Always box everything:</strong>
Rejected: Unnecessary overhead on hot path operations like <code>read()</code>.</p>
<h3 id="future-considerations-2"><a class="header" href="#future-considerations-2">Future Considerations</a></h3>
<p>If profiling shows stream boxing is a bottleneck (unlikely), we can add:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Extension trait for zero-cost streaming when backend type is known
pub trait FsReadTyped: FsRead {
    type Reader: Read + Send;
    fn open_read_typed(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>This follows Tower’s pattern of providing both <code>Service</code> (with associated types) and <code>BoxService</code> (with type erasure).</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Our boxing strategy mirrors Tower/Axum’s production-proven approach:</p>
<ul>
<li><strong>Zero-cost where it matters</strong> (hot path bulk operations, middleware composition)</li>
<li><strong>Box where flexibility is needed</strong> (streaming I/O, iterator filtering)</li>
<li><strong>Opt-in type erasure</strong> (explicit <code>boxed()</code> method)</li>
</ul>
<p>The performance cost is negligible (&lt;1% of I/O time), while the ergonomic and flexibility benefits are substantial.</p>
<hr>
<h2 id="adr-026-companion-shell-anyfs-shell"><a class="header" href="#adr-026-companion-shell-anyfs-shell">ADR-026: Companion shell (anyfs-shell)</a></h2>
<p><strong>Status:</strong> Accepted (Future)</p>
<p><strong>Context:</strong> Users want a low-friction way to explore how different backends and middleware behave without writing a full application.</p>
<p><strong>Decision:</strong> Provide a separate companion crate (e.g., <code>anyfs-shell</code>) that exposes a bash-style navigation and file management interface built on <code>FileStorage</code>.</p>
<p><strong>Scope:</strong></p>
<ul>
<li>Commands: <code>ls</code>, <code>cd</code>, <code>cat</code>, <code>cp</code>, <code>mv</code>, <code>rm</code>, <code>mkdir</code>, <code>stat</code>.</li>
<li>Navigation and file management only; no full bash scripting, pipes, or job control.</li>
<li>All operations route through <code>FileStorage</code> to exercise middleware and backend composition.</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Demonstrates backend neutrality and middleware effects in a tangible way.</li>
<li>Useful for docs, demos, and quick validation.</li>
<li>Keeps the core crates free of CLI/UI dependencies.</li>
</ul>
<hr>
<h2 id="adr-027-permissive-core-security-via-middleware"><a class="header" href="#adr-027-permissive-core-security-via-middleware">ADR-027: Permissive core; security via middleware</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> We need predictable filesystem semantics across backends. Some use cases require strict sandboxing, while others expect full filesystem behavior. Baking security restrictions into core traits would make behavior surprising and backend-dependent.</p>
<p><strong>Decision:</strong> Core traits are permissive: all operations supported by a backend are allowed by default. Security controls (limits, access control, read-only, rate limiting, audit) are applied via middleware such as <code>Restrictions</code>, <code>PathFilter</code>, <code>ReadOnly</code>, <code>Quota</code>, <code>RateLimit</code>, and <code>Tracing</code>.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Predictability: core behavior matches <code>std::fs</code> expectations.</li>
<li>Backend-agnostic: virtual and host backends share the same contract.</li>
<li>Separation of concerns: policy lives in middleware, not storage semantics.</li>
<li>Explicit security posture: applications opt in to the protections they need.</li>
</ul>
<hr>
<h2 id="adr-028-linux-like-semantics-for-virtual-backends"><a class="header" href="#adr-028-linux-like-semantics-for-virtual-backends">ADR-028: Linux-like semantics for virtual backends</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> Cross-platform filesystems differ in case sensitivity, separators, reserved names, and path length limits. Virtual backends need a consistent model that does not inherit OS quirks.</p>
<p><strong>Decision:</strong> Virtual backends use Linux-like semantics by default:</p>
<ul>
<li>Case-sensitive paths</li>
<li><code>/</code> as the internal separator</li>
<li>No reserved names</li>
<li>No max path length</li>
<li>No ADS (<code>:stream</code>) support</li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Cross-platform consistency for the same data.</li>
<li>Fewer surprises and reduced security footguns.</li>
<li>Simplifies backend implementation and testing.</li>
<li>Custom semantics remain possible via middleware or custom backends.</li>
</ul>
<hr>
<h2 id="adr-029-path-resolution-in-filestorage"><a class="header" href="#adr-029-path-resolution-in-filestorage">ADR-029: Path resolution in FileStorage</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> Path normalization (<code>//</code>, <code>.</code>, <code>..</code>) and symlink resolution must be consistent across backends. Implementing this logic in every backend is error-prone and leads to divergent behavior.</p>
<p><strong>Decision:</strong> <code>FileStorage</code> performs canonicalization and normalization for virtual backends. Backends receive resolved paths. Real filesystem backends (e.g., <code>VRootFsBackend</code>) delegate to OS resolution plus <code>strict-path</code> containment. <code>FileStorage</code> exposes <code>canonicalize</code>, <code>soft_canonicalize</code>, and <code>anchored_canonicalize</code> for explicit use.</p>
<p><strong>Why:</strong></p>
<ul>
<li>Consistent semantics across all backends.</li>
<li>Centralizes security-critical path handling.</li>
<li>Simplifies backend implementations.</li>
<li>Makes conformance testing straightforward.</li>
</ul>
<hr>
<h2 id="adr-030-layered-trait-hierarchy"><a class="header" href="#adr-030-layered-trait-hierarchy">ADR-030: Layered trait hierarchy</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> Not all backends can or should implement full POSIX behavior. Forcing a single large trait would make simple backends harder to implement and would obscure capabilities.</p>
<p><strong>Decision:</strong> Split the API into layered traits:</p>
<ul>
<li>Core: <code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code> (combined as <code>Fs</code>)</li>
<li>Extensions: <code>FsLink</code>, <code>FsPermissions</code>, <code>FsSync</code>, <code>FsStats</code></li>
<li>FUSE: <code>FsInode</code></li>
<li>POSIX: <code>FsHandles</code>, <code>FsLock</code>, <code>FsXattr</code></li>
<li>Convenience supertraits: <code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>, <code>FsPosix</code></li>
</ul>
<p><strong>Why:</strong></p>
<ul>
<li>Implement the lowest level you need.</li>
<li>Clear capability boundaries and trait bounds.</li>
<li>Avoids forcing unsupported features on backends.</li>
<li>Enables middleware to target specific capabilities.</li>
</ul>
<hr>
<h2 id="adr-031-indexing-as-middleware"><a class="header" href="#adr-031-indexing-as-middleware">ADR-031: Indexing as middleware</a></h2>
<p><strong>Status:</strong> Accepted (Future)</p>
<p><strong>Context:</strong> We want a durable, queryable index of file activity and metadata (for audit trails, drive management tools, and statistics). This indexing should be optional, configurable, and work across all backends.</p>
<p><strong>Decision:</strong> Indexing is implemented as middleware (<code>Indexing&lt;B&gt;</code> with <code>IndexLayer</code>), not as a specialized backend. The middleware writes to a sidecar index (SQLite by default) and can evolve to support alternate index engines.</p>
<p><strong>Naming:</strong> Use <code>IndexLayer</code> (builder) and <code>Indexing&lt;B&gt;</code> (middleware), consistent with existing layer naming.</p>
<p><strong>Why:</strong></p>
<ul>
<li><strong>Separation of concerns:</strong> Indexing is policy/analytics, not storage semantics.</li>
<li><strong>Backend-agnostic:</strong> Works with Memory, SQLite, VRootFs, and custom backends.</li>
<li><strong>Composability:</strong> Users opt in and configure it like other middleware (Quota, Tracing).</li>
<li><strong>Flexibility:</strong> Allows future index engines without changing core traits.</li>
<li><strong>DX consistency:</strong> Keeps std::fs-style usage via <code>FileStorage</code> with no API changes.</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<ul>
<li><strong>External OS changes:</strong> Not captured unless a future watcher/scan helper is added.</li>
<li><strong>Index failures:</strong> Choose between strict mode (fail the op) and best-effort mode.</li>
</ul>
<p><strong>Implementation sketch:</strong></p>
<ul>
<li><code>IndexLayer::builder().index_file("index.db").consistency(IndexConsistency::Strict)...</code></li>
<li>Wraps <code>open_write()</code> with a counting writer to record final size on close.</li>
<li>Updates a <code>nodes</code> table and logs <code>ops</code> entries per operation.</li>
</ul>
<hr>
<h2 id="adr-032-path-canonicalization-via-fspath-trait"><a class="header" href="#adr-032-path-canonicalization-via-fspath-trait">ADR-032: Path Canonicalization via FsPath Trait</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> Path canonicalization (resolving <code>..</code>, <code>.</code>, and symlinks) is needed for consistent path handling. The naive approach of baking this into <code>FileStorage</code> has issues:</p>
<ul>
<li>It’s not testable in isolation</li>
<li>It can’t be optimized per-backend</li>
<li>N+1 queries for paths like <code>/a/b/c/d/e</code> (each component = separate call)</li>
</ul>
<p><strong>Decision:</strong> Introduce an <code>FsPath</code> trait with <code>canonicalize()</code> and <code>soft_canonicalize()</code> methods that have <strong>default implementations</strong> but allow <strong>backend-specific optimizations</strong>.</p>
<p><strong>The Pattern:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsPath: FsRead + FsLink {
    /// Resolve all symlinks and normalize path components.
    /// Returns error if final path doesn't exist.
    fn canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        default_canonicalize(self, path)
    }

    /// Like canonicalize, but allows non-existent final component.
    fn soft_canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        default_soft_canonicalize(self, path)
    }
}

// Auto-implement for all FsLink implementors
impl&lt;T: FsRead + FsLink&gt; FsPath for T {}
<span class="boring">}</span></code></pre>
<p><strong>Default Implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn default_canonicalize&lt;F: FsRead + FsLink&gt;(fs: &amp;F, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
    let mut resolved = PathBuf::from("/");
    for component in path.components() {
        match component {
            Component::RootDir =&gt; resolved = PathBuf::from("/"),
            Component::ParentDir =&gt; { resolved.pop(); },
            Component::CurDir =&gt; {},
            Component::Normal(name) =&gt; {
                resolved.push(name);
                if let Ok(meta) = fs.symlink_metadata(&amp;resolved) {
                    if meta.file_type.is_symlink() {
                        let target = fs.read_link(&amp;resolved)?;
                        resolved.pop();
                        resolved = resolve_relative(&amp;resolved, &amp;target);
                    }
                }
            },
            _ =&gt; {},
        }
    }
    // Verify final path exists
    if !fs.exists(&amp;resolved)? {
        return Err(FsError::NotFound { path: resolved, operation: "canonicalize" });
    }
    Ok(resolved)
}
<span class="boring">}</span></code></pre>
<p><strong>Backend Optimization Examples:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Optimization</th></tr>
</thead>
<tbody>
<tr><td><code>SqliteBackend</code></td><td>Single recursive CTE query resolves entire path</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Delegates to <code>std::fs::canonicalize()</code> + containment check</td></tr>
<tr><td><code>MemoryBackend</code></td><td>Uses default (in-memory is fast anyway)</td></tr>
</tbody>
</table>
</div>
<p><strong>SQLite Optimized Implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsPath for SqliteBackend {
    fn canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        // Single query with recursive CTE
        self.conn.query_row(
            r#"
            WITH RECURSIVE path_resolve(segment, remaining, resolved, depth) AS (
                -- Initial: split path into segments
                SELECT ..., 0
                UNION ALL
                -- Recursive: resolve each segment, following symlinks
                SELECT ...
                FROM path_resolve
                JOIN nodes ON ...
                WHERE depth &lt; 40  -- Loop protection
            )
            SELECT resolved FROM path_resolve 
            WHERE remaining = '' 
            ORDER BY depth DESC LIMIT 1
            "#,
            params![path.to_string_lossy()],
            |row| Ok(PathBuf::from(row.get::&lt;_, String&gt;(0)?))
        ).map_err(|e| FsError::NotFound { path: path.into(), operation: "canonicalize" })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why This Design:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Benefit</th><th>Explanation</th></tr>
</thead>
<tbody>
<tr><td><strong>Portable default</strong></td><td>Works with any <code>Fs</code> backend out of the box</td></tr>
<tr><td><strong>Optimizable</strong></td><td>Backends can override for O(1) queries vs O(n)</td></tr>
<tr><td><strong>Testable</strong></td><td>Canonicalization logic is separate, can be unit tested</td></tr>
<tr><td><strong>Composable</strong></td><td>Middleware can wrap/intercept canonicalization</td></tr>
</tbody>
</table>
</div>
<p><strong>FileStorage Integration:</strong></p>
<blockquote>
<p><strong>Note:</strong> ADR-033 introduces <code>PathResolver</code> as the primary resolution strategy. <code>FsPath</code> remains
as an optional backend optimization hook. When a backend implements both <code>FsPath</code> and the default
traits, the backend can choose to delegate to its resolver or provide fully custom logic (e.g.,
SQLite CTE queries).</p>
</blockquote>
<p>FileStorage uses <code>PathResolver</code> for its resolution (see ADR-033):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: Fs, R: PathResolver, M&gt; FileStorage&lt;B, R, M&gt; {
    pub fn canonicalize(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.resolver.canonicalize(path.as_ref(), &amp;self.backend as &amp;dyn Fs)
    }

    pub fn soft_canonicalize(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.resolver.soft_canonicalize(path.as_ref(), &amp;self.backend as &amp;dyn Fs)
    }
}
<span class="boring">}</span></code></pre>
<p>Backends implementing <code>FsPath</code> can provide optimized implementations that the resolver MAY use:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsPath for SqliteBackend {
    fn canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        // Optimized: single CTE query instead of iterative resolution
        self.conn.query_row(/* ... */)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Trade-offs:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Queries</th><th>Complexity</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td>Default impl</td><td>O(n) per component</td><td>Simple</td><td>Memory, small files</td></tr>
<tr><td>SQLite CTE</td><td>O(1) single query</td><td>Moderate</td><td>Large trees, many symlinks</td></tr>
<tr><td>OS delegation</td><td>O(1) syscall</td><td>Simple</td><td>Real filesystem</td></tr>
</tbody>
</table>
</div>
<p><strong>Conclusion:</strong> The <code>FsPath</code> trait provides a clean abstraction that works everywhere but can be optimized where it matters. This follows Rust’s “zero-cost abstractions” philosophy: you don’t pay for what you don’t use, and you can optimize hot paths when needed.</p>
<hr>
<h2 id="adr-033-pathresolver-trait-for-pluggable-resolution"><a class="header" href="#adr-033-pathresolver-trait-for-pluggable-resolution">ADR-033: PathResolver Trait for Pluggable Resolution</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> Path resolution (normalizing <code>..</code>, <code>.</code>, and following symlinks) is currently handled in two places:</p>
<ol>
<li><code>FsPath</code> trait methods (<code>canonicalize</code>, <code>soft_canonicalize</code>) with backend-specific optimizations</li>
<li><code>FileStorage</code> performs pre-resolution for non-<code>SelfResolving</code> backends</li>
<li><code>SelfResolving</code> marker trait opts out of FileStorage resolution</li>
</ol>
<p>This works, but the resolution <strong>algorithm</strong> is not a first-class, testable unit. The logic is spread across components, making it harder to:</p>
<ul>
<li>Test path resolution in isolation</li>
<li>Benchmark/profile resolution performance</li>
<li>Provide third-party custom resolvers</li>
<li>Explore alternative resolution strategies (case-insensitive, caching, etc.)</li>
</ul>
<p><strong>Decision:</strong> Introduce a <code>PathResolver</code> trait that encapsulates the path resolution algorithm as a standalone, pluggable component.</p>
<p><strong>The Pattern:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-backend (trait definition)
/// Strategy trait for path resolution algorithms.
///
/// Encapsulates path normalization, `..`/`.` resolution, and optionally symlink following.
/// Symlink resolution requires the backend to implement `FsLink`. If the backend only
/// implements `Fs`, the resolver will normalize paths and resolve `.`/`..` but cannot
/// follow symlinks (they are treated as regular files/directories).
pub trait PathResolver: Send + Sync {
    /// Resolve path to canonical form.
    /// If backend implements `FsLink`, symlinks are followed up to max depth.
    /// If backend only implements `Fs`, symlinks are not followed.
    fn canonicalize(&amp;self, path: &amp;Path, fs: &amp;dyn Fs) -&gt; Result&lt;PathBuf, FsError&gt;;
    
    /// Like canonicalize, but allows non-existent final component.
    fn soft_canonicalize(&amp;self, path: &amp;Path, fs: &amp;dyn Fs) -&gt; Result&lt;PathBuf, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Note on symlink handling:</strong> The trait accepts <code>&amp;dyn Fs</code> for object safety, but implementations can attempt to downcast to <code>&amp;dyn FsLink</code> when symlink awareness is needed. All built-in virtual backends implement <code>FsLink</code>, so this works seamlessly. For backends without <code>FsLink</code>, resolution still works but treats all entries as non-symlinks.</p>
<p><strong>Built-in Implementations (in <code>anyfs</code> crate):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Default iterative resolver - walks path component by component.
/// Follows symlinks if the backend implements FsLink.
pub struct IterativeResolver {
    max_symlink_depth: usize,  // Default: 40
}

/// No-op resolver for SelfResolving backends (OS handles resolution).
pub struct NoOpResolver;

/// LRU cache wrapper around another resolver.
pub struct CachingResolver&lt;R: PathResolver&gt; {
    inner: R,
    cache: Cache&lt;PathBuf, PathBuf&gt;,  // LRU cache, bounded size
}

// Case-folding resolver is NOT built-in. Users can implement one via PathResolver
// trait if needed, but real-world demand is minimal since VRootFsBackend on
// Windows/macOS already gets case-insensitivity from the OS.
<span class="boring">}</span></code></pre>
<p><strong>Integration with FileStorage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: Fs, M&gt; FileStorage&lt;B, IterativeResolver, M&gt; {
    pub fn new(backend: B) -&gt; Self { ... }
}

impl&lt;B: Fs, R: PathResolver, M&gt; FileStorage&lt;B, R, M&gt; {
    pub fn with_resolver(backend: B, resolver: R) -&gt; Self {
        Self { backend, resolver, _marker: PhantomData }
    }
}

// Usage
let fs = FileStorage::new(backend);  // Uses IterativeResolver
let fs = FileStorage::with_resolver(backend, CachingResolver::new(IterativeResolver::default()));
<span class="boring">}</span></code></pre>
<p><strong>Relationship with FsPath Trait:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td><code>PathResolver</code></td><td>Algorithm for resolution (first-class, testable, swappable)</td></tr>
<tr><td><code>FsPath</code></td><td>Backend-level optimization hook (can delegate to resolver or override entirely)</td></tr>
<tr><td><code>SelfResolving</code></td><td>Remains as marker OR becomes <code>NoOpResolver</code> assignment</td></tr>
</tbody>
</table>
</div>
<p><code>FsPath</code> can delegate to the resolver:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsPath: FsRead + FsLink {
    fn resolver(&amp;self) -&gt; &amp;dyn PathResolver {
        static DEFAULT: IterativeResolver = IterativeResolver::new();
        &amp;DEFAULT
    }
    
    fn canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.resolver().canonicalize(path, self)
    }
}
<span class="boring">}</span></code></pre>
<p>Or backends can override entirely for optimized implementations (e.g., SQLite CTE).</p>
<p><strong>Why This Design:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Benefit</th><th>Explanation</th></tr>
</thead>
<tbody>
<tr><td><strong>Testable in isolation</strong></td><td>Unit test resolvers without full backend setup</td></tr>
<tr><td><strong>Benchmarkable</strong></td><td>Profile resolution algorithms independently</td></tr>
<tr><td><strong>Third-party extensible</strong></td><td>Custom resolvers without touching <code>Fs</code> traits</td></tr>
<tr><td><strong>Maintainable</strong></td><td>Path resolution is one focused, isolated component</td></tr>
<tr><td><strong>New capabilities</strong></td><td>Case-insensitive, caching, Windows-style resolvers become easy</td></tr>
<tr><td><strong>Backwards compatible</strong></td><td>Existing FsPath overrides still work; resolver is additive</td></tr>
</tbody>
</table>
</div>
<p><strong>Crate Placement:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Crate</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td><code>PathResolver</code> trait</td><td><code>anyfs-backend</code></td><td>Core contract, minimal deps</td></tr>
<tr><td><code>IterativeResolver</code></td><td><code>anyfs</code></td><td>Default impl, needs Fs methods</td></tr>
<tr><td><code>NoOpResolver</code></td><td><code>anyfs</code></td><td>For SelfResolving backends</td></tr>
<tr><td><code>CachingResolver</code></td><td><code>anyfs</code></td><td>Optional, needs cache impl</td></tr>
<tr><td>FileStorage integration</td><td><code>anyfs</code></td><td>Uses resolvers for path handling</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> Case-folding resolvers are NOT built-in. The <code>PathResolver</code> trait allows users to implement custom resolvers if needed, but we don’t ship speculative features.</p>
</blockquote>
<p><strong>Example Use Cases:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default: case-sensitive, symlink-aware (IterativeResolver is ZST, zero-cost)
let fs = FileStorage::new(MemoryBackend::new());

// Caching for read-heavy workloads
let fs = FileStorage::with_resolver(
    backend,
    CachingResolver::new(IterativeResolver::default())
);

// Custom resolver (user-implemented)
let fs = FileStorage::with_resolver(backend, MyCustomResolver::new());

// Testing: verify resolution behavior in isolation
#[test]
fn test_symlink_loop_detection() {
    let resolver = IterativeResolver::new();
    let mock_fs = MockFs::with_symlink_loop();
    let result = resolver.canonicalize(Path::new("/loop"), &amp;mock_fs);
    assert!(matches!(result, Err(FsError::InvalidData { .. })));
}
<span class="boring">}</span></code></pre>
<p><strong>Conclusion:</strong> The <code>PathResolver</code> trait provides clean separation of concerns, making path resolution testable, benchmarkable, and extensible. It complements <code>FsPath</code> (backend optimization hook) and can replace or work alongside <code>SelfResolving</code> (via <code>NoOpResolver</code>).</p>
<hr>
<h2 id="adr-034-llm-oriented-architecture-loa"><a class="header" href="#adr-034-llm-oriented-architecture-loa">ADR-034: LLM-Oriented Architecture (LOA)</a></h2>
<p><strong>Status:</strong> Accepted</p>
<p><strong>Context:</strong> AnyFS is being developed with significant LLM assistance (GitHub Copilot, Claude, etc.). Traditional software architecture prioritizes maintainability, testability, and extensibility for <strong>human developers</strong>. However, when LLMs are part of the development workflow, additional constraints become essential:</p>
<ol>
<li>LLMs work best with <strong>limited context windows</strong> - they can’t “understand” an entire codebase</li>
<li>LLMs excel at <strong>pattern matching</strong> - consistent structure enables better assistance</li>
<li>LLMs need <strong>clear contracts</strong> - well-documented interfaces reduce hallucination</li>
<li>LLMs benefit from <strong>isolated components</strong> - fixing one thing shouldn’t require understanding everything</li>
</ol>
<p>These same properties also benefit:</p>
<ul>
<li>Open source contributors (quick onboarding)</li>
<li>Code review (focused changes)</li>
<li>Parallel development (independent components)</li>
<li>AI-generated tests and documentation</li>
</ul>
<p><strong>Decision:</strong> Structure AnyFS using <strong>LLM-Oriented Architecture (LOA)</strong> - a methodology where every component is independently understandable, testable, and fixable with only local context.</p>
<p><strong>The Five Pillars:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pillar</th><th>Description</th><th>Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Single Responsibility</strong></td><td>One file = one concept</td><td><code>quota.rs</code>, <code>iterative.rs</code>, etc.</td></tr>
<tr><td><strong>Contract-First</strong></td><td>Traits define the spec</td><td>Documented trait invariants</td></tr>
<tr><td><strong>Isolated Testing</strong></td><td>Tests use mocks only</td><td>No real backends in unit tests</td></tr>
<tr><td><strong>Rich Errors</strong></td><td>Errors explain the fix</td><td>Context in every <code>FsError</code> variant</td></tr>
<tr><td><strong>Boundary Docs</strong></td><td>Examples at every API</td><td>Usage example in every doc comment</td></tr>
</tbody>
</table>
</div>
<p><strong>File Structure Convention:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # Component Name
//!
//! ## Responsibility
//! - Single bullet point
//!
//! ## Dependencies  
//! - Traits/types only
//!
//! ## Usage
//! ```rust
//! // Minimal example
//! ```

// ============================================================================
// Types
// ============================================================================

// ============================================================================
// Trait Implementations
// ============================================================================

// ============================================================================
// Public API
// ============================================================================

// ============================================================================
// Private Helpers
// ============================================================================

// ============================================================================
// Tests
// ============================================================================
<span class="boring">}</span></code></pre>
<p><strong>Component Isolation Checklist:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Single file per component</li>
<li><input disabled="" type="checkbox"> Implements a trait with documented invariants</li>
<li><input disabled="" type="checkbox"> Dependencies are traits/types, not implementations</li>
<li><input disabled="" type="checkbox"> Tests use mocks, not real backends</li>
<li><input disabled="" type="checkbox"> Error messages explain what went wrong and how to fix</li>
<li><input disabled="" type="checkbox"> Doc comment shows standalone usage example</li>
<li><input disabled="" type="checkbox"> No global state</li>
<li><input disabled="" type="checkbox"> <code>Send + Sync</code> where required</li>
</ul>
<p><strong>LLM Prompting Patterns:</strong></p>
<p>The architecture enables these clean prompts:</p>
<pre><code># Implement (user-provided resolver example)
Implement a case-folding resolver in your project.
Contract: Implement `PathResolver` trait from anyfs-backend.
Test: "/Foo/BAR" → "/foo/bar"

# Fix
Bug: Quota&lt;B&gt; doesn't account for existing file size.
File: src/middleware/quota.rs
Error: QuotaExceeded writing 50 bytes to 30-byte file with 100-byte limit.

# Review
Does this change maintain the PathResolver contract?
Are edge cases handled?
Are error messages informative?
</code></pre>
<p><strong>Deliverables:</strong></p>
<ol>
<li><strong>AGENTS.md</strong> - Instructions for LLMs contributing to the codebase</li>
<li><strong>LLM Development Methodology Guide</strong> - Full methodology documentation</li>
<li><strong>llm-context.md</strong> - Context7-style API guide for LLMs <em>using</em> the library</li>
</ol>
<p><strong>Why This Design:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Benefit</th><th>For LLMs</th><th>For Humans</th></tr>
</thead>
<tbody>
<tr><td>Isolated components</td><td>Fits in context window</td><td>Easy to understand</td></tr>
<tr><td>Clear contracts</td><td>Reduces hallucination</td><td>Self-documenting</td></tr>
<tr><td>Consistent structure</td><td>Pattern matching works</td><td>Predictable codebase</td></tr>
<tr><td>Rich errors</td><td>Can suggest fixes</td><td>Quick debugging</td></tr>
<tr><td>Focused tests</td><td>Can verify changes</td><td>Fast CI</td></tr>
</tbody>
</table>
</div>
<p><strong>Trade-offs:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>Deep abstraction</td><td>Maximum isolation</td><td>More files, more indirection</td></tr>
<tr><td>Monolithic design</td><td>Fewer files</td><td>LLMs can’t reason about it</td></tr>
<tr><td>LOA (chosen)</td><td>LLM-friendly + maintainable</td><td>Requires discipline</td></tr>
</tbody>
</table>
</div>
<p><strong>Relationship to Other ADRs:</strong></p>
<ul>
<li><strong>ADR-030 (Layered traits):</strong> LOA extends this with per-file isolation</li>
<li><strong>ADR-033 (PathResolver):</strong> Example of LOA - resolver is isolated, testable, replaceable</li>
<li><strong>ADR-025 (Strategic Boxing):</strong> LOA prefers simplicity over micro-optimization</li>
</ul>
<p><strong>Conclusion:</strong> LLM-Oriented Architecture is not just about AI. It’s about creating a codebase where <strong>any component can be understood, tested, fixed, or replaced with only local context</strong>. This benefits LLMs, open source contributors, code reviewers, and future maintainers equally. As AI-assisted development becomes standard, LOA positions AnyFS as a reference implementation for sustainable human-AI collaboration.</p>
<p><strong>See Also:</strong> <a href="#llm-optimized-development-methodology">LLM Development Methodology Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="indexedbackend-pattern"><a class="header" href="#indexedbackend-pattern">IndexedBackend Pattern</a></h1>
<p><strong>SQLite Metadata + Content-Addressed Blob Storage</strong></p>
<p>This document describes the IndexedBackend architecture pattern: separating filesystem metadata (stored in SQLite) from file content (stored as blobs). This enables efficient queries, large file support, and flexible storage backends.</p>
<blockquote>
<p><strong>Built-in Implementation:</strong> AnyFS ships <code>IndexedBackend</code> as a production-ready implementation using local disk blobs. See the <a href="#indexedbackend">Backends Guide</a> for usage. This document covers the underlying design pattern for those building custom implementations (e.g., with S3, cloud storage, or custom blob stores).</p>
</blockquote>
<hr>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The <strong>IndexedBackend pattern</strong> separates:</p>
<ul>
<li><strong>Metadata</strong> (directory structure, inodes, permissions) → SQLite</li>
<li><strong>Content</strong> (file bytes) → Content-Addressed Storage (CAS)</li>
</ul>
<pre><code>┌─────────────────────────────────────────────────────────┐
│            IndexedBackend (pattern)                     │
│  ┌─────────────────────┐    ┌────────────────────────┐  │
│  │   SQLite Metadata   │    │   Blob Store (CAS)     │  │
│  │                     │    │                        │  │
│  │  - inodes           │    │  - content-addressed   │  │
│  │  - dir_entries      │    │  - deduplicated        │  │
│  │  - blob references  │    │  - S3, local, etc.     │  │
│  │  - audit log        │    │                        │  │
│  └─────────────────────┘    └────────────────────────┘  │
└─────────────────────────────────────────────────────────┘

Custom backends can use S3, cloud storage, or other blob stores.
IndexedBackend implements a simpler variant with UUID-named local blobs
(optimized for streaming; see note below on storage models).
</code></pre>
<p><strong>Why this pattern?</strong></p>
<ul>
<li>SQLite is great for metadata queries (directory listings, stats, audit)</li>
<li>Blob stores scale better for large file content</li>
<li>Content-addressing enables deduplication</li>
<li>Separating concerns enables independent scaling</li>
</ul>
<h3 id="storage-model-variants"><a class="header" href="#storage-model-variants">Storage Model Variants</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Model</th><th>Blob Naming</th><th>Dedup</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td><strong>Content-Addressed</strong></td><td>SHA-256 of content</td><td>✅ Yes</td><td>Cloud/S3, archival, multi-tenant</td></tr>
<tr><td><strong>UUID+Timestamp</strong></td><td><code>{uuid}-{timestamp}.bin</code></td><td>❌ No</td><td>Streaming large files, simplicity</td></tr>
</tbody>
</table>
</div>
<p><strong>IndexedBackend</strong> uses <strong>UUID+Timestamp</strong> naming because:</p>
<ul>
<li>Large files can be streamed without buffering the entire file to compute a hash</li>
<li>Write latency is consistent (no hash computation)</li>
<li>Simpler garbage collection (delete blob when reference removed)</li>
</ul>
<p><strong>Custom implementations</strong> may prefer <strong>content-addressed</strong> storage when:</p>
<ul>
<li>Deduplication is valuable (many users uploading same files)</li>
<li>Using cloud blob stores with native CAS support (S3, GCS)</li>
<li>Building archival systems where write latency is acceptable</li>
</ul>
<hr>
<h2 id="framework-validation"><a class="header" href="#framework-validation">Framework Validation</a></h2>
<h3 id="do-current-traits-support-this"><a class="header" href="#do-current-traits-support-this">Do Current Traits Support This?</a></h3>
<p><strong>Yes.</strong> The <code>Fs</code> traits define <em>operations</em>, not <em>storage implementation</em>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait Method</th><th>Hybrid Implementation</th></tr>
</thead>
<tbody>
<tr><td><code>read(path)</code></td><td>SQLite lookup → blob fetch</td></tr>
<tr><td><code>write(path, data)</code></td><td>Blob upload → SQLite update</td></tr>
<tr><td><code>metadata(path)</code></td><td>SQLite query only</td></tr>
<tr><td><code>read_dir(path)</code></td><td>SQLite query only</td></tr>
<tr><td><code>remove_file(path)</code></td><td>SQLite update (refcount–)</td></tr>
<tr><td><code>rename(from, to)</code></td><td>SQLite update only</td></tr>
<tr><td><code>copy(from, to)</code></td><td>SQLite update (refcount++)</td></tr>
</tbody>
</table>
</div>
<p>The traits don’t care where bytes come from - that’s the backend’s business.</p>
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h3>
<p>Current design requires <code>&amp;self</code> methods with interior mutability. For hybrid:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomIndexedBackend {
    // SQLite needs single-writer (see "Write Queue" below)
    metadata: Arc&lt;Mutex&lt;Connection&gt;&gt;,

    // Blob store is typically already thread-safe
    blobs: Arc&lt;dyn BlobStore&gt;,

    // Write queue for serializing SQLite writes
    write_tx: mpsc::Sender&lt;WriteCmd&gt;,
}
<span class="boring">}</span></code></pre>
<p>This aligns with ADR-023 (interior mutability).</p>
<hr>
<h2 id="data-model"><a class="header" href="#data-model">Data Model</a></h2>
<h3 id="sqlite-schema"><a class="header" href="#sqlite-schema">SQLite Schema</a></h3>
<pre><code class="language-sql">-- Inode table (one row per file/directory/symlink)
CREATE TABLE nodes (
    inode       INTEGER PRIMARY KEY,
    parent      INTEGER NOT NULL,
    name        TEXT NOT NULL,
    node_type   TEXT NOT NULL,  -- 'file', 'dir', 'symlink'
    size        INTEGER NOT NULL DEFAULT 0,
    mode        INTEGER NOT NULL DEFAULT 420,  -- 0o644
    nlink       INTEGER NOT NULL DEFAULT 1,
    blob_id     TEXT,           -- NULL for directories
    symlink_target TEXT,        -- NULL unless symlink
    created_at  INTEGER NOT NULL,
    modified_at INTEGER NOT NULL,
    accessed_at INTEGER NOT NULL,

    UNIQUE(parent, name)
);

-- Root directory (inode 1)
INSERT INTO nodes (inode, parent, name, node_type, size, mode, created_at, modified_at, accessed_at)
VALUES (1, 1, '', 'dir', 0, 493, strftime('%s', 'now'), strftime('%s', 'now'), strftime('%s', 'now'));

-- Blob reference tracking (for dedup + GC)
CREATE TABLE blobs (
    blob_id     TEXT PRIMARY KEY,  -- sha256 hex
    size        INTEGER NOT NULL,
    refcount    INTEGER NOT NULL DEFAULT 0,
    created_at  INTEGER NOT NULL
);

-- Audit log (optional but recommended)
CREATE TABLE audit (
    seq         INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp   INTEGER NOT NULL,
    operation   TEXT NOT NULL,
    path        TEXT,
    actor       TEXT,
    details     TEXT  -- JSON
);

-- Indexes
CREATE INDEX idx_nodes_parent ON nodes(parent);
CREATE INDEX idx_nodes_blob ON nodes(blob_id) WHERE blob_id IS NOT NULL;
CREATE INDEX idx_blobs_refcount ON blobs(refcount) WHERE refcount = 0;
</code></pre>
<h3 id="blob-store-interface"><a class="header" href="#blob-store-interface">Blob Store Interface</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Content-addressed blob storage.
pub trait BlobStore: Send + Sync {
    /// Store bytes, returns content hash (blob_id).
    fn put(&amp;self, data: &amp;[u8]) -&gt; Result&lt;String, BlobError&gt;;

    /// Retrieve bytes by content hash.
    fn get(&amp;self, blob_id: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, BlobError&gt;;

    /// Check if blob exists.
    fn exists(&amp;self, blob_id: &amp;str) -&gt; Result&lt;bool, BlobError&gt;;

    /// Delete blob (only call after refcount reaches 0).
    fn delete(&amp;self, blob_id: &amp;str) -&gt; Result&lt;(), BlobError&gt;;

    /// Streaming read for large files.
    fn open_read(&amp;self, blob_id: &amp;str) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, BlobError&gt;;

    /// Streaming write, returns blob_id on completion.
    fn open_write(&amp;self) -&gt; Result&lt;Box&lt;dyn BlobWriter&gt;, BlobError&gt;;
}

pub trait BlobWriter: Write + Send {
    /// Finalize the blob and return its content hash.
    fn finalize(self: Box&lt;Self&gt;) -&gt; Result&lt;String, BlobError&gt;;
}
<span class="boring">}</span></code></pre>
<p>Implementations could be:</p>
<ul>
<li><code>LocalCasBackend</code> - local directory with content-addressed files</li>
<li><code>S3BlobStore</code> - S3-compatible object storage</li>
<li><code>MemoryBlobStore</code> - in-memory for testing</li>
</ul>
<hr>
<h2 id="implementation-sketch"><a class="header" href="#implementation-sketch">Implementation Sketch</a></h2>
<h3 id="core-structure"><a class="header" href="#core-structure">Core Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter, DirEntry, FileType};
use rusqlite::Connection;
use std::sync::{Arc, Mutex};
use std::path::{Path, PathBuf};
use tokio::sync::mpsc;

pub struct CustomIndexedBackend {
    /// SQLite connection (metadata)
    db: Arc&lt;Mutex&lt;Connection&gt;&gt;,

    /// Content-addressed blob storage
    blobs: Arc&lt;dyn BlobStore&gt;,

    /// Write command queue (single-writer pattern)
    write_tx: mpsc::UnboundedSender&lt;WriteCmd&gt;,

    /// Background writer handle
    _writer_handle: Arc&lt;WriterHandle&gt;,
}

enum WriteCmd {
    Write {
        path: PathBuf,
        blob_id: String,
        size: u64,
        reply: oneshot::Sender&lt;Result&lt;(), FsError&gt;&gt;,
    },
    Remove {
        path: PathBuf,
        reply: oneshot::Sender&lt;Result&lt;(), FsError&gt;&gt;,
    },
    CreateDir {
        path: PathBuf,
        reply: oneshot::Sender&lt;Result&lt;(), FsError&gt;&gt;,
    },
    // ... other write operations
}
<span class="boring">}</span></code></pre>
<h3 id="read-operations-direct"><a class="header" href="#read-operations-direct">Read Operations (Direct)</a></h3>
<p>Read operations can query SQLite and blob store directly (no queue needed):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for CustomIndexedBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();

        // 1. Query SQLite for blob_id
        let db = self.db.lock().map_err(|_| FsError::Backend("lock poisoned".into()))?;

        let (blob_id, node_type): (Option&lt;String&gt;, String) = db.query_row(
            "SELECT blob_id, node_type FROM nodes WHERE inode = (
                SELECT inode FROM nodes WHERE parent = ? AND name = ?
            )",
            // ... path resolution params
            |row| Ok((row.get(0)?, row.get(1)?)),
        ).map_err(|_| FsError::NotFound { path: path.to_path_buf() })?;

        if node_type != "file" {
            return Err(FsError::NotAFile { path: path.to_path_buf() });
        }

        let blob_id = blob_id.ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;

        drop(db);  // Release lock before blob fetch

        // 2. Fetch from blob store
        self.blobs.get(&amp;blob_id)
            .map_err(|e| FsError::Backend(e.to_string()))
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        let path = path.as_ref();
        let db = self.db.lock().map_err(|_| FsError::Backend("lock poisoned".into()))?;

        // Pure SQLite query
        let exists: bool = db.query_row(
            "SELECT EXISTS(SELECT 1 FROM nodes WHERE parent = ? AND name = ?)",
            // ... params
            |row| row.get(0),
        ).unwrap_or(false);

        Ok(exists)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = path.as_ref();
        let db = self.db.lock().map_err(|_| FsError::Backend("lock poisoned".into()))?;

        // Pure SQLite query - no blob store needed
        db.query_row(
            "SELECT node_type, size, mode, nlink, created_at, modified_at, accessed_at, inode
             FROM nodes WHERE parent = ? AND name = ?",
            // ... params
            |row| {
                let node_type: String = row.get(0)?;
                Ok(Metadata {
                    file_type: match node_type.as_str() {
                        "file" =&gt; FileType::File,
                        "dir" =&gt; FileType::Directory,
                        "symlink" =&gt; FileType::Symlink,
                        _ =&gt; FileType::File,
                    },
                    size: row.get(1)?,
                    permissions: Some(row.get(2)?),
                    // ... other fields
                })
            },
        ).map_err(|_| FsError::NotFound { path: path.to_path_buf() })
    }

    // ... other FsRead methods
}
<span class="boring">}</span></code></pre>
<h3 id="write-operations-two-phase-commit"><a class="header" href="#write-operations-two-phase-commit">Write Operations (Two-Phase Commit)</a></h3>
<p>Writes use a two-phase pattern: upload blob first, then commit SQLite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsWrite for CustomIndexedBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Phase 1: Upload blob (can fail independently)
        let blob_id = self.blobs.put(data)
            .map_err(|e| FsError::Backend(format!("blob upload failed: {}", e)))?;

        // Phase 2: Commit metadata (via write queue)
        let (tx, rx) = oneshot::channel();

        self.write_tx.send(WriteCmd::Write {
            path,
            blob_id,
            size: data.len() as u64,
            reply: tx,
        }).map_err(|_| FsError::Backend("write queue closed".into()))?;

        // Wait for SQLite commit
        rx.blocking_recv()
            .map_err(|_| FsError::Backend("write cancelled".into()))?
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Queue the removal (blob cleanup happens in background via GC)
        let (tx, rx) = oneshot::channel();

        self.write_tx.send(WriteCmd::Remove { path, reply: tx })
            .map_err(|_| FsError::Backend("write queue closed".into()))?;

        rx.blocking_recv()
            .map_err(|_| FsError::Backend("remove cancelled".into()))?
    }

    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        // Copy is just a metadata operation - increment refcount, no blob copy!
        let (tx, rx) = oneshot::channel();

        self.write_tx.send(WriteCmd::Copy {
            from: from.as_ref().to_path_buf(),
            to: to.as_ref().to_path_buf(),
            reply: tx,
        }).map_err(|_| FsError::Backend("write queue closed".into()))?;

        rx.blocking_recv()
            .map_err(|_| FsError::Backend("copy cancelled".into()))?
    }

    // ... other FsWrite methods
}
<span class="boring">}</span></code></pre>
<h3 id="write-queue-worker"><a class="header" href="#write-queue-worker">Write Queue Worker</a></h3>
<p>The single-writer pattern for SQLite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn write_worker(
    db: Arc&lt;Mutex&lt;Connection&gt;&gt;,
    blobs: Arc&lt;dyn BlobStore&gt;,
    mut rx: mpsc::UnboundedReceiver&lt;WriteCmd&gt;,
) {
    while let Some(cmd) = rx.recv().await {
        let result = {
            let mut db = db.lock().unwrap();

            match cmd {
                WriteCmd::Write { path, blob_id, size, reply } =&gt; {
                    let result = db.execute_batch(&amp;format!(r#"
                        BEGIN;

                        -- Upsert blob record
                        INSERT INTO blobs (blob_id, size, refcount, created_at)
                        VALUES ('{blob_id}', {size}, 1, strftime('%s', 'now'))
                        ON CONFLICT(blob_id) DO UPDATE SET refcount = refcount + 1;

                        -- Update or insert node
                        -- (simplified - real impl needs path resolution)

                        -- Audit log
                        INSERT INTO audit (timestamp, operation, path)
                        VALUES (strftime('%s', 'now'), 'write', '{path}');

                        COMMIT;
                    "#));

                    let _ = reply.send(result.map_err(|e| FsError::Backend(e.to_string())));
                }

                WriteCmd::Remove { path, reply } =&gt; {
                    // Decrement refcount (GC cleans up when refcount = 0)
                    let result = db.execute_batch(&amp;format!(r#"
                        BEGIN;

                        -- Get blob_id before delete
                        -- Decrement refcount
                        -- Remove node
                        -- Audit log

                        COMMIT;
                    "#));

                    let _ = reply.send(result.map_err(|e| FsError::Backend(e.to_string())));
                }

                // ... other commands
            }
        };
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="deduplication"><a class="header" href="#deduplication">Deduplication</a></h2>
<p>Content-addressing gives you dedup for free:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BlobStore for LocalCasBackend {
    fn put(&amp;self, data: &amp;[u8]) -&gt; Result&lt;String, BlobError&gt; {
        // Hash the content
        let hash = sha256(data);
        let blob_id = hex::encode(hash);

        // Check if already exists
        let blob_path = self.root.join(&amp;blob_id[0..2]).join(&amp;blob_id);

        if blob_path.exists() {
            // Already have this content - dedup!
            return Ok(blob_id);
        }

        // Store new blob
        std::fs::create_dir_all(blob_path.parent().unwrap())?;
        std::fs::write(&amp;blob_path, data)?;

        Ok(blob_id)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Dedup in action:</strong></p>
<ul>
<li>User A writes <code>report.pdf</code> (10 MB) → blob <code>abc123</code>, refcount = 1</li>
<li>User B writes identical <code>report.pdf</code> → same blob <code>abc123</code>, refcount = 2</li>
<li>Physical storage: 10 MB (not 20 MB)</li>
</ul>
<h3 id="refcount-management"><a class="header" href="#refcount-management">Refcount Management</a></h3>
<pre><code class="language-sql">-- On file write (new reference to blob)
UPDATE blobs SET refcount = refcount + 1 WHERE blob_id = ?;

-- On file delete
UPDATE blobs SET refcount = refcount - 1 WHERE blob_id = ?;

-- On copy (no blob copy needed!)
UPDATE blobs SET refcount = refcount + 1 WHERE blob_id = ?;
</code></pre>
<hr>
<h2 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h2>
<p>Blobs with <code>refcount = 0</code> are orphans and can be deleted:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CustomIndexedBackend {
    /// Run garbage collection (call periodically or on-demand).
    pub fn gc(&amp;self) -&gt; Result&lt;GcStats, FsError&gt; {
        let db = self.db.lock().map_err(|_| FsError::Backend("lock".into()))?;

        // Find orphaned blobs
        let orphans: Vec&lt;String&gt; = db.prepare(
            "SELECT blob_id FROM blobs WHERE refcount = 0"
        )?.query_map([], |row| row.get(0))?
          .filter_map(|r| r.ok())
          .collect();

        drop(db);

        // Delete from blob store
        let mut deleted = 0;
        for blob_id in &amp;orphans {
            if self.blobs.delete(blob_id).is_ok() {
                deleted += 1;
            }
        }

        // Remove from SQLite
        let db = self.db.lock().unwrap();
        db.execute(
            "DELETE FROM blobs WHERE refcount = 0",
            [],
        )?;

        Ok(GcStats { orphans_found: orphans.len(), blobs_deleted: deleted })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>GC Safety:</strong></p>
<ul>
<li>Never delete blobs referenced by snapshots</li>
<li>Add <code>snapshot_refs</code> table or use <code>refcount</code> that includes snapshot references</li>
<li>Run GC in background, not during writes</li>
</ul>
<hr>
<h2 id="snapshots-and-backup"><a class="header" href="#snapshots-and-backup">Snapshots and Backup</a></h2>
<h3 id="creating-a-snapshot"><a class="header" href="#creating-a-snapshot">Creating a Snapshot</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CustomIndexedBackend {
    /// Create a point-in-time snapshot.
    pub fn snapshot(&amp;self, name: &amp;str) -&gt; Result&lt;SnapshotId, FsError&gt; {
        let db = self.db.lock().unwrap();

        db.execute_batch(&amp;format!(r#"
            BEGIN;

            -- Record snapshot
            INSERT INTO snapshots (name, created_at, root_manifest)
            VALUES ('{name}', strftime('%s', 'now'),
                    (SELECT json_group_array(blob_id) FROM blobs WHERE refcount &gt; 0));

            -- Pin all current blobs (prevent GC)
            UPDATE blobs SET refcount = refcount + 1
            WHERE blob_id IN (SELECT blob_id FROM nodes WHERE blob_id IS NOT NULL);

            COMMIT;
        "#))?;

        Ok(SnapshotId(name.to_string()))
    }

    /// Export as single portable artifact.
    pub fn export(&amp;self, dest: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        // 1. SQLite backup API for metadata
        let db = self.db.lock().unwrap();
        let backup_db = Connection::open(dest.as_ref().join("metadata.db"))?;
        db.backup(rusqlite::DatabaseName::Main, &amp;backup_db, None)?;

        // 2. Copy referenced blobs
        let blob_ids: Vec&lt;String&gt; = db.prepare(
            "SELECT DISTINCT blob_id FROM nodes WHERE blob_id IS NOT NULL"
        )?.query_map([], |row| row.get(0))?
          .filter_map(|r| r.ok())
          .collect();

        drop(db);

        let blobs_dir = dest.as_ref().join("blobs");
        std::fs::create_dir_all(&amp;blobs_dir)?;

        for blob_id in blob_ids {
            let data = self.blobs.get(&amp;blob_id)?;
            std::fs::write(blobs_dir.join(&amp;blob_id), data)?;
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware-integration"><a class="header" href="#middleware-integration">Middleware Integration</a></h2>
<p>Middleware works unchanged - it wraps the hybrid backend like any other:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, QuotaLayer, TracingLayer, PathFilterLayer};

let backend = CustomIndexedBackend::open("drive.db", LocalCasBackend::new("./blobs"))?;

// Standard middleware stack
let backend = backend
    .layer(QuotaLayer::builder()
        .max_total_size(50 * 1024 * 1024 * 1024)  // 50 GB
        .build())
    .layer(PathFilterLayer::builder()
        .deny("**/.env")
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(backend);

// Use like any other filesystem
fs.write("/documents/report.pdf", &amp;pdf_bytes)?;
<span class="boring">}</span></code></pre>
<p><strong>Quota tracking note:</strong> <code>QuotaLayer</code> tracks logical size (what users see), not physical size (with dedup). For physical tracking, the backend could expose <code>physical_usage()</code> separately.</p>
<hr>
<h2 id="async-considerations"><a class="header" href="#async-considerations">Async Considerations</a></h2>
<p>The hybrid pattern benefits significantly from async (ADR-024):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Sync Pain</th><th>Async Benefit</th></tr>
</thead>
<tbody>
<tr><td>Blob upload to S3</td><td>Blocks thread</td><td>Concurrent uploads</td></tr>
<tr><td>Multiple reads</td><td>Sequential</td><td>Parallel fetches</td></tr>
<tr><td>Write queue</td><td><code>blocking_recv()</code></td><td>Native async channel</td></tr>
<tr><td>GC</td><td>Blocks all ops</td><td>Background task</td></tr>
</tbody>
</table>
</div>
<p>When <code>AsyncFs</code> traits exist (ADR-024), the hybrid backend can use them naturally:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl AsyncFsRead for CustomIndexedBackend {
    async fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let blob_id = self.lookup_blob_id(path).await?;
        self.blobs.get_async(&amp;blob_id).await  // Non-blocking!
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="identified-gaps"><a class="header" href="#identified-gaps">Identified Gaps</a></h2>
<p>Areas where the current framework could be enhanced:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Gap</th><th>Current State</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Two-phase commit pattern</td><td>Not documented</td><td>Add to backend guide</td></tr>
<tr><td>Refcount/GC patterns</td><td>Not documented</td><td>Add section</td></tr>
<tr><td>Streaming large files</td><td><code>open_read</code>/<code>open_write</code> exist</td><td>Document chunked patterns</td></tr>
<tr><td>Physical vs logical size</td><td>Quota tracks logical only</td><td>Consider <code>PhysicalStats</code> trait</td></tr>
<tr><td>Background tasks (GC)</td><td>No pattern</td><td>Document spawn pattern</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>Framework validation: PASSED</strong></p>
<p>The current AnyFS trait design supports hybrid backends:</p>
<ul>
<li>Traits define operations, not storage</li>
<li>Interior mutability allows single-writer patterns</li>
<li>Middleware composes unchanged</li>
<li>Async strategy (ADR-024) enhances this pattern</li>
</ul>
<p><strong>Key patterns for hybrid backends:</strong></p>
<ol>
<li>Single-writer queue for SQLite</li>
<li>Two-phase commit (blob upload → SQLite commit)</li>
<li>Content-addressing for dedup</li>
<li>Refcounting for GC safety</li>
<li>Snapshot pinning for backup safety</li>
</ol>
<p>This validates that AnyFS is flexible enough for advanced storage architectures while maintaining its simple middleware composition model.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zero-cost-alternatives-for-io-operations"><a class="header" href="#zero-cost-alternatives-for-io-operations">Zero-Cost Alternatives for I/O Operations</a></h1>
<p>This document analyzes alternatives to dynamic dispatch (<code>Box&lt;dyn Trait&gt;</code>) for streaming I/O and directory iteration.</p>
<blockquote>
<p><strong>Decision:</strong> See <a href="#adr-025-strategic-boxing-tower-style">ADR-025: Strategic Boxing</a> for the formal decision.</p>
<p><strong>TL;DR:</strong> We follow Tower/Axum’s approach - zero-cost on hot path (<code>read()</code>, <code>write()</code>), box at cold path boundaries (<code>open_read()</code>, <code>read_dir()</code>). We avoid heap allocations and dynamic dispatch unless they buy flexibility with negligible performance impact.</p>
</blockquote>
<hr>
<h2 id="current-design-dynamic-dispatch"><a class="header" href="#current-design-dynamic-dispatch">Current Design (Dynamic Dispatch)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}

pub trait FsDir: Send + Sync {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt;;
}

// Where ReadDirIter is:
pub struct ReadDirIter(Box&lt;dyn Iterator&lt;Item = Result&lt;DirEntry, FsError&gt;&gt; + Send&gt;);
<span class="boring">}</span></code></pre>
<p><strong>Cost:</strong> One heap allocation per <code>open_read()</code>, <code>open_write()</code>, or <code>read_dir()</code> call.</p>
<hr>
<h2 id="option-1-associated-types-classic-approach"><a class="header" href="#option-1-associated-types-classic-approach">Option 1: Associated Types (Classic Approach)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    type Reader: Read + Send;

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader, FsError&gt;;
}

pub trait FsDir: Send + Sync {
    type DirIter: Iterator&lt;Item = Result&lt;DirEntry, FsError&gt;&gt; + Send;

    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::DirIter, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for MemoryBackend {
    type Reader = std::io::Cursor&lt;Vec&lt;u8&gt;&gt;;

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader, FsError&gt; {
        let data = self.read(path)?;
        Ok(std::io::Cursor::new(data))
    }
}

impl FsDir for MemoryBackend {
    type DirIter = std::vec::IntoIter&lt;Result&lt;DirEntry, FsError&gt;&gt;;

    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::DirIter, FsError&gt; {
        let entries = self.collect_entries(path)?;
        Ok(entries.into_iter())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="middleware-propagation-problem"><a class="header" href="#middleware-propagation-problem">Middleware Propagation Problem</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for Quota&lt;B&gt; {
    // Must define our own Reader type that wraps B::Reader
    type Reader = QuotaReader&lt;B::Reader&gt;;

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader, FsError&gt; {
        let inner = self.inner.open_read(path)?;
        Ok(QuotaReader::new(inner, self.usage.clone()))
    }
}

// Every middleware needs a custom wrapper type
struct QuotaReader&lt;R&gt; {
    inner: R,
    usage: Arc&lt;RwLock&lt;QuotaUsage&gt;&gt;,
}

impl&lt;R: Read&gt; Read for QuotaReader&lt;R&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
        // Track bytes read if needed
        self.inner.read(buf)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="the-type-explosion"><a class="header" href="#the-type-explosion">The Type Explosion</a></h3>
<p>With a middleware stack like <code>Quota&lt;PathFilter&lt;Tracing&lt;MemoryBackend&gt;&gt;&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type FinalReader = QuotaReader&lt;PathFilterReader&lt;TracingReader&lt;Cursor&lt;Vec&lt;u8&gt;&gt;&gt;&gt;&gt;;
type FinalDirIter = QuotaIter&lt;PathFilterIter&lt;TracingIter&lt;IntoIter&lt;Result&lt;DirEntry, FsError&gt;&gt;&gt;&gt;&gt;;
<span class="boring">}</span></code></pre>
<h3 id="verdict"><a class="header" href="#verdict">Verdict</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Assessment</th></tr>
</thead>
<tbody>
<tr><td>Heap allocations</td><td>✅ None</td></tr>
<tr><td>Type complexity</td><td>❌ Exponential growth</td></tr>
<tr><td>Middleware authoring</td><td>❌ Every middleware needs wrapper types</td></tr>
<tr><td>User ergonomics</td><td>⚠️ Type annotations become unwieldy</td></tr>
<tr><td>Compile times</td><td>❌ Longer due to monomorphization</td></tr>
</tbody>
</table>
</div>
<p><strong>Not recommended</strong> as the primary API due to complexity explosion.</p>
<hr>
<h2 id="option-2-rpitit-rust-175"><a class="header" href="#option-2-rpitit-rust-175">Option 2: RPITIT (Rust 1.75+)</a></h2>
<p>Return Position Impl Trait in Traits allows:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;impl Read + Send, FsError&gt;;
}

pub trait FsDir: Send + Sync {
    fn read_dir(&amp;self, path: &amp;Path)
        -&gt; Result&lt;impl Iterator&lt;Item = Result&lt;DirEntry, FsError&gt;&gt; + Send, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<p>The compiler infers a unique anonymous type for each implementor:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for MemoryBackend {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;impl Read + Send, FsError&gt; {
        let data = self.read(path)?;
        Ok(std::io::Cursor::new(data))  // Returns Cursor&lt;Vec&lt;u8&gt;&gt;, but caller sees impl Read
    }
}

impl FsRead for SqliteBackend {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;impl Read + Send, FsError&gt; {
        Ok(SqliteReader::new(self.conn.clone(), path))  // Different type, same interface
    }
}
<span class="boring">}</span></code></pre>
<h3 id="middleware-still-works"><a class="header" href="#middleware-still-works">Middleware Still Works</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for Tracing&lt;B&gt; {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;impl Read + Send, FsError&gt; {
        let span = tracing::span!(Level::DEBUG, "open_read");
        let _guard = span.enter();
        self.inner.open_read(path)  // Just forward - return type is inferred
    }
}
<span class="boring">}</span></code></pre>
<h3 id="the-catch-object-safety"><a class="header" href="#the-catch-object-safety">The Catch: Object Safety</a></h3>
<p><strong>RPITIT makes traits non-object-safe.</strong> You cannot do:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile with RPITIT
let backends: Vec&lt;Box&lt;dyn FsRead&gt;&gt; = vec![...];
<span class="boring">}</span></code></pre>
<h3 id="verdict-1"><a class="header" href="#verdict-1">Verdict</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Assessment</th></tr>
</thead>
<tbody>
<tr><td>Heap allocations</td><td>✅ None</td></tr>
<tr><td>Type complexity</td><td>✅ Hidden behind <code>impl Trait</code></td></tr>
<tr><td>Middleware authoring</td><td>✅ Simple forwarding</td></tr>
<tr><td>User ergonomics</td><td>✅ Clean API</td></tr>
<tr><td>Object safety</td><td>❌ Lost - can’t use <code>dyn FsRead</code></td></tr>
<tr><td>Rust version</td><td>⚠️ Requires 1.75+</td></tr>
</tbody>
</table>
</div>
<p><strong>Good for performance-critical paths</strong> but sacrifices <code>dyn</code> usage.</p>
<hr>
<h2 id="option-3-generic-associated-types-gats"><a class="header" href="#option-3-generic-associated-types-gats">Option 3: Generic Associated Types (GATs)</a></h2>
<p>For readers that borrow from the backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    type Reader&lt;'a&gt;: Read + Send where Self: 'a;

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader&lt;'_&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="use-case-zero-copy-reads"><a class="header" href="#use-case-zero-copy-reads">Use Case: Zero-Copy Reads</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for MemoryBackend {
    type Reader&lt;'a&gt; = &amp;'a [u8];  // Borrow directly from internal storage!

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader&lt;'_&gt;, FsError&gt; {
        let data = self.storage.read().unwrap();
        let bytes = data.get(path.as_ref())
            .ok_or(FsError::NotFound { path: path.as_ref().to_path_buf() })?;
        Ok(bytes.as_slice())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<p>GATs are powerful but add significant complexity:</p>
<ul>
<li>Lifetime parameters propagate through middleware</li>
<li>Not all backends can provide borrowed data (SQLite must copy)</li>
<li>Makes trait definitions harder to understand</li>
</ul>
<h3 id="verdict-2"><a class="header" href="#verdict-2">Verdict</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Assessment</th></tr>
</thead>
<tbody>
<tr><td>Heap allocations</td><td>✅ Can be zero-copy</td></tr>
<tr><td>Type complexity</td><td>❌ High (lifetimes everywhere)</td></tr>
<tr><td>Middleware authoring</td><td>❌ Complex lifetime handling</td></tr>
<tr><td>Use case fit</td><td>⚠️ Only benefits backends with owned data</td></tr>
</tbody>
</table>
</div>
<p><strong>Overkill for most use cases.</strong> Consider only for specialized zero-copy scenarios.</p>
<hr>
<h2 id="option-4-hybrid-approach-recommended"><a class="header" href="#option-4-hybrid-approach-recommended">Option 4: Hybrid Approach (Recommended)</a></h2>
<p>Provide <strong>both</strong> dynamic and static APIs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    /// Dynamic dispatch version (simple, flexible)
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}

/// Extension trait for zero-cost static dispatch
pub trait FsReadTyped: FsRead {
    type Reader: Read + Send;

    /// Static dispatch version (zero-cost, less flexible)
    fn open_read_typed(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader, FsError&gt;;
}

// Blanket impl for convenience when types align
impl&lt;T: FsReadTyped&gt; FsRead for T {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
        Ok(Box::new(self.open_read_typed(path)?))
    }
}
<span class="boring">}</span></code></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default: dynamic dispatch (works everywhere)
let reader = fs.open_read("/file.txt")?;

// Performance-critical: static dispatch
let reader: MemoryReader = fs.open_read_typed("/file.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="verdict-3"><a class="header" href="#verdict-3">Verdict</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Assessment</th></tr>
</thead>
<tbody>
<tr><td>Heap allocations</td><td>✅ Optional (use <code>_typed</code> to avoid)</td></tr>
<tr><td>Type complexity</td><td>✅ Hidden unless you opt-in</td></tr>
<tr><td>Middleware authoring</td><td>✅ Only implement base trait</td></tr>
<tr><td>User ergonomics</td><td>✅ Simple default, power when needed</td></tr>
<tr><td>Object safety</td><td>✅ Base trait remains object-safe</td></tr>
</tbody>
</table>
</div>
<p><strong>Best of both worlds</strong> - simple default, zero-cost opt-in.</p>
<hr>
<h2 id="option-5-callback-based-iteration"><a class="header" href="#option-5-callback-based-iteration">Option 5: Callback-Based Iteration</a></h2>
<p>Avoid returning iterators entirely:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsDir: Send + Sync {
    fn for_each_entry&lt;F&gt;(&amp;self, path: &amp;Path, f: F) -&gt; Result&lt;(), FsError&gt;
    where
        F: FnMut(DirEntry) -&gt; ControlFlow&lt;(), ()&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs.for_each_entry("/dir", |entry| {
    println!("{}", entry.name);
    ControlFlow::Continue(())
})?;
<span class="boring">}</span></code></pre>
<h3 id="verdict-4"><a class="header" href="#verdict-4">Verdict</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Assessment</th></tr>
</thead>
<tbody>
<tr><td>Heap allocations</td><td>✅ None</td></tr>
<tr><td>Ergonomics</td><td>❌ Callbacks are awkward</td></tr>
<tr><td>Early exit</td><td>✅ Via <code>ControlFlow::Break</code></td></tr>
<tr><td>Composability</td><td>❌ Can’t chain iterator methods</td></tr>
</tbody>
</table>
</div>
<p><strong>Not recommended</strong> as primary API. Could be added as optimization option.</p>
<hr>
<h2 id="option-6-stack-allocated-small-buffer"><a class="header" href="#option-6-stack-allocated-small-buffer">Option 6: Stack-Allocated Small Buffer</a></h2>
<p>For directory iteration, most directories are small:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use smallvec::SmallVec;

pub struct ReadDirIter {
    // Stack-allocate up to 32 entries, heap only if larger
    entries: SmallVec&lt;[Result&lt;DirEntry, FsError&gt;; 32]&gt;,
    index: usize,
}
<span class="boring">}</span></code></pre>
<h3 id="verdict-5"><a class="header" href="#verdict-5">Verdict</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Assessment</th></tr>
</thead>
<tbody>
<tr><td>Heap allocations</td><td>⚠️ Avoided for small directories</td></tr>
<tr><td>Memory overhead</td><td>⚠️ Larger stack frames</td></tr>
<tr><td>Dependencies</td><td>⚠️ Adds <code>smallvec</code> crate</td></tr>
</tbody>
</table>
</div>
<p><strong>Reasonable optimization</strong> for directory iteration specifically.</p>
<hr>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<h3 id="primary-api-keep-dynamic-dispatch"><a class="header" href="#primary-api-keep-dynamic-dispatch">Primary API: Keep Dynamic Dispatch</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}

pub trait FsDir: Send + Sync {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong></p>
<ol>
<li><strong>Simplicity</strong> - One type to learn, one API</li>
<li><strong>Object safety</strong> - Can use <code>Box&lt;dyn Fs&gt;</code> for runtime polymorphism</li>
<li><strong>Middleware simplicity</strong> - No wrapper types needed</li>
<li><strong>Actual cost is low</strong> - One allocation per stream open, not per read</li>
</ol>
<h3 id="optional-static-dispatch-extension-fast-path"><a class="header" href="#optional-static-dispatch-extension-fast-path">Optional: Static Dispatch Extension (Fast Path)</a></h3>
<p>For performance-critical code, offer typed variants. This is the <strong>first-class fast path</strong> for hot loops when the backend type is known:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsReadTyped: FsRead {
    type Reader: Read + Send;
    fn open_read_typed(&amp;self, path: &amp;Path) -&gt; Result&lt;Self::Reader, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="future-rpitit-when-object-safety-not-needed"><a class="header" href="#future-rpitit-when-object-safety-not-needed">Future: RPITIT When Object Safety Not Needed</a></h3>
<p>If a user doesn’t need <code>dyn Fs</code>, they can define their own trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsReadStatic: Send + Sync {
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;impl Read + Send, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="cost-analysis-is-it-actually-a-problem"><a class="header" href="#cost-analysis-is-it-actually-a-problem">Cost Analysis: Is It Actually a Problem?</a></h2>
<h3 id="heap-allocation-cost"><a class="header" href="#heap-allocation-cost">Heap Allocation Cost</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Allocations</th><th>Typical Size</th><th>Cost</th></tr>
</thead>
<tbody>
<tr><td><code>open_read()</code></td><td>1</td><td>~24-48 bytes (vtable + pointer)</td><td>~20-50ns</td></tr>
<tr><td><code>read()</code> (data)</td><td>0-1</td><td>File size</td><td>Dominates</td></tr>
<tr><td><code>read_dir()</code></td><td>1</td><td>~24-48 bytes</td><td>~20-50ns</td></tr>
<tr><td>Iteration</td><td>0</td><td>-</td><td>-</td></tr>
</tbody>
</table>
</div>
<p><strong>The allocation is dwarfed by actual I/O time.</strong> For a 4KB file read from SQLite or disk, the Box allocation is &lt;0.1% of total time.</p>
<h3 id="when-it-matters"><a class="header" href="#when-it-matters">When It Matters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Matters?</th></tr>
</thead>
<tbody>
<tr><td>Reading large files</td><td>No - I/O dominates</td></tr>
<tr><td>Reading many small files</td><td>Maybe - consider batching</td></tr>
<tr><td>Hot loop micro-benchmarks</td><td>Yes</td></tr>
<tr><td>Real-world applications</td><td>Rarely</td></tr>
</tbody>
</table>
</div>
<h3 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h3>
<p><strong>Dynamic dispatch is the right default.</strong> The cost is negligible for real workloads, and the ergonomic benefits are substantial. Offer static dispatch as an opt-in escape hatch for the rare cases where it matters.</p>
<hr>
<h2 id="summary-decision-matrix"><a class="header" href="#summary-decision-matrix">Summary Decision Matrix</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Alloc-Free</th><th>Simple</th><th>Object-Safe</th><th>Recommended</th></tr>
</thead>
<tbody>
<tr><td>Current (<code>Box&lt;dyn&gt;</code>)</td><td>❌</td><td>✅</td><td>✅</td><td>✅ Default</td></tr>
<tr><td>Associated Types</td><td>✅</td><td>❌</td><td>✅</td><td>❌ Too complex</td></tr>
<tr><td>RPITIT</td><td>✅</td><td>✅</td><td>❌</td><td>⚠️ When no dyn needed</td></tr>
<tr><td>GATs</td><td>✅</td><td>❌</td><td>❌</td><td>❌ Overkill</td></tr>
<tr><td>Hybrid</td><td>✅ opt-in</td><td>✅</td><td>✅</td><td>✅ Best of both</td></tr>
<tr><td>Callbacks</td><td>✅</td><td>❌</td><td>✅</td><td>❌ Awkward API</td></tr>
<tr><td>SmallVec</td><td>⚠️</td><td>✅</td><td>✅</td><td>⚠️ For ReadDirIter</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="indexing-middleware-design-plan"><a class="header" href="#indexing-middleware-design-plan">Indexing Middleware (Design Plan)</a></h1>
<p><strong>Status:</strong> Accepted (Future) — See ADR-031
<strong>Scope:</strong> Design plan only (no API break)</p>
<hr>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Provide a consistent, queryable index of file activity and metadata for real filesystems (SQLite default). The index tracks operations (create, write, rename, delete) and maintains a catalog of files for fast queries and statistics. This enables workflows like “manage a flash drive and query every change” and “mount a drive and get an implicit audit trail.”</p>
<p><strong>Direction:</strong> Middleware-only. Indexing is a composable layer users opt into when they want a queryable catalog of file activity.</p>
<hr>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li>Preserve std::fs-style DX via <code>FileStorage</code> (no change to core traits).</li>
<li>Track file operations with timestamps in a durable index (SQLite default).</li>
<li>Provide fast queries (by path, prefix, mtime, size, hash).</li>
<li>Keep index consistent for operations executed through AnyFS.</li>
<li>Keep the design open to future index engines via a small trait (SQLite default).</li>
</ul>
<hr>
<h2 id="non-goals"><a class="header" href="#non-goals">Non-Goals</a></h2>
<ul>
<li>Full OS-level auditing outside AnyFS (requires kernel hooks).</li>
<li>Mandatory hashing of all files (optional and expensive).</li>
<li>Replacing <code>Tracing</code> (indexing is storage + query, tracing is instrumentation).</li>
</ul>
<hr>
<h2 id="architecture-middleware-only"><a class="header" href="#architecture-middleware-only">Architecture (Middleware-Only)</a></h2>
<h3 id="indexing-middleware-primary"><a class="header" href="#indexing-middleware-primary">Indexing Middleware (Primary)</a></h3>
<p><strong>Shape:</strong> <code>Indexing&lt;B&gt;</code> where <code>B: Fs</code></p>
<p><strong>Layer:</strong> <code>IndexLayer</code> (builder-based, like <code>QuotaLayer</code>, <code>TracingLayer</code>)</p>
<p><strong>Behavior:</strong> Intercepts operations and writes entries into an index (SQLite by default). Works on all backends (Memory, SQLite, VRootFs, custom). Guarantees apply only to operations that flow through AnyFS.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Backend-agnostic.</li>
<li>Useful for virtual backends too.</li>
<li>No special-case OS behavior.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>External changes on real FS are not captured (unless a watcher/scan helper is added later).</li>
</ul>
<hr>
<h2 id="where-it-fits"><a class="header" href="#where-it-fits">Where It Fits</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommended</th></tr>
</thead>
<tbody>
<tr><td>AnyFS app wants an audit trail</td><td><code>Indexing&lt;B&gt;</code> middleware</td></tr>
<tr><td>Virtual backend needs queryable catalog</td><td><code>Indexing&lt;B&gt;</code> middleware</td></tr>
<tr><td>Real FS with external edits to track</td><td>Indexing middleware + future watcher/scan helper</td></tr>
<tr><td>Mounted drive where all access goes through AnyFS</td><td>Indexing middleware (enough)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="consistency-model"><a class="header" href="#consistency-model">Consistency Model</a></h2>
<ul>
<li><strong>Through AnyFS:</strong> Strong consistency for index updates in strict mode.</li>
<li><strong>External OS changes:</strong> Not captured by default. A future watcher/scan helper can reconcile.</li>
</ul>
<p><strong>Modes:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IndexConsistency {
    Strict,      // If index update fails, return error from FS op
    BestEffort,  // FS op succeeds even if index update fails
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="index-schema-sqlite"><a class="header" href="#index-schema-sqlite">Index Schema (SQLite)</a></h2>
<p>Minimal schema focused on query speed and durability:</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS nodes (
  path TEXT PRIMARY KEY,
  parent_path TEXT NOT NULL,
  file_type INTEGER NOT NULL,      -- 0=file, 1=dir, 2=symlink
  size INTEGER NOT NULL DEFAULT 0,
  inode INTEGER,
  nlink INTEGER,
  permissions INTEGER,
  created_at INTEGER,
  modified_at INTEGER,
  accessed_at INTEGER,
  symlink_target TEXT,
  hash BLOB,                        -- optional
  exists INTEGER NOT NULL DEFAULT 1,
  last_seen_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_nodes_parent ON nodes(parent_path);
CREATE INDEX IF NOT EXISTS idx_nodes_mtime ON nodes(modified_at);
CREATE INDEX IF NOT EXISTS idx_nodes_hash ON nodes(hash);

CREATE TABLE IF NOT EXISTS ops (
  id INTEGER PRIMARY KEY,
  ts INTEGER NOT NULL,
  op TEXT NOT NULL,                 -- "write", "rename", "remove", ...
  path TEXT,
  path_to TEXT,
  bytes INTEGER,
  status TEXT NOT NULL,             -- "ok" | "err"
  error TEXT
);

CREATE TABLE IF NOT EXISTS config (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
);
</code></pre>
<p><strong>Path normalization:</strong> Store virtual paths (what the user sees), not host paths. For host FS, optionally store host paths in a separate table if needed.</p>
<hr>
<h2 id="operation-mapping"><a class="header" href="#operation-mapping">Operation Mapping</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Index Update</th></tr>
</thead>
<tbody>
<tr><td><code>write</code>, <code>append</code>, <code>truncate</code></td><td>Upsert node, update size/mtime, log op</td></tr>
<tr><td><code>create_dir</code>, <code>create_dir_all</code></td><td>Insert dir nodes, log op</td></tr>
<tr><td><code>remove_file</code></td><td>Mark <code>exists=0</code>, log op</td></tr>
<tr><td><code>remove_dir</code>, <code>remove_dir_all</code></td><td>Mark subtree removed (prefix query), log op</td></tr>
<tr><td><code>rename</code></td><td>Update path + parent for subtree, log op</td></tr>
<tr><td><code>copy</code></td><td>Insert new node from source metadata, log op</td></tr>
<tr><td><code>symlink</code>, <code>hard_link</code></td><td>Insert node, set link metadata, log op</td></tr>
<tr><td><code>read</code>/<code>read_range</code></td><td>Optional op log only (configurable)</td></tr>
</tbody>
</table>
</div>
<p><strong>Streaming writes:</strong> Wrap <code>open_write()</code> with a counting writer that records final size and timestamps on close.</p>
<hr>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IndexConfig {
    pub index_file: PathBuf,            // sidecar index file (SQLite default)
    pub consistency: IndexConsistency,
    pub track_reads: bool,
    pub track_errors: bool,
    pub track_metadata: bool,
    pub content_hashing: ContentHashing, // None | OnWrite | OnDemand
    pub initial_scan: InitialScan,       // None | OnDemand | FullScan
}
<span class="boring">}</span></code></pre>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<ul>
<li>Middleware type: <code>Indexing&lt;B&gt;</code></li>
<li>Layer: <code>IndexLayer</code></li>
<li>Builder methods emphasize intent: <code>index_file</code>, <code>consistency</code>, <code>track_*</code>, <code>content_hashing</code>, <code>initial_scan</code></li>
</ul>
<h3 id="example-configuration"><a class="header" href="#example-configuration">Example Configuration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = MemoryBackend::new()
    .layer(IndexLayer::builder()
        .index_file("index.db")
        .consistency(IndexConsistency::Strict)
        .track_reads(false)
        .build());
<span class="boring">}</span></code></pre>
<h3 id="index-engine-abstraction-future"><a class="header" href="#index-engine-abstraction-future">Index Engine Abstraction (Future)</a></h3>
<p>To keep the middleware ergonomic while enabling alternate engines, define a small storage trait and keep SQLite as the default implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IndexStore: Send + Sync {
    fn upsert_node(&amp;self, node: IndexNode) -&gt; Result&lt;(), IndexError&gt;;
    fn mark_removed(&amp;self, path: &amp;Path) -&gt; Result&lt;(), IndexError&gt;;
    fn rename_prefix(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), IndexError&gt;;
    fn record_op(&amp;self, entry: OpEntry) -&gt; Result&lt;(), IndexError&gt;;
}

<span class="boring">}</span></code></pre>
<p>The default implementation uses SQLite at <code>index_file</code>. If/when alternate engines are needed, the <code>IndexLayer</code> builder can accept a boxed <code>IndexStore</code> for advanced use without introducing an enum.</p>
<hr>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<ul>
<li>Use WAL mode for concurrency.</li>
<li>Batch updates for recursive operations (rename/remove_dir_all).</li>
<li>Hashing is optional and should be off by default.</li>
<li>Keep op logs bounded (optional retention policy).</li>
</ul>
<hr>
<h2 id="security-and-containment"><a class="header" href="#security-and-containment">Security and Containment</a></h2>
<ul>
<li>Index file should live <strong>outside</strong> the root path by default.</li>
<li>For mounted drives, use a dedicated index path per mount.</li>
<li>Respect <code>PathFilter</code> and <code>Restrictions</code> when operating through middleware.</li>
</ul>
<hr>
<h2 id="mounting-scenario"><a class="header" href="#mounting-scenario">Mounting Scenario</a></h2>
<p>When mounted via <code>anyfs</code> (with <code>fuse</code> or <code>winfsp</code> feature flags), all access goes through AnyFS. The index becomes an implicit audit trail:</p>
<ul>
<li>Every file operation is logged.</li>
<li>Queries reflect all operations routed through AnyFS.</li>
</ul>
<hr>
<h2 id="open-questions"><a class="header" href="#open-questions">Open Questions</a></h2>
<ul>
<li>Should op logs be bounded by size/time by default?</li>
<li>Do we need a query API in <code>anyfs</code> or a separate <code>anyfs-index</code> crate?</li>
<li>Should middleware expose a read-only <code>IndexStore</code> handle for queries?</li>
<li>Should we add a companion watcher/scan tool for external changes on real FS?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layered-traits-anyfs-backend"><a class="header" href="#layered-traits-anyfs-backend">Layered Traits (anyfs-backend)</a></h1>
<p>AnyFS uses a <strong>layered trait architecture</strong> for maximum flexibility with minimal complexity.</p>
<p>See ADR-030 for the design rationale.</p>
<hr>
<h2 id="trait-hierarchy"><a class="header" href="#trait-hierarchy">Trait Hierarchy</a></h2>
<pre><code>                    FsPosix
                       │
        ┌──────────────┼──────────────┐
        │              │              │
   FsHandles       FsLock        FsXattr
        │              │              │
        └──────────────┼──────────────┘
                       │
                    FsFuse
                       │
                   FsInode
                       │
                    FsFull
                       │
        ┌──────┬───────┼───────┬──────┐
        │      │       │       │      │
   FsLink   FsPerm  FsSync  FsStats   │
        │      │       │       │      │
        └──────┴───────┼───────┴──────┘
                       │
                      Fs   ← Most users only need this
                       │
           ┌───────────┼───────────┐
           │           │           │
        FsRead      FsWrite     FsDir

                                              Derived Traits (auto-impl)
                                              ───────────────────────────
                                              FsPath: FsRead + FsLink
                                                (path canonicalization)
</code></pre>
<p><strong>Simple rule:</strong> Import <code>Fs</code> for basic use. Add traits as needed for advanced features.</p>
<p><strong>Note:</strong> <code>FsPath</code> is a derived trait with a blanket impl. Any type implementing <code>FsRead + FsLink</code> automatically gets <code>FsPath</code>. <code>SelfResolving</code> is a marker trait that opts out of <code>FileStorage</code> path resolution. <code>PathResolver</code> is a strategy trait for pluggable path resolution (see ADR-033).</p>
<hr>
<h2 id="layer-1-core-traits-required"><a class="header" href="#layer-1-core-traits-required">Layer 1: Core Traits (Required)</a></h2>
<blockquote>
<p><strong>Thread Safety:</strong> All traits require <code>Send + Sync</code> and use <code>&amp;self</code> for all methods. Backend implementers MUST use interior mutability (<code>RwLock</code>, <code>Mutex</code>, etc.) to ensure thread-safe concurrent access. See ADR-023 for rationale.</p>
<p><strong>Path Parameters:</strong> Core traits use <code>&amp;Path</code> so they are object-safe (<code>dyn Fs</code> works). For ergonomics, <code>FileStorage</code> and <code>FsExt</code> accept <code>impl AsRef&lt;Path&gt;</code> and forward to the core traits.</p>
</blockquote>
<h3 id="fsread"><a class="header" href="#fsread">FsRead</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt;;
    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt;;
    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt;;
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fswrite"><a class="header" href="#fswrite">FsWrite</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsWrite: Send + Sync {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn append(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn truncate(&amp;self, path: &amp;Path, size: u64) -&gt; Result&lt;(), FsError&gt;;
    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsdir"><a class="header" href="#fsdir">FsDir</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsDir: Send + Sync {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt;;
    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}

/// Iterator over directory entries. Wraps a boxed iterator for flexibility.
///
/// - Outer `Result` (from `read_dir()`) = "can I open this directory?"
/// - Inner `Result` (per item) = "can I read this entry?"
pub struct ReadDirIter(Box&lt;dyn Iterator&lt;Item = Result&lt;DirEntry, FsError&gt;&gt; + Send + 'static&gt;);

impl Iterator for ReadDirIter {
    type Item = Result&lt;DirEntry, FsError&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { self.0.next() }
}

impl ReadDirIter {
    pub fn new(iter: impl Iterator&lt;Item = Result&lt;DirEntry, FsError&gt;&gt; + Send + 'static) -&gt; Self {
        Self(Box::new(iter))
    }

    /// Create from a pre-collected vector (useful for middleware like Overlay).
    pub fn from_vec(entries: Vec&lt;Result&lt;DirEntry, FsError&gt;&gt;) -&gt; Self {
        Self(Box::new(entries.into_iter()))
    }

    /// Collect all entries, short-circuiting on first error.
    pub fn collect_all(self) -&gt; Result&lt;Vec&lt;DirEntry&gt;, FsError&gt; {
        self.collect()
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-2-extended-traits-optional"><a class="header" href="#layer-2-extended-traits-optional">Layer 2: Extended Traits (Optional)</a></h2>
<h3 id="fslink"><a class="header" href="#fslink">FsLink</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLink: Send + Sync {
    fn symlink(&amp;self, target: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn hard_link(&amp;self, original: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn read_link(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn symlink_metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fspermissions"><a class="header" href="#fspermissions">FsPermissions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsPermissions: Send + Sync {
    fn set_permissions(&amp;self, path: &amp;Path, perm: Permissions) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fssync"><a class="header" href="#fssync">FsSync</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsSync: Send + Sync {
    fn sync(&amp;self) -&gt; Result&lt;(), FsError&gt;;
    fn fsync(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsstats"><a class="header" href="#fsstats">FsStats</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsStats: Send + Sync {
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fspath-optimizable"><a class="header" href="#fspath-optimizable">FsPath (Optimizable)</a></h3>
<p>Path canonicalization with a default implementation. Backends can override for optimized resolution.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsPath: FsRead + FsLink {
    /// Resolve all symlinks and normalize path (.., .).
    /// Default: iterative resolution via read_link() and symlink_metadata().
    fn canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        // ... default impl ...
    }

    /// Like canonicalize, but allows non-existent final component.
    fn soft_canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        // ... default impl ...
    }
}
impl&lt;T: FsRead + FsLink&gt; FsPath for T {}
<span class="boring">}</span></code></pre>
<h3 id="selfresolving-marker"><a class="header" href="#selfresolving-marker">SelfResolving (Marker)</a></h3>
<p>Marker trait for backends that handle their own path resolution (e.g., <code>VRootFsBackend</code>, <code>StdFsBackend</code>). <code>FileStorage</code> will NOT perform virtual path resolution for these backends.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SelfResolving {}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-3-inode-trait-for-fuse"><a class="header" href="#layer-3-inode-trait-for-fuse">Layer 3: Inode Trait (For FUSE)</a></h2>
<h3 id="fsinode"><a class="header" href="#fsinode">FsInode</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsInode: Send + Sync {
    fn path_to_inode(&amp;self, path: &amp;Path) -&gt; Result&lt;u64, FsError&gt;;
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt;;
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="layer-4-posix-traits-full-posix"><a class="header" href="#layer-4-posix-traits-full-posix">Layer 4: POSIX Traits (Full POSIX)</a></h2>
<h3 id="posix-types"><a class="header" href="#posix-types">POSIX Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Opaque file handle (inode-based for efficiency)
pub struct Handle(pub u64);

/// File open flags (mirrors POSIX)
#[derive(Clone, Copy, Debug)]
pub struct OpenFlags {
    pub read: bool,
    pub write: bool,
    pub create: bool,
    pub truncate: bool,
    pub append: bool,
}

impl OpenFlags {
    pub const READ: Self = Self { read: true, write: false, create: false, truncate: false, append: false };
    pub const WRITE: Self = Self { read: false, write: true, create: true, truncate: true, append: false };
    pub const READ_WRITE: Self = Self { read: true, write: true, create: false, truncate: false, append: false };
    pub const APPEND: Self = Self { read: false, write: true, create: true, truncate: false, append: true };
}

/// File lock type (mirrors POSIX flock)
#[derive(Clone, Copy, Debug)]
pub enum LockType {
    Shared,     // Multiple readers
    Exclusive,  // Single writer
}
<span class="boring">}</span></code></pre>
<h3 id="fshandles"><a class="header" href="#fshandles">FsHandles</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsHandles: Send + Sync {
    fn open(&amp;self, path: &amp;Path, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt;;
    fn read_at(&amp;self, handle: Handle, buf: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn write_at(&amp;self, handle: Handle, data: &amp;[u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fslock"><a class="header" href="#fslock">FsLock</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLock: Send + Sync {
    fn lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;(), FsError&gt;;
    fn try_lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;bool, FsError&gt;;
    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsxattr"><a class="header" href="#fsxattr">FsXattr</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsXattr: Send + Sync {
    fn get_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn set_xattr(&amp;self, path: &amp;Path, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;(), FsError&gt;;
    fn list_xattr(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="convenience-supertraits"><a class="header" href="#convenience-supertraits">Convenience Supertraits</a></h2>
<p>These are automatically implemented via blanket impls:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Basic filesystem - covers 90% of use cases
pub trait Fs: FsRead + FsWrite + FsDir {}
impl&lt;T: FsRead + FsWrite + FsDir&gt; Fs for T {}

/// Full filesystem with all std::fs features
pub trait FsFull: Fs + FsLink + FsPermissions + FsSync + FsStats {}
impl&lt;T: Fs + FsLink + FsPermissions + FsSync + FsStats&gt; FsFull for T {}

/// FUSE-mountable filesystem
pub trait FsFuse: FsFull + FsInode {}
impl&lt;T: FsFull + FsInode&gt; FsFuse for T {}

/// Full POSIX filesystem
pub trait FsPosix: FsFuse + FsHandles + FsLock + FsXattr {}
impl&lt;T: FsFuse + FsHandles + FsLock + FsXattr&gt; FsPosix for T {}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="when-to-use-each-level"><a class="header" href="#when-to-use-each-level">When to Use Each Level</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Trait</th><th>Use When</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>Fs</code></td><td>Basic file operations (read, write, dirs)</td></tr>
<tr><td>2</td><td><code>FsFull</code></td><td>Need links, permissions, sync, or stats</td></tr>
<tr><td>3</td><td><code>FsFuse</code></td><td>FUSE mounting or hardlink support</td></tr>
<tr><td>4</td><td><code>FsPosix</code></td><td>Full POSIX (file handles, locks, xattr)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="implementing-functions"><a class="header" href="#implementing-functions">Implementing Functions</a></h2>
<p>Use trait bounds to specify requirements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::FileStorage;

// Works with any backend, keeps std::fs-style paths
fn process_files&lt;B: Fs&gt;(fs: &amp;FileStorage&lt;B&gt;) -&gt; Result&lt;(), FsError&gt; {
    let data = fs.read("/input.txt")?;
    fs.write("/output.txt", &amp;data)?;
    Ok(())
}

// Requires link support
fn create_backup&lt;B: Fs + FsLink&gt;(fs: &amp;FileStorage&lt;B&gt;) -&gt; Result&lt;(), FsError&gt; {
    fs.hard_link("/data.txt", "/data.txt.bak")?;
    Ok(())
}

// Requires FsFuse trait + fuse/winfsp feature
fn mount_filesystem(fs: impl FsFuse) -&gt; Result&lt;(), FsError&gt; {
    anyfs::MountHandle::mount(fs, "/mnt/myfs")?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="extension-trait"><a class="header" href="#extension-trait">Extension Trait</a></h2>
<p><code>FsExt</code> provides convenience methods for any <code>Fs</code> backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsExt: Fs {
    /// Check if path is a file.
    fn is_file(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;

    /// Check if path is a directory.
    fn is_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, FsError&gt;;

    /// JSON methods (require optional `serde` feature in anyfs-backend)
    #[cfg(feature = "serde")]
    fn read_json&lt;T: DeserializeOwned&gt;(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;T, FsError&gt;;
    #[cfg(feature = "serde")]
    fn write_json&lt;T: Serialize&gt;(&amp;self, path: impl AsRef&lt;Path&gt;, value: &amp;T) -&gt; Result&lt;(), FsError&gt;;
}

// Blanket implementation
impl&lt;B: Fs&gt; FsExt for B {}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="filestorageb-r-m-anyfs"><a class="header" href="#filestorageb-r-m-anyfs">FileStorage&lt;B, R, M&gt; (anyfs)</a></h1>
<p><strong>Zero-cost ergonomic wrapper for std::fs-aligned API</strong></p>
<hr>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p><code>FileStorage&lt;B, R, M&gt;</code> is a <strong>thin wrapper</strong> that provides a familiar std::fs-aligned API with:</p>
<ul>
<li><strong><code>B</code></strong> - Backend type (generic, zero-cost)</li>
<li><strong><code>R</code></strong> - PathResolver type (default: <code>IterativeResolver</code>, zero-cost)</li>
<li><strong><code>M</code></strong> - Optional marker type for compile-time safety</li>
</ul>
<p>It is the intended application-facing API: std::fs-style paths with object-safe core traits under the hood.</p>
<p><strong>Axum-style design:</strong> Zero-cost by default, type erasure opt-in.</p>
<p><strong>It does THREE things:</strong></p>
<ol>
<li>Ergonomics (std::fs-aligned API)</li>
<li>Optional type-safety via marker types</li>
<li>Pluggable path resolution for virtual backends (via <code>PathResolver</code> trait - see ADR-033)</li>
</ol>
<p>All policy (limits, feature gates, logging) is handled by middleware, not FileStorage.</p>
<hr>
<h2 id="creating-a-container"><a class="header" href="#creating-a-container">Creating a Container</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FileStorage};

// Simple: ergonomics + path resolution (type inferred)
let fs = FileStorage::new(MemoryBackend::new());
<span class="boring">}</span></code></pre>
<p>With middleware (layer-based):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, FileStorage};

// Type is inferred - no need to write it out
let fs = FileStorage::new(
    SqliteBackend::open("data.db")?
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .build())
        .layer(RestrictionsLayer::builder()
            .deny_permissions()
            .build())
);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="marker-types-compile-time-safety"><a class="header" href="#marker-types-compile-time-safety">Marker Types (Compile-Time Safety)</a></h2>
<p>Use <code>_</code> to infer the backend type while specifying the marker:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, FileStorage};

// Define marker types for your domains
struct Sandbox;
struct UserData;

// Specify marker in type annotation, infer backend and resolver with _
let sandbox: FileStorage&lt;_, _, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
let userdata: FileStorage&lt;_, _, UserData&gt; = FileStorage::new(SqliteBackend::open("data.db")?);

// Type-safe function signatures prevent mixing containers
fn process_sandbox(fs: &amp;FileStorage&lt;impl Fs, IterativeResolver, Sandbox&gt;) {
    // Can only accept Sandbox-marked containers
}

fn save_user_file(fs: &amp;FileStorage&lt;impl Fs, IterativeResolver, UserData&gt;, name: &amp;str, data: &amp;[u8]) {
    // Can only accept UserData-marked containers
}

// Compile-time safety:
process_sandbox(&amp;sandbox);   // OK
process_sandbox(&amp;userdata);  // Compile error! Type mismatch
<span class="boring">}</span></code></pre>
<h3 id="self-documenting-types-1"><a class="header" href="#self-documenting-types-1">Self-Documenting Types</a></h3>
<p>Both dimensions are meaningful:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FileStorage&lt;SqliteBackend, IterativeResolver, TenantA&gt;   // SQLite storage for TenantA
FileStorage&lt;MemoryBackend, IterativeResolver, Sandbox&gt;   // In-memory sandbox
FileStorage&lt;StdFsBackend, IterativeResolver, Production&gt; // Real filesystem, production
<span class="boring">}</span></code></pre>
<h3 id="type-aliases-for-clean-code-1"><a class="header" href="#type-aliases-for-clean-code-1">Type Aliases for Clean Code</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define your standard secure stack
type SecureBackend = Tracing&lt;Restrictions&lt;Quota&lt;SqliteBackend&gt;&gt;&gt;;

// Type aliases for common combinations
type SandboxFs = FileStorage&lt;MemoryBackend, IterativeResolver, Sandbox&gt;;
type UserDataFs = FileStorage&lt;SecureBackend, IterativeResolver, UserData&gt;;
type TenantFs&lt;T&gt; = FileStorage&lt;SecureBackend, IterativeResolver, T&gt;;

// Now signatures are clean AND informative
fn run_agent(fs: &amp;SandboxFs) { ... }
fn save_document(fs: &amp;UserDataFs, doc: &amp;Document) { ... }
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-markers"><a class="header" href="#when-to-use-markers">When to Use Markers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Use Markers?</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>Single container</td><td>No</td><td><code>FileStorage&lt;B&gt;</code> is sufficient</td></tr>
<tr><td>Multiple containers, same type</td><td><strong>Yes</strong></td><td>Prevent accidental mixing</td></tr>
<tr><td>Multi-tenant systems</td><td><strong>Yes</strong></td><td>Compile-time tenant isolation</td></tr>
<tr><td>Sandbox + user data</td><td><strong>Yes</strong></td><td>Never write user data to sandbox</td></tr>
<tr><td>Testing</td><td>Maybe</td><td>Tag test vs production containers</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="stdfs-aligned-methods"><a class="header" href="#stdfs-aligned-methods">std::fs-aligned Methods</a></h2>
<p>FileStorage mirrors std::fs naming:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FileStorage</th><th>std::fs</th></tr>
</thead>
<tbody>
<tr><td><code>read()</code></td><td><code>std::fs::read</code></td></tr>
<tr><td><code>read_to_string()</code></td><td><code>std::fs::read_to_string</code></td></tr>
<tr><td><code>write()</code></td><td><code>std::fs::write</code></td></tr>
<tr><td><code>read_dir()</code></td><td><code>std::fs::read_dir</code></td></tr>
<tr><td><code>create_dir()</code></td><td><code>std::fs::create_dir</code></td></tr>
<tr><td><code>create_dir_all()</code></td><td><code>std::fs::create_dir_all</code></td></tr>
<tr><td><code>remove_file()</code></td><td><code>std::fs::remove_file</code></td></tr>
<tr><td><code>remove_dir()</code></td><td><code>std::fs::remove_dir</code></td></tr>
<tr><td><code>remove_dir_all()</code></td><td><code>std::fs::remove_dir_all</code></td></tr>
<tr><td><code>rename()</code></td><td><code>std::fs::rename</code></td></tr>
<tr><td><code>copy()</code></td><td><code>std::fs::copy</code></td></tr>
<tr><td><code>metadata()</code></td><td><code>std::fs::metadata</code></td></tr>
<tr><td><code>symlink_metadata()</code></td><td><code>std::fs::symlink_metadata</code></td></tr>
<tr><td><code>read_link()</code></td><td><code>std::fs::read_link</code></td></tr>
<tr><td><code>set_permissions()</code></td><td><code>std::fs::set_permissions</code></td></tr>
</tbody>
</table>
</div>
<p>When the backend implements extended traits (e.g., <code>FsLink</code>, <code>FsInode</code>, <code>FsHandles</code>), FileStorage forwards those methods too and keeps the same <code>impl AsRef&lt;Path&gt;</code> ergonomics for path parameters.</p>
<hr>
<h2 id="what-filestorage-does-not-do"><a class="header" href="#what-filestorage-does-not-do">What FileStorage Does NOT Do</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Use Instead</th></tr>
</thead>
<tbody>
<tr><td>Quota enforcement</td><td><code>Quota&lt;B&gt;</code></td></tr>
<tr><td>Feature gating</td><td><code>Restrictions&lt;B&gt;</code></td></tr>
<tr><td>Audit logging</td><td><code>Tracing&lt;B&gt;</code></td></tr>
<tr><td>Path containment</td><td>PathFilter middleware or VRootFsBackend containment</td></tr>
</tbody>
</table>
</div>
<p>FileStorage is <strong>not a policy layer</strong>. If you need policy, compose middleware.</p>
<p>It is also the <strong>ergonomic path layer</strong>: its methods accept <code>impl AsRef&lt;Path&gt;</code> and forward to the core object-safe traits that take <code>&amp;Path</code>.</p>
<p>For virtual backends, FileStorage performs symlink-aware path resolution before delegating so normalization is consistent across backends. Backends that wrap a real filesystem (e.g., <code>VRootFsBackend</code>) implement <code>SelfResolving</code> to skip this resolution and let the OS handle it (with strict containment on that backend).</p>
<hr>
<h2 id="filestorage-implementation-1"><a class="header" href="#filestorage-implementation-1">FileStorage Implementation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;
use anyfs_backend::{Fs, PathResolver};
use anyfs::resolvers::IterativeResolver;

/// Zero-cost ergonomic wrapper.
/// Generic over backend (B), resolver (R), and marker (M).
pub struct FileStorage&lt;B, R = IterativeResolver, M = ()&gt; {
    backend: B,
    resolver: R,
    _marker: PhantomData&lt;M&gt;,
}

impl&lt;B: Fs, M&gt; FileStorage&lt;B, IterativeResolver, M&gt; {
    /// Create a new FileStorage with default resolver (IterativeResolver).
    /// Marker type is specified via type annotation:
    /// `let fs: FileStorage&lt;_, _, MyMarker&gt; = FileStorage::new(backend);`
    pub fn new(backend: B) -&gt; Self {
        FileStorage {
            backend,
            resolver: IterativeResolver::new(),
            _marker: PhantomData,
        }
    }
}

impl&lt;B: Fs, R: PathResolver, M&gt; FileStorage&lt;B, R, M&gt; {
    /// Create FileStorage with a custom path resolver.
    /// See ADR-033 for PathResolver trait details.
    pub fn with_resolver(backend: B, resolver: R) -&gt; Self {
        FileStorage {
            backend,
            resolver,
            _marker: PhantomData,
        }
    }

    /// Type-erase the backend for simpler types (opt-in boxing).
    /// Note: resolver type is preserved (no boxing).
    pub fn boxed(self) -&gt; FileStorage&lt;Box&lt;dyn Fs&gt;, R, M&gt; {
        FileStorage {
            backend: Box::new(self.backend),
            resolver: self.resolver,
            _marker: PhantomData,
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="path-resolution-1"><a class="header" href="#path-resolution-1">Path Resolution</a></h3>
<p>FileStorage handles path resolution for virtual backends via the <code>PathResolver</code> trait (see ADR-033). The default <code>IterativeResolver</code> provides symlink-aware canonicalization.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{FileStorage, MemoryBackend};
use anyfs::resolvers::{IterativeResolver, CachingResolver};

// Default: uses IterativeResolver (zero-cost, likely ZST)
let fs = FileStorage::new(MemoryBackend::new());

// Custom: with caching resolver for read-heavy workloads
let fs = FileStorage::with_resolver(
    MemoryBackend::new(),
    CachingResolver::new(IterativeResolver::default())
);
<span class="boring">}</span></code></pre>
<p>Backends implementing <code>SelfResolving</code> (like <code>VRootFsBackend</code>) skip resolution since the OS handles it.</p>
<hr>
<h2 id="type-erasure-opt-in-1"><a class="header" href="#type-erasure-opt-in-1">Type Erasure (Opt-in)</a></h2>
<p>When you need simpler types (e.g., storing in collections), use <code>.boxed()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend, FileStorage, Fs};

// Type-erased for uniform storage
let filesystems: Vec&lt;FileStorage&lt;Box&lt;dyn Fs&gt;&gt;&gt; = vec![
    FileStorage::new(MemoryBackend::new()).boxed(),
    FileStorage::new(SqliteBackend::open("a.db")?).boxed(),
    FileStorage::new(SqliteBackend::open("b.db")?).boxed(),
];

// Or use type alias
type DynFileStorage&lt;R = IterativeResolver, M = ()&gt; = FileStorage&lt;Box&lt;dyn Fs&gt;, R, M&gt;;
<span class="boring">}</span></code></pre>
<p><strong>When to use <code>.boxed()</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Situation</th><th>Use Generic</th><th>Use <code>.boxed()</code></th></tr>
</thead>
<tbody>
<tr><td>Local variables</td><td>Yes</td><td>No</td></tr>
<tr><td>Function params</td><td>Yes (<code>impl Fs</code>)</td><td>No</td></tr>
<tr><td>Return types</td><td>Yes (<code>impl Fs</code>)</td><td>No</td></tr>
<tr><td>Collections of mixed backends</td><td>No</td><td><strong>Yes</strong></td></tr>
<tr><td>Struct fields (want simple type)</td><td>Maybe</td><td><strong>Yes</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="direct-backend-access"><a class="header" href="#direct-backend-access">Direct Backend Access</a></h2>
<p>If you don’t need the wrapper, use backends directly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, FileStorage};

let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build());

// Use FileStorage for std::fs-style paths
let fs = FileStorage::new(backend);
fs.write("/file.txt", b"data")?;
<span class="boring">}</span></code></pre>
<p><code>FileStorage&lt;B, R, M&gt;</code> is part of the <code>anyfs</code> crate, not a separate crate.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="built-in-backends-guide"><a class="header" href="#built-in-backends-guide">Built-in Backends Guide</a></h1>
<p>This guide explains each built-in backend in AnyFS, how it works internally, when to use it, and the trade-offs involved.</p>
<hr>
<h2 id="quick-reference-which-backend-should-you-use"><a class="header" href="#quick-reference-which-backend-should-you-use">Quick Reference: Which Backend Should You Use?</a></h2>
<blockquote>
<p><strong>TL;DR</strong> — Pick the first match from top to bottom:</p>
</blockquote>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Your Situation</th><th>Best Choice</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>Writing tests</td><td><strong>MemoryBackend</strong></td><td>Fast, isolated, no cleanup</td></tr>
<tr><td>Running in WASM/browser</td><td><strong>MemoryBackend</strong></td><td>Simplest; SqliteBackend also works</td></tr>
<tr><td>Need encrypted single-file storage</td><td><strong>SqliteCipherBackend</strong></td><td>AES-256, portable</td></tr>
<tr><td>Need portable single-file database</td><td><strong>SqliteBackend</strong></td><td>Cross-platform, ACID</td></tr>
<tr><td>Large files (&gt;100MB) with path isolation</td><td><strong>IndexedBackend</strong></td><td>Virtual paths + native disk I/O</td></tr>
<tr><td>Containing untrusted code to a directory</td><td><strong>VRootFsBackend</strong></td><td>Prevents path traversal attacks</td></tr>
<tr><td>Working with real files in trusted environment</td><td><strong>StdFsBackend</strong></td><td>Direct OS operations</td></tr>
<tr><td>Need layered filesystem (container-like)</td><td><strong>Overlay</strong> (middleware)</td><td>Base + writable upper layer</td></tr>
</tbody>
</table>
</div>
<p>⚠️ <strong>Security Warning:</strong> <code>StdFsBackend</code> provides <strong>NO isolation</strong>. Never use with untrusted input.</p>
<hr>
<h2 id="backend-categories"><a class="header" href="#backend-categories">Backend Categories</a></h2>
<p>AnyFS backends fall into two fundamental categories based on <strong>who resolves paths</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Path Resolution</th><th>Symlink Handling</th><th>Isolation</th></tr>
</thead>
<tbody>
<tr><td><strong>Type 1: Virtual Filesystem</strong></td><td>PathResolver (pluggable)</td><td>Simulated by AnyFS</td><td>Complete</td></tr>
<tr><td><strong>Type 2: Real Filesystem</strong></td><td>Operating System</td><td>Delegated to OS</td><td>Partial/None</td></tr>
</tbody>
</table>
</div>
<h3 id="type-1-virtual-filesystem-backends"><a class="header" href="#type-1-virtual-filesystem-backends">Type 1: Virtual Filesystem Backends</a></h3>
<p>These backends store filesystem data in an abstract format (memory, database, etc.). <strong>AnyFS handles path resolution via pluggable <code>PathResolver</code></strong> (see ADR-033), including:</p>
<ul>
<li>Path traversal (<code>..</code>, <code>.</code>)</li>
<li>Symlink following (simulated)</li>
<li>Hard link tracking (simulated)</li>
<li>Path normalization</li>
</ul>
<p><strong>Key benefit:</strong> Complete isolation from the host OS. Identical behavior across all platforms.</p>
<h3 id="type-2-real-filesystem-backends"><a class="header" href="#type-2-real-filesystem-backends">Type 2: Real Filesystem Backends</a></h3>
<p>These backends delegate operations to the actual operating system. <strong>The OS handles path resolution</strong>, which means:</p>
<ul>
<li>Native symlink behavior</li>
<li>Native permission enforcement</li>
<li>Platform-specific edge cases</li>
<li>Potential security considerations (path escapes)</li>
</ul>
<p><strong>Key benefit:</strong> Native performance and compatibility with existing files.</p>
<hr>
<h2 id="type-1-virtual-filesystem-backends-1"><a class="header" href="#type-1-virtual-filesystem-backends-1">Type 1: Virtual Filesystem Backends</a></h2>
<h3 id="memorybackend"><a class="header" href="#memorybackend">MemoryBackend</a></h3>
<p>An in-memory filesystem. All data lives in RAM and is lost when the process exits.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, FileStorage};

let fs = FileStorage::new(MemoryBackend::new());
fs.write("/data.txt", b"Hello, World!")?;
<span class="boring">}</span></code></pre>
<h4 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h4>
<ul>
<li>Files and directories stored in a tree structure (<code>HashMap</code> or similar)</li>
<li>Symlinks stored as data pointing to target paths</li>
<li>Hard links share the same underlying data node</li>
<li>All operations are memory-only (no disk I/O)</li>
<li>Supports snapshots via <code>Clone</code> and persistence via <code>save_to()</code>/<code>load_from()</code></li>
</ul>
<h4 id="performance"><a class="header" href="#performance">Performance</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Speed</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Read/Write</td><td>⚡ <strong>Very Fast</strong></td><td>No I/O, pure memory operations</td></tr>
<tr><td>Path Resolution</td><td>⚡ <strong>Very Fast</strong></td><td>In-memory tree traversal</td></tr>
<tr><td>Large Files</td><td>⚠️ <strong>Memory-bound</strong></td><td>Limited by available RAM</td></tr>
</tbody>
</table>
</div>
<h4 id="advantages"><a class="header" href="#advantages">Advantages</a></h4>
<ul>
<li><strong>Fastest backend</strong> - no disk I/O overhead</li>
<li><strong>Deterministic</strong> - perfect for testing</li>
<li><strong>Portable</strong> - works on all platforms including WASM</li>
<li><strong>Snapshots</strong> - <code>Clone</code> creates instant backups</li>
<li><strong>No cleanup</strong> - no temp files to delete</li>
</ul>
<h4 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h4>
<ul>
<li><strong>Volatile</strong> - data lost on process exit (unless serialized)</li>
<li><strong>Memory-limited</strong> - large filesystems consume RAM</li>
<li><strong>No persistence</strong> - must explicitly save/load state</li>
</ul>
<h4 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Unit tests</td><td>✅ <strong>Ideal</strong> - fast, isolated, deterministic</td></tr>
<tr><td>Integration tests</td><td>✅ <strong>Ideal</strong> - no filesystem pollution</td></tr>
<tr><td>Temporary workspaces</td><td>✅ <strong>Good</strong> - fast scratch space</td></tr>
<tr><td>Build caches</td><td>✅ <strong>Good</strong> - if fits in memory</td></tr>
<tr><td>WASM/Browser</td><td>✅ <strong>Ideal</strong> - simplest option (SqliteBackend also works)</td></tr>
<tr><td>Large file storage</td><td>❌ <strong>Avoid</strong> - use SqliteBackend or disk</td></tr>
<tr><td>Persistent data</td><td>❌ <strong>Avoid</strong> - unless you handle serialization</td></tr>
</tbody>
</table>
</div>
<p><strong>✅ USE MemoryBackend when:</strong></p>
<ul>
<li>Writing unit tests (fast, isolated, deterministic)</li>
<li>Writing integration tests (no filesystem pollution)</li>
<li>Building temporary workspaces or scratch space</li>
<li>Caching data that fits in memory</li>
<li>Running in WASM/browser environments (simplest option)</li>
<li>Need instant snapshots via <code>Clone</code></li>
</ul>
<p><strong>❌ DON’T USE MemoryBackend when:</strong></p>
<ul>
<li>Storing files larger than available RAM</li>
<li>Data must survive process restart (use SqliteBackend)</li>
<li>Working with existing files on disk (use VRootFsBackend)</li>
</ul>
<hr>
<h3 id="sqlitebackend"><a class="header" href="#sqlitebackend">SqliteBackend</a></h3>
<p>Stores the entire filesystem in a single SQLite database file.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, FileStorage};

let fs = FileStorage::new(SqliteBackend::open("myfs.db")?);
fs.write("/documents/report.txt", b"Annual Report")?;
<span class="boring">}</span></code></pre>
<h4 id="how-it-works-1-1"><a class="header" href="#how-it-works-1-1">How It Works</a></h4>
<ul>
<li>Single <code>.db</code> file contains all files, directories, and metadata</li>
<li>Schema: <code>nodes</code> table (path, type, content, permissions, timestamps)</li>
<li>Symlinks stored as rows with target path in content</li>
<li>Hard links share the same <code>inode</code> (row ID)</li>
<li>Uses WAL mode for concurrent read access</li>
<li>Transactions ensure atomic operations</li>
</ul>
<h4 id="performance-1"><a class="header" href="#performance-1">Performance</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Speed</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Read/Write</td><td>🐢 <strong>Slower</strong></td><td>SQLite query overhead</td></tr>
<tr><td>Path Resolution</td><td>🐢 <strong>Slower</strong></td><td>Database lookups per component</td></tr>
<tr><td>Transactions</td><td>✅ <strong>Atomic</strong></td><td>ACID guarantees</td></tr>
<tr><td>Large Files</td><td>✅ <strong>Good</strong></td><td>Streams to disk, not RAM</td></tr>
</tbody>
</table>
</div>
<h4 id="advantages-1"><a class="header" href="#advantages-1">Advantages</a></h4>
<ul>
<li><strong>Single-file portability</strong> - entire filesystem in one <code>.db</code> file</li>
<li><strong>ACID transactions</strong> - atomic operations, crash recovery</li>
<li><strong>Cross-platform</strong> - works on all platforms including WASM</li>
<li><strong>Complete isolation</strong> - no interaction with host filesystem</li>
<li><strong>Queryable</strong> - can inspect with SQLite tools</li>
<li><strong>Encryption available</strong> - via <code>SqliteCipherBackend</code></li>
</ul>
<h4 id="disadvantages-1"><a class="header" href="#disadvantages-1">Disadvantages</a></h4>
<ul>
<li><strong>Slower than memory</strong> - database overhead on every operation</li>
<li><strong>Single-writer</strong> - SQLite’s write lock limits concurrency</li>
<li><strong>Large file tradeoffs</strong> - files &gt;100MB stored as BLOBs have higher memory pressure during operations</li>
</ul>
<h4 id="when-to-use-1"><a class="header" href="#when-to-use-1">When to Use</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Portable storage</td><td>✅ <strong>Ideal</strong> - single file, works everywhere</td></tr>
<tr><td>Embedded databases</td><td>✅ <strong>Ideal</strong> - self-contained</td></tr>
<tr><td>Sandboxed environments</td><td>✅ <strong>Good</strong> - complete isolation</td></tr>
<tr><td>Encrypted storage</td><td>✅ <strong>Good</strong> - use SqliteCipherBackend</td></tr>
<tr><td>Archive/backup</td><td>✅ <strong>Good</strong> - atomic, portable</td></tr>
<tr><td>Large media files</td><td>✅ <strong>Works</strong> - higher memory pressure during I/O</td></tr>
<tr><td>High-throughput I/O</td><td>⚠️ <strong>Tradeoff</strong> - database overhead vs MemoryBackend</td></tr>
<tr><td>External tool access</td><td>❌ <strong>Avoid</strong> - files not on real filesystem</td></tr>
</tbody>
</table>
</div>
<p><strong>✅ USE SqliteBackend when:</strong></p>
<ul>
<li>Need portable, single-file storage (easy to copy, backup, share)</li>
<li>Building embedded/self-contained applications</li>
<li>Complete isolation from host filesystem is required</li>
<li>Want encryption (use SqliteCipherBackend)</li>
<li>Need ACID transactions and crash recovery</li>
<li>Cross-platform consistency is critical</li>
</ul>
<p><strong>❌ DON’T USE SqliteBackend when:</strong></p>
<ul>
<li>Files must be accessible to external tools (use VRootFsBackend)</li>
<li>Minimizing memory pressure for very large files is critical (use IndexedBackend)</li>
</ul>
<hr>
<h3 id="indexedbackend"><a class="header" href="#indexedbackend">IndexedBackend</a></h3>
<p>A hybrid backend: <strong>virtual paths</strong> with <strong>disk-based content storage</strong>. Paths, directories, symlinks, and metadata are stored in an index database. File content is stored on the real filesystem as opaque blobs.</p>
<blockquote>
<p><strong>Feature:</strong> <code>indexed</code></p>
<p><strong>Key insight:</strong> Same isolation model as SqliteBackend, but file content stored externally for native I/O performance with large files.</p>
</blockquote>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{IndexedBackend, FileStorage};

// Files stored in ./storage/, index in ./storage/index.db
let fs = FileStorage::new(IndexedBackend::open("./storage")?);
fs.write("/documents/report.pdf", &amp;pdf_bytes)?;
// Actually stored as: ./storage/a1b2c3d4-5678-...-1704067200.bin
<span class="boring">}</span></code></pre>
<h4 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h4>
<pre><code>Virtual Path                    Real Storage
─────────────────────────────────────────────────────
/documents/report.pdf    →    ./storage/blobs/a1b2c3d4-...-1704067200.bin
/images/photo.jpg        →    ./storage/blobs/b2c3d4e5-...-1704067201.bin
/config.json             →    ./storage/blobs/c3d4e5f6-...-1704067202.bin

index.db contains:
┌─────────────────────────┬──────────────────────────────┬──────────┐
│ virtual_path            │ blob_name                    │ metadata │
├─────────────────────────┼──────────────────────────────┼──────────┤
│ /documents/report.pdf   │ a1b2c3d4-...-1704067200.bin  │ {...}    │
│ /images/photo.jpg       │ b2c3d4e5-...-1704067201.bin  │ {...}    │
└─────────────────────────┴──────────────────────────────┴──────────┘
</code></pre>
<ul>
<li><strong>Virtual filesystem, real content:</strong> Directory structure, paths, symlinks, and metadata are virtual (stored in <code>index.db</code>). Only raw file content lives on disk as opaque blobs.</li>
<li>Files stored with UUID + timestamp names (flat, meaningless filenames)</li>
<li><code>index.db</code> SQLite database maps virtual paths to blob names</li>
<li>Symlinks and hard links are simulated in the index (not OS symlinks)</li>
<li>Path resolution handled by AnyFS framework (Type 1 backend)</li>
<li>File content streamed directly from disk (native I/O performance)</li>
</ul>
<h4 id="performance-2"><a class="header" href="#performance-2">Performance</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Speed</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Read/Write</td><td>🟢 <strong>Fast</strong></td><td>Native disk I/O for content</td></tr>
<tr><td>Path Resolution</td><td>🟡 <strong>Moderate</strong></td><td>Index lookup + disk access</td></tr>
<tr><td>Large Files</td><td>✅ <strong>Excellent</strong></td><td>Streamed directly from disk</td></tr>
<tr><td>Metadata Ops</td><td>🟢 <strong>Fast</strong></td><td>Index-only, no disk I/O</td></tr>
</tbody>
</table>
</div>
<h4 id="advantages-2"><a class="header" href="#advantages-2">Advantages</a></h4>
<ul>
<li><strong>Native file I/O</strong> - content stored as raw files, fast streaming</li>
<li><strong>Large file support</strong> - no memory constraints, unlike SqliteBackend BLOBs</li>
<li><strong>Complete path isolation</strong> - virtual paths, same as SqliteBackend</li>
<li><strong>Inspectable</strong> - can see blob files on disk (though with opaque names)</li>
<li><strong>Cross-platform</strong> - works identically on all platforms</li>
</ul>
<h4 id="disadvantages-2"><a class="header" href="#disadvantages-2">Disadvantages</a></h4>
<ul>
<li><strong>Index dependency</strong> - losing <code>index.db</code> = losing virtual structure (blobs become orphaned)</li>
<li><strong>Two-component backup</strong> - must copy directory + index.db together</li>
<li><strong>Content exposure</strong> - blob files are readable on disk (paths are hidden, content is not)</li>
<li><strong>Not single-file portable</strong> - unlike SqliteBackend</li>
</ul>
<h4 id="when-to-use-2"><a class="header" href="#when-to-use-2">When to Use</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Large file storage</td><td>✅ <strong>Ideal</strong> - native I/O performance</td></tr>
<tr><td>Media libraries</td><td>✅ <strong>Ideal</strong> - stream large videos/images</td></tr>
<tr><td>Document management</td><td>✅ <strong>Good</strong> - virtual paths + fast I/O</td></tr>
<tr><td>Sandboxed + large files</td><td>✅ <strong>Ideal</strong> - virtual paths, real I/O</td></tr>
<tr><td>Single-file portability</td><td>❌ <strong>Avoid</strong> - use SqliteBackend</td></tr>
<tr><td>Content confidentiality</td><td>⚠️ <strong>Wrap</strong> - use Encryption middleware for protection</td></tr>
<tr><td>WASM/Browser</td><td>❌ <strong>Avoid</strong> - requires real filesystem</td></tr>
</tbody>
</table>
</div>
<p><strong>✅ USE IndexedBackend when:</strong></p>
<ul>
<li>Storing large files (videos, images, documents &gt;100MB)</li>
<li>Need native I/O performance for streaming content</li>
<li>Building media libraries or document management systems</li>
<li>Want virtual path isolation but with real disk performance</li>
<li>Files are large but path structure should be sandboxed</li>
</ul>
<p><strong>❌ DON’T USE IndexedBackend when:</strong></p>
<ul>
<li>Need single-file portability (use SqliteBackend)</li>
<li>Content must be hidden from host filesystem (use SqliteBackend or SqliteCipherBackend)</li>
<li>Need WASM/browser support (use MemoryBackend or SqliteBackend)</li>
</ul>
<blockquote>
<p>🔒 <strong>Encryption Tip:</strong> If you need large file performance but content confidentiality matters, wrap IndexedBackend with <code>Encryption&lt;B&gt;</code> middleware to encrypt blob contents at rest. This protects data while preserving native I/O streaming.</p>
</blockquote>
<hr>
<h2 id="type-2-real-filesystem-backends-1"><a class="header" href="#type-2-real-filesystem-backends-1">Type 2: Real Filesystem Backends</a></h2>
<h3 id="stdfsbackend"><a class="header" href="#stdfsbackend">StdFsBackend</a></h3>
<p>Direct delegation to <code>std::fs</code>. Every call maps 1:1 to the standard library.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{StdFsBackend, FileStorage};

let fs = FileStorage::new(StdFsBackend::new());
fs.write("/tmp/data.txt", b"Hello")?; // Actually writes to /tmp/data.txt
<span class="boring">}</span></code></pre>
<h4 id="how-it-works-3"><a class="header" href="#how-it-works-3">How It Works</a></h4>
<ul>
<li>Every method directly calls the equivalent <code>std::fs</code> function</li>
<li>Paths passed through unchanged</li>
<li>OS handles all resolution, symlinks, permissions</li>
<li>Implements <code>SelfResolving</code> marker (FileStorage skips virtual resolution)</li>
</ul>
<h4 id="performance-3"><a class="header" href="#performance-3">Performance</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Speed</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Read/Write</td><td>🟢 <strong>Normal</strong></td><td>Native OS speed</td></tr>
<tr><td>Path Resolution</td><td>⚡ <strong>Fast</strong></td><td>OS kernel handles it</td></tr>
<tr><td>Symlinks</td><td>✅ <strong>Native</strong></td><td>OS behavior</td></tr>
</tbody>
</table>
</div>
<h4 id="advantages-3"><a class="header" href="#advantages-3">Advantages</a></h4>
<ul>
<li><strong>Zero overhead</strong> - direct OS calls</li>
<li><strong>Full compatibility</strong> - works with all existing files</li>
<li><strong>Native features</strong> - OS permissions, ACLs, xattrs</li>
<li><strong>Middleware-ready</strong> - add Quota, Tracing, etc. to real filesystem</li>
</ul>
<h4 id="disadvantages-3"><a class="header" href="#disadvantages-3">Disadvantages</a></h4>
<ul>
<li><strong>No isolation</strong> - full filesystem access</li>
<li><strong>No containment</strong> - paths can escape anywhere</li>
<li><strong>Platform differences</strong> - Windows vs Unix behavior</li>
<li><strong>Security risk</strong> - must trust path inputs</li>
</ul>
<h4 id="when-to-use-3"><a class="header" href="#when-to-use-3">When to Use</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Adding middleware to real FS</td><td>✅ <strong>Ideal</strong> - wrap with Quota, Tracing</td></tr>
<tr><td>Trusted environments</td><td>✅ <strong>Good</strong> - when isolation not needed</td></tr>
<tr><td>Migration path</td><td>✅ <strong>Good</strong> - gradually add AnyFS features</td></tr>
<tr><td>Full host FS features</td><td>✅ <strong>Good</strong> - ACLs, xattrs, etc.</td></tr>
<tr><td>Untrusted input</td><td>❌ <strong>Never</strong> - use VRootFsBackend</td></tr>
<tr><td>Sandboxing</td><td>❌ <strong>Never</strong> - no containment whatsoever</td></tr>
<tr><td>Multi-tenant systems</td><td>❌ <strong>Avoid</strong> - use virtual backends</td></tr>
</tbody>
</table>
</div>
<p><strong>✅ USE StdFsBackend when:</strong></p>
<ul>
<li>Adding middleware (Quota, Tracing, etc.) to real filesystem operations</li>
<li>Operating in a fully trusted environment with controlled inputs</li>
<li>Migrating existing code to AnyFS incrementally</li>
<li>Need full access to host filesystem features (ACLs, xattrs)</li>
<li>Building tools that work with user’s actual files</li>
</ul>
<p><strong>❌ DON’T USE StdFsBackend when:</strong></p>
<ul>
<li>Handling untrusted path inputs (use VRootFsBackend)</li>
<li>Any form of sandboxing is required (no containment!)</li>
<li>Building multi-tenant systems (use virtual backends)</li>
<li>Security isolation matters at all</li>
</ul>
<blockquote>
<p>⚠️ <strong>Security Warning:</strong> StdFsBackend provides <strong>ZERO isolation</strong>. Paths like <code>../../etc/passwd</code> will work. Only use with fully trusted, controlled inputs.</p>
</blockquote>
<hr>
<h3 id="vrootfsbackend"><a class="header" href="#vrootfsbackend">VRootFsBackend</a></h3>
<p>Sets a directory as a virtual root. All operations are contained within it.</p>
<blockquote>
<p><strong>Feature:</strong> <code>vrootfs</code></p>
</blockquote>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{VRootFsBackend, FileStorage};

// /home/user/sandbox becomes the virtual "/"
let fs = FileStorage::new(VRootFsBackend::new("/home/user/sandbox")?);

fs.write("/data.txt", b"Hello")?; 
// Actually writes to: /home/user/sandbox/data.txt

fs.read("/../../../etc/passwd")?;
// Resolves to: /home/user/sandbox/etc/passwd (clamped!)
<span class="boring">}</span></code></pre>
<h4 id="how-it-works-4"><a class="header" href="#how-it-works-4">How It Works</a></h4>
<ul>
<li>Configured with a real directory as the “virtual root”</li>
<li>All paths are validated and clamped to stay within root</li>
<li>Uses <code>strict-path</code> crate for escape prevention</li>
<li>Symlinks are followed but targets validated</li>
<li>Implements <code>SelfResolving</code> marker (OS handles resolution after validation)</li>
</ul>
<pre><code>Virtual Path          Validation              Real Path
───────────────────────────────────────────────────────────────
/data.txt        →   validate &amp; join    →   /home/user/sandbox/data.txt
/../../../etc    →   clamp to root      →   /home/user/sandbox/etc
/link → /tmp     →   validate target    →   ERROR or clamped
</code></pre>
<h4 id="performance-4"><a class="header" href="#performance-4">Performance</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Speed</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Read/Write</td><td>🟡 <strong>Moderate</strong></td><td>Validation overhead</td></tr>
<tr><td>Path Resolution</td><td>🐢 <strong>Slower</strong></td><td>Extra I/O for symlink checks</td></tr>
<tr><td>Symlink Following</td><td>🐢 <strong>Slower</strong></td><td>Must validate each hop</td></tr>
</tbody>
</table>
</div>
<h4 id="advantages-4"><a class="header" href="#advantages-4">Advantages</a></h4>
<ul>
<li><strong>Path containment</strong> - cannot escape virtual root</li>
<li><strong>Real file access</strong> - native OS performance for content</li>
<li><strong>Symlink safety</strong> - targets validated against root</li>
<li><strong>Drop-in sandboxing</strong> - wrap existing directories</li>
</ul>
<h4 id="disadvantages-4"><a class="header" href="#disadvantages-4">Disadvantages</a></h4>
<ul>
<li><strong>Performance overhead</strong> - validation on every operation</li>
<li><strong>Extra I/O</strong> - symlink following requires <code>lstat</code> calls</li>
<li><strong>Platform quirks</strong> - symlink behavior varies (especially Windows)</li>
<li><strong>Theoretical edge cases</strong> - TOCTOU races exist but are difficult to exploit</li>
</ul>
<h4 id="when-to-use-4"><a class="header" href="#when-to-use-4">When to Use</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>User uploads directory</td><td>✅ <strong>Ideal</strong> - contain user content</td></tr>
<tr><td>Plugin sandboxing</td><td>✅ <strong>Good</strong> - limit plugin file access</td></tr>
<tr><td>Chroot-like isolation</td><td>✅ <strong>Good</strong> - without actual chroot</td></tr>
<tr><td>AI agent workspaces</td><td>✅ <strong>Good</strong> - bound agent to directory</td></tr>
<tr><td>Real FS + path containment</td><td>✅ <strong>Ideal</strong> - native I/O with boundaries</td></tr>
<tr><td>Maximum security</td><td>⚠️ <strong>Careful</strong> - theoretical TOCTOU exists</td></tr>
<tr><td>Cross-platform symlinks</td><td>⚠️ <strong>Careful</strong> - Windows behavior differs</td></tr>
<tr><td>Complete host isolation</td><td>❌ <strong>Avoid</strong> - use SqliteBackend instead</td></tr>
</tbody>
</table>
</div>
<p><strong>✅ USE VRootFsBackend when:</strong></p>
<ul>
<li>Containing user-uploaded content to a specific directory</li>
<li>Sandboxing plugins, extensions, or untrusted code</li>
<li>Need chroot-like isolation without actual chroot privileges</li>
<li>Building AI agent workspaces with filesystem boundaries</li>
<li>Want real filesystem performance with path containment</li>
</ul>
<p><strong>❌ DON’T USE VRootFsBackend when:</strong></p>
<ul>
<li>Maximum security required (theoretical TOCTOU edge cases exist - use MemoryBackend)</li>
<li>Need highest I/O performance (validation adds overhead)</li>
<li>Cross-platform symlink consistency is critical (Windows differs)</li>
<li>Want complete isolation from host (use SqliteBackend)</li>
</ul>
<blockquote>
<p>🔒 <strong>Encryption Tip:</strong> For sensitive data in sandboxed directories (user uploads, plugin workspaces, AI agent data), wrap VRootFsBackend with <code>Encryption&lt;B&gt;</code> middleware. This ensures files written to the host filesystem are encrypted at rest, protecting against host-level access.</p>
</blockquote>
<hr>
<h2 id="composition-middleware"><a class="header" href="#composition-middleware">Composition Middleware</a></h2>
<h3 id="overlaybase-upper-1"><a class="header" href="#overlaybase-upper-1">Overlay&lt;Base, Upper&gt;</a></h3>
<p>Union filesystem middleware combining a read-only base with a writable upper layer.</p>
<blockquote>
<p><strong>Note:</strong> Overlay is middleware (in <code>anyfs/middleware/overlay.rs</code>), not a standalone backend. It composes two backends into a layered view.</p>
</blockquote>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, MemoryBackend, Overlay, FileStorage};

// Base: read-only template
let base = SqliteBackend::open("template.db")?;

// Upper: writable scratch layer  
let upper = MemoryBackend::new();

let fs = FileStorage::new(Overlay::new(base, upper));

// Read: checks upper first, falls back to base
let data = fs.read("/config.txt")?;

// Write: always goes to upper
fs.write("/config.txt", b"modified")?;

// Delete: creates "whiteout" in upper, shadows base
fs.remove_file("/unwanted.txt")?;
<span class="boring">}</span></code></pre>
<h4 id="how-it-works-5"><a class="header" href="#how-it-works-5">How It Works</a></h4>
<pre><code>┌─────────────────────────────────────────────────┐
│                  Overlay&lt;B, U&gt;                  │
├─────────────────────────────────────────────────┤
│  Read:   upper.exists(path)?                    │
│            → upper.read(path)                   │
│            : base.read(path)                    │
│                                                 │
│  Write:  upper.write(path, data)                │
│          (base unchanged)                       │
│                                                 │
│  Delete: upper.mark_whiteout(path)              │
│          (shadows base, doesn't delete it)      │
│                                                 │
│  List:   merge(base.read_dir(), upper.read_dir())│
│          - exclude whiteouts                    │
└─────────────────────────────────────────────────┘

         ┌──────────────┐
         │    Upper     │  ← Writes go here
         │ (MemoryFs)   │  ← Modifications stored here
         │              │  ← Whiteouts (deletions) here
         └──────┬───────┘
                │ if not found
                ▼
         ┌──────────────┐
         │     Base     │  ← Read-only layer
         │ (SqliteFs)   │  ← Original/template data
         │              │  ← Never modified
         └──────────────┘
</code></pre>
<ul>
<li><strong>Reads:</strong> Check upper layer first, fall back to base</li>
<li><strong>Writes:</strong> Always go to upper layer (base is read-only)</li>
<li><strong>Deletes:</strong> Create “whiteout” marker in upper (shadows base file)</li>
<li><strong>Directory listing:</strong> Merge both layers, exclude whiteouts</li>
</ul>
<h4 id="performance-5"><a class="header" href="#performance-5">Performance</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Speed</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Read (upper hit)</td><td>⚡ <strong>Fast</strong></td><td>Single layer lookup</td></tr>
<tr><td>Read (base fallback)</td><td>🟡 <strong>Moderate</strong></td><td>Two-layer lookup</td></tr>
<tr><td>Write</td><td>Depends on upper</td><td>Upper layer speed</td></tr>
<tr><td>Directory listing</td><td>🐢 <strong>Slower</strong></td><td>Must merge both layers</td></tr>
</tbody>
</table>
</div>
<h4 id="advantages-5"><a class="header" href="#advantages-5">Advantages</a></h4>
<ul>
<li><strong>Copy-on-write semantics</strong> - modifications don’t affect base</li>
<li><strong>Instant rollback</strong> - discard upper layer to reset</li>
<li><strong>Space efficient</strong> - only changes stored in upper</li>
<li><strong>Template pattern</strong> - share base across multiple instances</li>
<li><strong>Testing isolation</strong> - test against real data without modifying it</li>
</ul>
<h4 id="disadvantages-5"><a class="header" href="#disadvantages-5">Disadvantages</a></h4>
<ul>
<li><strong>Complexity</strong> - whiteout handling, merge logic</li>
<li><strong>Directory listing overhead</strong> - must combine and filter</li>
<li><strong>Two backends to manage</strong> - lifecycle of both layers</li>
<li><strong>Not true CoW</strong> - doesn’t deduplicate at block level</li>
</ul>
<h4 id="when-to-use-5"><a class="header" href="#when-to-use-5">When to Use</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Container images</td><td>✅ <strong>Ideal</strong> - base image + writable layer</td></tr>
<tr><td>Template filesystems</td><td>✅ <strong>Ideal</strong> - shared base, per-user upper</td></tr>
<tr><td>Testing with real data</td><td>✅ <strong>Ideal</strong> - modify without consequences</td></tr>
<tr><td>Rollback capability</td><td>✅ <strong>Good</strong> - discard upper to reset</td></tr>
<tr><td>Git-like branching</td><td>✅ <strong>Good</strong> - branch = new upper layer</td></tr>
<tr><td>Simple use cases</td><td>❌ <strong>Overkill</strong> - use single backend</td></tr>
<tr><td>Block-level CoW</td><td>❌ <strong>Avoid</strong> - Overlay is file-level</td></tr>
<tr><td>Dir listing perf</td><td>❌ <strong>Avoid</strong> - merge overhead on listings</td></tr>
</tbody>
</table>
</div>
<p><strong>✅ USE Overlay when:</strong></p>
<ul>
<li>Building container-like systems (base image + writable layer)</li>
<li>Sharing a template filesystem across multiple instances</li>
<li>Testing against production data without modifying it</li>
<li>Need instant rollback capability (discard upper layer)</li>
<li>Implementing git-like branching at filesystem level</li>
</ul>
<p><strong>❌ DON’T USE Overlay when:</strong></p>
<ul>
<li>Simple, single-purpose filesystem (unnecessary complexity)</li>
<li>Need block-level copy-on-write (Overlay is file-level)</li>
<li>Directory listing performance is critical (merge overhead)</li>
<li>Don’t need layered semantics (use single backend)</li>
</ul>
<hr>
<h2 id="backend-selection-guide"><a class="header" href="#backend-selection-guide">Backend Selection Guide</a></h2>
<h3 id="quick-decision-tree"><a class="header" href="#quick-decision-tree">Quick Decision Tree</a></h3>
<pre><code>Do you need persistence?
├─ No → MemoryBackend
└─ Yes
   ├─ Single portable file? → SqliteBackend
   ├─ Large files + path isolation? → IndexedBackend
   └─ Access existing files on disk?
      ├─ Need containment? → VRootFsBackend  
      └─ Trusted environment? → StdFsBackend
</code></pre>
<h3 id="comparison-matrix"><a class="header" href="#comparison-matrix">Comparison Matrix</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Speed</th><th>Isolation</th><th>Persistence</th><th>Large Files</th><th>WASM</th></tr>
</thead>
<tbody>
<tr><td>MemoryBackend</td><td>⚡ Very Fast</td><td>✅ Complete</td><td>❌ None</td><td>⚠️ RAM-limited</td><td>✅</td></tr>
<tr><td>SqliteBackend</td><td>🐢 Slower</td><td>✅ Complete</td><td>✅ Single file</td><td>✅ Supported</td><td>✅</td></tr>
<tr><td>IndexedBackend</td><td>🟢 Fast</td><td>✅ Complete</td><td>✅ Directory</td><td>✅ Native I/O</td><td>❌</td></tr>
<tr><td>StdFsBackend</td><td>🟢 Normal</td><td>❌ None</td><td>✅ Native</td><td>✅ Native</td><td>❌</td></tr>
<tr><td>VRootFsBackend</td><td>🟡 Moderate</td><td>✅ Strong</td><td>✅ Native</td><td>✅ Native</td><td>❌</td></tr>
<tr><td>Overlay</td><td>Varies</td><td>Varies</td><td>Varies</td><td>Varies</td><td>Varies</td></tr>
</tbody>
</table>
</div>
<h3 id="by-use-case"><a class="header" href="#by-use-case">By Use Case</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommended</th></tr>
</thead>
<tbody>
<tr><td>Unit testing</td><td>MemoryBackend</td></tr>
<tr><td>Integration testing</td><td>MemoryBackend or SqliteBackend</td></tr>
<tr><td>Portable application data</td><td>SqliteBackend</td></tr>
<tr><td>Encrypted storage</td><td>SqliteCipherBackend</td></tr>
<tr><td>Large file + isolation</td><td>IndexedBackend</td></tr>
<tr><td>Media libraries</td><td>IndexedBackend</td></tr>
<tr><td>Plugin/agent sandboxing</td><td>VRootFsBackend</td></tr>
<tr><td>Adding middleware to real FS</td><td>StdFsBackend</td></tr>
<tr><td>Container-like isolation</td><td>Overlay&lt;SqliteBackend, MemoryBackend&gt;</td></tr>
<tr><td>Template with modifications</td><td>Overlay&lt;Base, Upper&gt;</td></tr>
<tr><td>WASM/Browser</td><td>MemoryBackend or SqliteBackend</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="platform-compatibility"><a class="header" href="#platform-compatibility">Platform Compatibility</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th style="text-align: center">Windows</th><th style="text-align: center">Linux</th><th style="text-align: center">macOS</th><th style="text-align: center">WASM</th></tr>
</thead>
<tbody>
<tr><td>MemoryBackend</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>SqliteBackend</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅*</td></tr>
<tr><td>IndexedBackend</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>StdFsBackend</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>VRootFsBackend</td><td style="text-align: center">✅**</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>Overlay</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">Varies</td></tr>
</tbody>
</table>
</div>
<p>* Requires wasm32-compatible SQLite build<br>** Windows symlinks require elevated privileges or Developer Mode</p>
<hr>
<h2 id="common-mistakes-to-avoid"><a class="header" href="#common-mistakes-to-avoid">Common Mistakes to Avoid</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>❌ Mistake</th><th>✅ Instead</th></tr>
</thead>
<tbody>
<tr><td>Using <code>StdFsBackend</code> with user-provided paths</td><td>Use <code>VRootFsBackend</code> - it prevents <code>../../etc/passwd</code> attacks</td></tr>
<tr><td>Using <code>MemoryBackend</code> for data that must survive restart</td><td>Use <code>SqliteBackend</code> for persistence, or call <code>save_to()</code> to serialize</td></tr>
<tr><td>Expecting identical symlink behavior across platforms with <code>VRootFsBackend</code></td><td>Use <code>MemoryBackend</code> or <code>SqliteBackend</code> for consistent cross-platform symlinks</td></tr>
<tr><td>Using <code>Overlay</code> when a simple backend would suffice</td><td>Keep it simple - use <code>Overlay</code> only when you need true layered semantics</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="which-crate-should-i-use"><a class="header" href="#which-crate-should-i-use">Which Crate Should I Use?</a></h1>
<hr>
<h2 id="decision-guide"><a class="header" href="#decision-guide">Decision Guide</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>You want to…</th><th>Use</th></tr>
</thead>
<tbody>
<tr><td>Build an application</td><td><code>anyfs</code></td></tr>
<tr><td>Use built-in backends (Memory, SQLite, VRootFs)</td><td><code>anyfs</code></td></tr>
<tr><td>Use built-in middleware (Quota, PathFilter, etc.)</td><td><code>anyfs</code></td></tr>
<tr><td>Implement a custom backend</td><td><code>anyfs-backend</code> only</td></tr>
<tr><td>Implement custom middleware</td><td><code>anyfs-backend</code> only</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="quick-examples"><a class="header" href="#quick-examples">Quick Examples</a></h2>
<h3 id="simple-usage"><a class="header" href="#simple-usage">Simple usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs::FileStorage;

let fs = FileStorage::new(MemoryBackend::new());
fs.create_dir_all("/data")?;
fs.write("/data/file.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<h3 id="with-middleware-quotas-sandboxing-tracing"><a class="header" href="#with-middleware-quotas-sandboxing-tracing">With middleware (quotas, sandboxing, tracing)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, RestrictionsLayer, PathFilterLayer, TracingLayer};
use anyfs::FileStorage;

let stack = SqliteBackend::open("tenant.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(stack);
<span class="boring">}</span></code></pre>
<h3 id="custom-backend-implementation"><a class="header" href="#custom-backend-implementation">Custom backend implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, FsError, Metadata, DirEntry};
use std::path::Path;

pub struct MyBackend;

impl Fs for MyBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        todo!()
    }

    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    // ... implement all 25 methods
}
<span class="boring">}</span></code></pre>
<h3 id="custom-middleware-implementation"><a class="header" href="#custom-middleware-implementation">Custom middleware implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, Layer, FsError};
use std::path::Path;

pub struct MyMiddleware&lt;B: Fs&gt; {
    inner: B,
}

impl&lt;B: Fs&gt; Fs for MyMiddleware&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Intercept, transform, or delegate
        self.inner.read(path)
    }
    // ... implement all methods
}

pub struct MyMiddlewareLayer;

impl&lt;B: Fs&gt; Layer&lt;B&gt; for MyMiddlewareLayer {
    type Backend = MyMiddleware&lt;B&gt;;
    fn layer(self, backend: B) -&gt; Self::Backend {
        MyMiddleware { inner: backend }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<ul>
<li><strong>Don’t depend on <code>anyfs</code></strong> if you’re only implementing a backend or middleware. Use <code>anyfs-backend</code>.</li>
<li><strong>Don’t put policy in backends.</strong> Use middleware (Quota, PathFilter, etc.).</li>
<li><strong>Don’t put policy in FileStorage.</strong> It is an ergonomic wrapper with centralized path resolution, not a policy layer.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="consumer-documentation-planning"><a class="header" href="#consumer-documentation-planning">Consumer Documentation Planning</a></h1>
<blockquote>
<p><strong>This document specifies what the Context7-style consumer documentation should contain when the AnyFS library is implemented.</strong>
This is a planning/specification document, not actual API documentation.</p>
</blockquote>
<hr>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>When AnyFS is implemented, we need a <strong>Context7-style reference document</strong> that LLMs can use to correctly consume the AnyFS API. This document specifies what that reference should contain.</p>
<p><strong>Why Context7-style?</strong></p>
<ul>
<li>LLMs need quick decision trees to select the right components</li>
<li>Copy-paste-ready patterns reduce hallucination</li>
<li>Common mistakes section prevents known pitfalls</li>
<li>Trait hierarchy helps understand what to implement</li>
</ul>
<hr>
<h2 id="required-sections"><a class="header" href="#required-sections">Required Sections</a></h2>
<p>The consumer documentation MUST include these sections:</p>
<h3 id="1-quick-decision-trees"><a class="header" href="#1-quick-decision-trees">1. Quick Decision Trees</a></h3>
<p>Decision trees help LLMs quickly navigate to the right component. Include:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Decision Tree</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Which Crate?</td><td><code>anyfs-backend</code> vs <code>anyfs</code></td></tr>
<tr><td>Which Backend?</td><td>Memory, SQLite, VRootFs, etc.</td></tr>
<tr><td>Which Middleware?</td><td>Quota, PathFilter, ReadOnly, etc.</td></tr>
<tr><td>Which Trait Level?</td><td>Fs, FsFull, FsFuse, FsPosix</td></tr>
</tbody>
</table>
</div>
<p><strong>Format:</strong> ASCII tree diagrams with terminal answers.</p>
<p><strong>Example structure (to be filled with actual API when implemented):</strong></p>
<pre><code>Is data persistence required?
├─ NO → MemoryBackend
└─ YES → Is encryption needed?
         ├─ YES → SqliteCipherBackend
         └─ NO → [continue decision tree...]
</code></pre>
<h3 id="2-common-patterns"><a class="header" href="#2-common-patterns">2. Common Patterns</a></h3>
<p>Provide copy-paste-ready code for these scenarios:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Simple File Operations</td><td>read, write, delete, check existence</td></tr>
<tr><td>Directory Operations</td><td>create, list, remove</td></tr>
<tr><td>Sandboxed AI Agent</td><td>Full middleware stack example</td></tr>
<tr><td>Persistent Database</td><td>SqliteBackend setup</td></tr>
<tr><td>Type-Safe Containers</td><td>Marker types for compile-time safety</td></tr>
<tr><td>Streaming Large Files</td><td>open_read/open_write usage</td></tr>
</tbody>
</table>
</div>
<p><strong>Requirements for each pattern:</strong></p>
<ul>
<li>Complete, runnable code blocks</li>
<li>All imports included</li>
<li>Proper error handling (no <code>.unwrap()</code>)</li>
<li>Minimal code that demonstrates the concept</li>
</ul>
<h3 id="3-trait-hierarchy-diagram"><a class="header" href="#3-trait-hierarchy-diagram">3. Trait Hierarchy Diagram</a></h3>
<p>Visual representation of the trait hierarchy:</p>
<pre><code>FsPosix  ← Full POSIX (handles, locks, xattr)
    ↑
FsFuse   ← FUSE-mountable (+ inodes)
    ↑
FsFull   ← std::fs features (+ links, permissions, sync, stats)
    ↑
   Fs    ← Basic filesystem (90% of use cases)
    ↑
FsRead + FsWrite + FsDir  ← Core traits
</code></pre>
<p>With clear guidance: “Implement the lowest level you need. Higher levels include all below.”</p>
<h3 id="4-backend-implementation-pattern"><a class="header" href="#4-backend-implementation-pattern">4. Backend Implementation Pattern</a></h3>
<p>Template for implementing custom backends. The consumer docs should include:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Traits to Implement</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>Minimum</td><td><code>FsRead + FsWrite + FsDir</code></td><td><code>Fs</code></td></tr>
<tr><td>Extended</td><td>Add <code>FsLink</code>, <code>FsPermissions</code>, <code>FsSync</code>, <code>FsStats</code></td><td><code>FsFull</code></td></tr>
<tr><td>FUSE</td><td>Add <code>FsInode</code></td><td><code>FsFuse</code></td></tr>
<tr><td>POSIX</td><td>Add <code>FsHandles</code>, <code>FsLock</code>, <code>FsXattr</code></td><td><code>FsPosix</code></td></tr>
</tbody>
</table>
</div>
<p>Each level should have a complete template showing all required method signatures.</p>
<h3 id="5-middleware-implementation-pattern"><a class="header" href="#5-middleware-implementation-pattern">5. Middleware Implementation Pattern</a></h3>
<p>Template showing:</p>
<ul>
<li>How to wrap an inner backend with a generic type parameter</li>
<li>Which methods to intercept vs delegate</li>
<li>The <code>Layer</code> trait for <code>.layer()</code> syntax</li>
<li>Common middleware patterns table:</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Intercept</th><th>Delegate</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Logging</td><td>All (before/after)</td><td>All</td><td><code>Tracing</code></td></tr>
<tr><td>Block writes</td><td>Write methods → error</td><td>Read methods</td><td><code>ReadOnly</code></td></tr>
<tr><td>Transform data</td><td><code>read</code>/<code>write</code></td><td>Everything else</td><td><code>Encryption</code></td></tr>
<tr><td>Check access</td><td>All (before)</td><td>All</td><td><code>PathFilter</code></td></tr>
<tr><td>Enforce limits</td><td>Write methods (check size)</td><td>Read methods</td><td><code>Quota</code></td></tr>
</tbody>
</table>
</div>
<h3 id="6-adapter-patterns"><a class="header" href="#6-adapter-patterns">6. Adapter Patterns</a></h3>
<p>Templates for interoperability:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Adapter Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>FROM external</td><td>Wrap external crate’s filesystem as AnyFS backend</td></tr>
<tr><td>TO external</td><td>Wrap AnyFS backend to satisfy external crate’s trait</td></tr>
</tbody>
</table>
</div>
<h3 id="7-error-handling-reference"><a class="header" href="#7-error-handling-reference">7. Error Handling Reference</a></h3>
<p>All <code>FsError</code> variants with when to use each:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>When to Return</th></tr>
</thead>
<tbody>
<tr><td><code>NotFound</code></td><td>Path doesn’t exist</td></tr>
<tr><td><code>AlreadyExists</code></td><td>Path already exists (create conflict)</td></tr>
<tr><td><code>NotAFile</code></td><td>Expected file, got directory</td></tr>
<tr><td><code>NotADirectory</code></td><td>Expected directory, got file</td></tr>
<tr><td><code>DirectoryNotEmpty</code></td><td>Can’t remove non-empty directory</td></tr>
<tr><td><code>ReadOnly</code></td><td>Write blocked by ReadOnly middleware</td></tr>
<tr><td><code>AccessDenied</code></td><td>Blocked by PathFilter or permissions</td></tr>
<tr><td><code>QuotaExceeded</code></td><td>Size/count limit exceeded</td></tr>
<tr><td><code>NotSupported</code></td><td>Backend doesn’t support this operation</td></tr>
<tr><td><code>Backend</code></td><td>Backend-specific error</td></tr>
</tbody>
</table>
</div>
<h3 id="8-common-mistakes--fixes"><a class="header" href="#8-common-mistakes--fixes">8. Common Mistakes &amp; Fixes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mistake</th><th>Fix</th></tr>
</thead>
<tbody>
<tr><td>Using <code>unwrap()</code></td><td>Always use <code>?</code> or handle <code>FsError</code></td></tr>
<tr><td>Assuming paths normalized</td><td>Use <code>canonicalize()</code> first</td></tr>
<tr><td>Forgetting parent dirs</td><td>Use <code>create_dir_all</code></td></tr>
<tr><td>Holding handles too long</td><td>Drop promptly</td></tr>
<tr><td>Mixing backend types</td><td>Use <code>FileStorage::boxed()</code></td></tr>
<tr><td>Testing with real files</td><td>Use <code>MemoryBackend</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="document-structure"><a class="header" href="#document-structure">Document Structure</a></h2>
<p>When creating the actual consumer documentation, follow this structure:</p>
<pre><code class="language-markdown"># AnyFS Implementation Patterns

## Quick Decision Trees
### Which Crate Do I Need?
### Which Backend Should I Use?
### Do I Need Middleware?
### Which Trait Level?

## Common Patterns
### Simple File Operations
### Directory Operations
### Sandboxed AI Agent
### Persistent Database
### Type-Safe Container Markers

## Trait Hierarchy (Pick Your Level)

## Pattern 1: Implement a Backend
### Minimum: Implement Fs
### Add Links/Permissions: Implement FsFull
### Add FUSE Support: Implement FsFuse

## Pattern 2: Implement Middleware
### Template
### Common Middleware Patterns

## Pattern 3: Implement an Adapter
### Adapter FROM another crate
### Adapter TO another crate

## Error Handling Reference

## Common Mistakes &amp; Fixes

## Quick Reference: What to Implement
</code></pre>
<hr>
<h2 id="creation-guidelines"><a class="header" href="#creation-guidelines">Creation Guidelines</a></h2>
<p>When creating the actual consumer documentation after implementation:</p>
<ol>
<li><strong>Use actual tested code</strong> - Every example must compile and run</li>
<li><strong>Include all imports</strong> - LLMs need complete context</li>
<li><strong>Show error handling</strong> - Never use <code>.unwrap()</code> in examples</li>
<li><strong>Keep examples minimal</strong> - Shortest code that demonstrates the pattern</li>
<li><strong>Update with API changes</strong> - This doc must stay in sync with implementation</li>
<li><strong>Validate against real usage</strong> - Test each pattern before including it</li>
</ol>
<hr>
<h2 id="quality-checklist"><a class="header" href="#quality-checklist">Quality Checklist</a></h2>
<p>Before publishing the consumer documentation:</p>
<ul>
<li><input disabled="" type="checkbox"> All code examples compile</li>
<li><input disabled="" type="checkbox"> All code examples run without panics</li>
<li><input disabled="" type="checkbox"> Decision trees lead to correct answers</li>
<li><input disabled="" type="checkbox"> Error variants match actual <code>FsError</code> enum</li>
<li><input disabled="" type="checkbox"> Trait hierarchy matches actual trait definitions</li>
<li><input disabled="" type="checkbox"> Common mistakes reflect actual issues found in testing</li>
</ul>
<hr>
<h2 id="related-documents"><a class="header" href="#related-documents">Related Documents</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Document</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><a href="#llm-optimized-development-methodology">LLM Development Methodology</a></td><td>For implementers: how to structure code for LLM development</td></tr>
<tr><td>This document</td><td>Specification for consumer documentation</td></tr>
<tr><td><a href="#backend-implementers-guide">Backend Guide</a></td><td>Design for backend implementation</td></tr>
<tr><td><a href="#tutorial-building-your-first-middleware">Middleware Tutorial</a></td><td>Design for middleware creation</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="tracking"><a class="header" href="#tracking">Tracking</a></h2>
<p>This planning document should be replaced with actual consumer documentation when:</p>
<ol>
<li><strong>AnyFS is implemented</strong> - The crates exist and compile</li>
<li><strong>API is stable</strong> - No major breaking changes expected</li>
<li><strong>Examples are tested</strong> - All patterns verified working</li>
</ol>
<p><strong>GitHub Issue:</strong> Create Context7-style consumer documentation</p>
<ul>
<li><strong>Status:</strong> Blocked by AnyFS implementation</li>
<li><strong>Template:</strong> This planning document</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="llm-optimized-development-methodology"><a class="header" href="#llm-optimized-development-methodology">LLM-Optimized Development Methodology</a></h1>
<p><strong>Purpose:</strong> This document defines the methodology for structuring AnyFS code so that each component is independently testable, reviewable, replaceable, and fixable—by both humans and LLMs—without requiring full project context.</p>
<hr>
<h2 id="core-principle-context-independent-components"><a class="header" href="#core-principle-context-independent-components">Core Principle: Context-Independent Components</a></h2>
<p>Every component in AnyFS should be understandable and modifiable with <strong>only local context</strong>. An LLM (or human contributor) should be able to:</p>
<ol>
<li><strong>Understand</strong> a component by reading only its file + trait definition</li>
<li><strong>Test</strong> a component in isolation without the rest of the system</li>
<li><strong>Fix</strong> a bug by looking at only the failing component + error message</li>
<li><strong>Review</strong> changes without understanding the entire architecture</li>
<li><strong>Replace</strong> a component with an alternative implementation</li>
</ol>
<p>This is achieved through strict separation of concerns, clear contracts (traits), and self-documenting structure.</p>
<hr>
<h2 id="the-five-pillars"><a class="header" href="#the-five-pillars">The Five Pillars</a></h2>
<h3 id="1-single-responsibility-per-file"><a class="header" href="#1-single-responsibility-per-file">1. Single Responsibility per File</a></h3>
<p>Each file implements <strong>exactly one concept</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Implements</th><th>Dependencies</th></tr>
</thead>
<tbody>
<tr><td><code>fs_read.rs</code></td><td><code>FsRead</code> trait</td><td><code>FsError</code>, <code>Metadata</code></td></tr>
<tr><td><code>quota.rs</code></td><td><code>Quota&lt;B&gt;</code> middleware</td><td><code>Fs</code> trait</td></tr>
<tr><td><code>memory.rs</code></td><td><code>MemoryBackend</code></td><td><code>Fs</code>, <code>FsLink</code>, etc.</td></tr>
<tr><td><code>iterative.rs</code></td><td><code>IterativeResolver</code></td><td><code>PathResolver</code> trait</td></tr>
</tbody>
</table>
</div>
<p><strong>Why:</strong> An LLM can be given just the file + its dependencies. No need for “the big picture.”</p>
<h3 id="2-contract-first-design-traits-as-contracts"><a class="header" href="#2-contract-first-design-traits-as-contracts">2. Contract-First Design (Traits as Contracts)</a></h3>
<p>Every component implements a well-defined trait. The trait IS the specification:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Read operations for a virtual filesystem.
/// 
/// # Contract
/// - All methods use `&amp;self` (interior mutability)
/// - Thread-safe: `Send + Sync` required
/// - Errors are always `FsError`, never panic
/// 
/// # Implementor Checklist
/// - [ ] Handle non-existent paths with `FsError::NotFound`
/// - [ ] Handle non-UTF8 content in `read_to_string` with `FsError::InvalidData`
/// - [ ] `metadata()` follows symlinks; use `symlink_metadata()` for link info
pub trait FsRead: Send + Sync {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>LLM Instruction:</strong> “Implement <code>FsRead</code> for <code>MyBackend</code>. Follow the contract in the trait doc.”</p>
<h3 id="3-isolated-testing-no-integration-dependencies"><a class="header" href="#3-isolated-testing-no-integration-dependencies">3. Isolated Testing (No Integration Dependencies)</a></h3>
<p>Each component has tests that run without external dependencies:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    // Mock only what's needed
    struct MockFs {
        files: HashMap&lt;PathBuf, Vec&lt;u8&gt;&gt;,
    }
    
    #[test]
    fn quota_rejects_oversized_write() {
        let mock = MockFs::new();
        let quota = Quota::new(mock).max_file_size(100);
        
        let result = quota.write(Path::new("/big.txt"), &amp;[0u8; 200]);
        assert!(matches!(result, Err(FsError::FileSizeExceeded { .. })));
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why:</strong> LLM can run tests for just the component being fixed. No database, no filesystem, no network.</p>
<h3 id="4-error-messages-as-documentation"><a class="header" href="#4-error-messages-as-documentation">4. Error Messages as Documentation</a></h3>
<p>Errors must contain enough context to fix the problem without reading other code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Bad: Requires context to understand
Err(FsError::NotFound { path: path.to_path_buf() })

// ✅ Good: Self-explanatory
Err(FsError::NotFound { 
    path: path.to_path_buf(),
    operation: "read",
    context: "file does not exist or is a directory".into(),
})
<span class="boring">}</span></code></pre>
<p><strong>LLM Instruction:</strong> “The error says ‘quota exceeded: limit 100MB, requested 150MB, usage 80MB’. Fix the code that’s writing 150MB.”</p>
<h3 id="5-documentation-at-every-boundary"><a class="header" href="#5-documentation-at-every-boundary">5. Documentation at Every Boundary</a></h3>
<p>Every public item has documentation explaining:</p>
<ul>
<li><strong>What</strong> it does (one line)</li>
<li><strong>When</strong> to use it (use case)</li>
<li><strong>How</strong> to use it (example)</li>
<li><strong>Why</strong> it exists (rationale, if non-obvious)</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Path resolution strategy using iterative component-by-component traversal.
///
/// # When to Use
/// - Default resolver for virtual backends (MemoryBackend, SqliteBackend)
/// - When you need standard POSIX-like symlink resolution
///
/// # Example
/// ```rust
/// let resolver = IterativeResolver::new();
/// let canonical = resolver.canonicalize(Path::new("/a/b/../c"), &amp;fs)?;
/// ```
///
/// # Performance
/// O(n) where n = number of path components. For deep paths with many symlinks,
/// consider `CachingResolver` wrapper.
pub struct IterativeResolver { /* ... */ }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="file-structure-convention"><a class="header" href="#file-structure-convention">File Structure Convention</a></h2>
<p>Every implementation file follows this structure:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # Component Name
//!
//! Brief description of what this component does.
//!
//! ## Responsibility
//! - Single bullet point describing THE responsibility
//!
//! ## Dependencies
//! - List of traits/types this depends on
//!
//! ## Usage
//! ```rust
//! // Minimal working example
//! ```

use crate::{...}; // Minimal imports

// ============================================================================
// Types
// ============================================================================

/// Primary type for this component.
pub struct ComponentName { /* ... */ }

// ============================================================================
// Trait Implementations
// ============================================================================

impl SomeTrait for ComponentName {
    // Implementation
}

// ============================================================================
// Public API
// ============================================================================

impl ComponentName {
    /// Constructor with sensible defaults.
    pub fn new() -&gt; Self { /* ... */ }
    
    /// Builder-style configuration.
    pub fn with_option(self, value: T) -&gt; Self { /* ... */ }
}

// ============================================================================
// Private Helpers
// ============================================================================

impl ComponentName {
    fn internal_helper(&amp;self) { /* ... */ }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    
    // Tests that verify the contract
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="llm-prompting-patterns"><a class="header" href="#llm-prompting-patterns">LLM Prompting Patterns</a></h2>
<h3 id="pattern-1-implement-a-component"><a class="header" href="#pattern-1-implement-a-component">Pattern 1: Implement a Component</a></h3>
<pre><code>Implement `CachingResolver` in `anyfs/src/resolvers/caching.rs`.

Contract: Implement `PathResolver` trait (see anyfs-backend/src/path_resolver.rs).

Requirements:
- Wrap another resolver with LRU cache
- Cache resolved canonical paths keyed by input path
- Bounded cache size (configurable max entries)

Test: Write a test verifying cache hit returns same result as cache miss.
</code></pre>
<h3 id="pattern-2-fix-a-bug"><a class="header" href="#pattern-2-fix-a-bug">Pattern 2: Fix a Bug</a></h3>
<pre><code>Bug: `Quota&lt;B&gt;` doesn't account for existing file size when checking write limits.

File: src/middleware/quota.rs
Error: QuotaExceeded when writing 50 bytes to a 30-byte file with 100-byte limit.
Expected: Should succeed (30 + 50 = 80 &lt; 100).

Fix the `check_write_quota` method.
</code></pre>
<h3 id="pattern-3-add-a-feature"><a class="header" href="#pattern-3-add-a-feature">Pattern 3: Add a Feature</a></h3>
<pre><code>Add `max_path_depth` limit to `Quota&lt;B&gt;` middleware.

File: src/middleware/quota.rs
Contract: Reject operations that would create paths deeper than the limit.

Example:
```rust
let quota = Quota::new(backend).max_path_depth(5);
quota.create_dir_all("/a/b/c/d/e/f")?; // Err: depth 6 &gt; limit 5
</code></pre>
<pre><code>
### Pattern 4: Review a Change

</code></pre>
<p>Review this change to IterativeResolver:</p>
<ul>
<li>Does it maintain the PathResolver contract?</li>
<li>Are edge cases handled (empty path, root path, circular symlinks)?</li>
<li>Are error messages informative?</li>
<li>Are tests sufficient?</li>
</ul>
<p>[diff]</p>
<pre><code>
---

## Component Isolation Checklist

Before considering a component complete, verify:

- [ ] **Single file** - Component lives in one file (or one module with mod.rs)
- [ ] **Clear contract** - Implements a trait with documented invariants
- [ ] **Minimal dependencies** - Only depends on traits/types, not other implementations
- [ ] **Self-contained tests** - Tests use mocks, not real backends
- [ ] **Informative errors** - Error messages explain what went wrong and how to fix
- [ ] **Usage example** - Doc comment shows how to use in isolation
- [ ] **No global state** - All state is in the struct instance
- [ ] **Thread-safe** - `Send + Sync` where required
- [ ] **Documented edge cases** - What happens with empty input, None, errors?

---

## Open Source Contribution Benefits

This methodology directly enables:

| Benefit                     | How                                                             |
| --------------------------- | --------------------------------------------------------------- |
| **First-time contributors** | Can understand one component without reading the whole codebase |
| **Focused PRs**             | Changes stay in one file, easy to review                        |
| **Parallel development**    | Multiple contributors work on different components              |
| **Quick onboarding**        | Read the trait, implement the trait, done                       |
| **CI efficiency**           | Test just the changed component                                 |

---

## Anti-Patterns to Avoid

### ❌ Spaghetti Dependencies

```rust
// Bad: Middleware knows about specific backends
impl&lt;B: Fs&gt; Quota&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        if let Some(sqlite) = self.inner.downcast_ref::&lt;SqliteBackend&gt;() {
            // Special case for SQLite
        }
    }
}
</code></pre>
<h3 id="-hidden-context-requirements"><a class="header" href="#-hidden-context-requirements">❌ Hidden Context Requirements</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Requires knowing about global configuration
impl FsRead for MyBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let config = CONFIG.lock().unwrap(); // Hidden global!
        // ...
    }
}
<span class="boring">}</span></code></pre>
<h3 id="-tests-that-require-setup"><a class="header" href="#-tests-that-require-setup">❌ Tests That Require Setup</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Requires database, filesystem, network
#[test]
fn test_sqlite_backend() {
    let db = SqliteBackend::open("test.db").unwrap(); // Creates real file!
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="-vague-errors"><a class="header" href="#-vague-errors">❌ Vague Errors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: No context
Err(FsError::Backend("operation failed".into()))
<span class="boring">}</span></code></pre>
<hr>
<h2 id="integration-with-context7-style-documentation"><a class="header" href="#integration-with-context7-style-documentation">Integration with Context7-style Documentation</a></h2>
<p>When the project is complete, we will provide a <strong>consumer-facing LLM context document</strong> that:</p>
<ol>
<li>Explains the surface API (what to import, what to call)</li>
<li>Provides decision trees (which backend? which middleware?)</li>
<li>Shows complete, runnable examples</li>
<li>Lists common mistakes and how to avoid them</li>
</ol>
<p>This is separate from AGENTS.md (for contributors) and lives in <a href="#consumer-documentation-planning">Implementation Patterns</a>.</p>
<hr>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Principle</th><th>Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Isolated</strong></td><td>One file, one concept</td></tr>
<tr><td><strong>Contracted</strong></td><td>Traits define the spec</td></tr>
<tr><td><strong>Testable</strong></td><td>Mock-based unit tests</td></tr>
<tr><td><strong>Debuggable</strong></td><td>Rich error context</td></tr>
<tr><td><strong>Documented</strong></td><td>Examples at every boundary</td></tr>
<tr><td><strong>LLM-Ready</strong></td><td>Promptable patterns for common tasks</td></tr>
</tbody>
</table>
</div>
<p>By following this methodology, AnyFS becomes a codebase where any component can be understood, tested, fixed, or replaced by an LLM (or human) with only local context. This is the foundation for sustainable AI-assisted development.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cross-platform-virtual-drive-mounting"><a class="header" href="#cross-platform-virtual-drive-mounting">Cross-Platform Virtual Drive Mounting</a></h1>
<p><strong>Mounting AnyFS backends as real filesystem mount points</strong></p>
<hr>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>AnyFS backends implementing <code>FsFuse</code> can be mounted as real filesystem drives that any application can access. This is part of the <code>anyfs</code> crate (behind feature flags: <code>fuse</code> for Linux/macOS, <code>winfsp</code> for Windows) because mounting is a core promise of AnyFS, not an optional extra.</p>
<hr>
<h2 id="product-promise"><a class="header" href="#product-promise">Product Promise</a></h2>
<p>Mounting is a core AnyFS promise: make filesystem composition easy, safe, and genuinely enjoyable for programmers. The mount API prioritizes:</p>
<ul>
<li>Easy onboarding (one handle, one builder, minimal boilerplate)</li>
<li>Safe defaults (explicit read-only modes, clear errors, no hidden behavior)</li>
<li>Delightful DX (predictable behavior, fast feedback, good docs)</li>
</ul>
<hr>
<h2 id="roadmap-mvp-to-cross-platform"><a class="header" href="#roadmap-mvp-to-cross-platform">Roadmap (MVP to Cross-Platform)</a></h2>
<h3 id="phase-0-design-and-api-shape-complete"><a class="header" href="#phase-0-design-and-api-shape-complete">Phase 0: Design and API shape (complete)</a></h3>
<ul>
<li>API spec defines <code>MountHandle</code>, <code>MountBuilder</code>, <code>MountOptions</code>, <code>MountError</code></li>
<li>Platform detection hooks (<code>is_available</code>) and consistent error mapping</li>
<li>Examples and docs anchored in this guide
<strong>Acceptance:</strong> Spec review complete; API signatures consistent across docs; error mapping defined.</li>
</ul>
<h3 id="phase-1-linux-fuse-mvp-read-only-pending"><a class="header" href="#phase-1-linux-fuse-mvp-read-only-pending">Phase 1: Linux FUSE MVP (read-only, pending)</a></h3>
<ul>
<li><code>fuser</code> adapter for lookup/getattr/readdir/read</li>
<li>Read-only mount option; write ops return <code>PermissionDenied</code>
<strong>Acceptance:</strong> Mount/unmount works on Linux; read-only operations pass smoke tests; unmount-on-drop is reliable.</li>
</ul>
<h3 id="phase-2-linux-fuse-readwrite-pending"><a class="header" href="#phase-2-linux-fuse-readwrite-pending">Phase 2: Linux FUSE read/write (pending)</a></h3>
<ul>
<li>Full write path: create, write, rename, remove, link operations</li>
<li>Capability reporting and correct metadata mapping
<strong>Acceptance:</strong> Conformance tests pass for FsFuse path/inode behavior; no panics; clean shutdown.</li>
</ul>
<h3 id="phase-3-macos-parity-macfuse-pending"><a class="header" href="#phase-3-macos-parity-macfuse-pending">Phase 3: macOS parity (macFUSE, pending)</a></h3>
<ul>
<li>Port Linux FUSE adapter to macFUSE requirements</li>
<li>Driver detection and install guidance
<strong>Acceptance:</strong> Mount/unmount works on macOS with core read/write flows.</li>
</ul>
<h3 id="phase-4-windows-support-winfsp-optional-dokan-pending"><a class="header" href="#phase-4-windows-support-winfsp-optional-dokan-pending">Phase 4: Windows support (WinFsp, optional Dokan, pending)</a></h3>
<ul>
<li>WinFsp adapter with required mapping for Windows semantics</li>
<li>Optional Dokan path as alternative provider
<strong>Acceptance:</strong> Mount/unmount works on Windows; driver detection errors are clear and actionable.</li>
</ul>
<hr>
<h2 id="non-goals-1"><a class="header" href="#non-goals-1">Non-goals</a></h2>
<ul>
<li>Kernel drivers or kernel-space code</li>
<li>WASM or browser environments</li>
<li>Network filesystem protocols (NFS/SMB)</li>
</ul>
<hr>
<h2 id="platform-technologies"><a class="header" href="#platform-technologies">Platform Technologies</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Technology</th><th>Rust Crate</th><th>User Installation</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>FUSE</td><td><code>fuser</code></td><td>Usually pre-installed</td></tr>
<tr><td>macOS</td><td>macFUSE</td><td><code>fuser</code></td><td><a href="https://osxfuse.github.io/">macFUSE</a></td></tr>
<tr><td>Windows</td><td>WinFsp</td><td><code>winfsp</code></td><td><a href="https://winfsp.dev/">WinFsp</a></td></tr>
<tr><td>Windows</td><td>Dokan</td><td><code>dokan</code></td><td><a href="https://dokan-dev.github.io/">Dokan</a></td></tr>
</tbody>
</table>
</div>
<p><strong>Key insight:</strong> Linux and macOS both use FUSE (via <code>fuser</code> crate), but Windows requires a completely different API (WinFsp or Dokan).</p>
<hr>
<h2 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h2>
<h3 id="unified-mount-trait"><a class="header" href="#unified-mount-trait">Unified Mount Trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Platform-agnostic mount handle.
/// Drop to unmount.
pub struct MountHandle {
    inner: Box&lt;dyn MountHandleInner&gt;,
}

impl MountHandle {
    /// Mount a backend at the specified path.
    ///
    /// Platform requirements:
    /// - Linux: FUSE (usually available)
    /// - macOS: macFUSE must be installed
    /// - Windows: WinFsp or Dokan must be installed
    pub fn mount&lt;B: FsFuse&gt;(backend: B, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, MountError&gt; {
        #[cfg(unix)]
        return fuse_mount(backend, path);

        #[cfg(windows)]
        return winfsp_mount(backend, path);

        #[cfg(not(any(unix, windows)))]
        return Err(MountError::PlatformNotSupported);
    }

    /// Check if mounting is available on this platform.
    pub fn is_available() -&gt; bool {
        #[cfg(target_os = "linux")]
        return check_fuse_available();

        #[cfg(target_os = "macos")]
        return check_macfuse_available();

        #[cfg(windows)]
        return check_winfsp_available() || check_dokan_available();

        #[cfg(not(any(unix, windows)))]
        return false;
    }

    /// Unmount the filesystem.
    pub fn unmount(self) -&gt; Result&lt;(), MountError&gt; {
        self.inner.unmount()
    }
}

impl Drop for MountHandle {
    fn drop(&amp;mut self) {
        let _ = self.inner.unmount();
    }
}
<span class="boring">}</span></code></pre>
<h3 id="platform-adapters"><a class="header" href="#platform-adapters">Platform Adapters</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                     MountHandle (unified API)               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │ FuseAdapter │  │ FuseAdapter │  │ WinFspAdapter       │ │
│  │   (Linux)   │  │   (macOS)   │  │    (Windows)        │ │
│  └──────┬──────┘  └──────┬──────┘  └──────────┬──────────┘ │
│         │                │                     │            │
│         ▼                ▼                     ▼            │
│    ┌─────────┐      ┌─────────┐         ┌──────────┐       │
│    │  fuser  │      │  fuser  │         │  winfsp  │       │
│    │  crate  │      │  crate  │         │  crate   │       │
│    └────┬────┘      └────┬────┘         └────┬─────┘       │
│         │                │                   │              │
│         ▼                ▼                   ▼              │
│    ┌─────────┐      ┌─────────┐         ┌──────────┐       │
│    │  FUSE   │      │ macFUSE │         │  WinFsp  │       │
│    │ (kernel)│      │ (kext)  │         │ (driver) │       │
│    └─────────┘      └─────────┘         └──────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<hr>
<h2 id="module-structure"><a class="header" href="#module-structure">Module Structure</a></h2>
<p>Mounting is part of the <code>anyfs</code> crate:</p>
<pre><code>anyfs/
  src/
    mount/
      mod.rs                    # MountHandle, MountError, re-exports
      error.rs                  # MountError definitions
      handle.rs                 # MountHandle, MountOptions, builder

      unix/
        mod.rs                  # cfg(unix)
        fuse_adapter.rs         # FUSE implementation via fuser

      windows/
        mod.rs                  # cfg(windows)
        winfsp_adapter.rs       # WinFsp implementation
</code></pre>
<h3 id="feature-flags-in-anyfs-cargotoml"><a class="header" href="#feature-flags-in-anyfs-cargotoml">Feature Flags in anyfs Cargo.toml</a></h3>
<pre><code class="language-toml">[package]
name = "anyfs"
version = "0.1.0"

[dependencies]
anyfs-backend = { version = "0.1" }

[target.'cfg(unix)'.dependencies]
fuser = { version = "0.14", optional = true }

[target.'cfg(windows)'.dependencies]
winfsp = { version = "0.4", optional = true }

[features]
default = []
fuse = ["dep:fuser"]      # Enable mounting on Linux/macOS
winfsp = ["dep:winfsp"]   # Enable mounting on Windows
</code></pre>
<hr>
<h2 id="fuse-adapter-linuxmacos"><a class="header" href="#fuse-adapter-linuxmacos">FUSE Adapter (Linux/macOS)</a></h2>
<p>The FUSE adapter translates between <code>fuser::Filesystem</code> trait and our <code>FsFuse</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fuser::{Filesystem, Request, ReplyEntry, ReplyAttr, ReplyData, ReplyDirectory};
use anyfs_backend::{FsFuse, FsError, Metadata, FileType};

pub struct FuseAdapter&lt;B: FsFuse&gt; {
    backend: B,
}

impl&lt;B: FsFuse&gt; Filesystem for FuseAdapter&lt;B&gt; {
    fn lookup(&amp;mut self, _req: &amp;Request, parent: u64, name: &amp;OsStr, reply: ReplyEntry) {
        match self.backend.lookup(parent, name) {
            Ok(inode) =&gt; {
                match self.backend.metadata_by_inode(inode) {
                    Ok(meta) =&gt; reply.entry(&amp;TTL, &amp;to_fuse_attr(&amp;meta), 0),
                    Err(e) =&gt; reply.error(to_errno(&amp;e)),
                }
            }
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    fn getattr(&amp;mut self, _req: &amp;Request, ino: u64, reply: ReplyAttr) {
        match self.backend.metadata_by_inode(ino) {
            Ok(meta) =&gt; reply.attr(&amp;TTL, &amp;to_fuse_attr(&amp;meta)),
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    fn read(&amp;mut self, _req: &amp;Request, ino: u64, _fh: u64, offset: i64, size: u32, _flags: i32, _lock: Option&lt;u64&gt;, reply: ReplyData) {
        let path = match self.backend.inode_to_path(ino) {
            Ok(p) =&gt; p,
            Err(e) =&gt; return reply.error(to_errno(&amp;e)),
        };

        match self.backend.read_range(&amp;path, offset as u64, size as usize) {
            Ok(data) =&gt; reply.data(&amp;data),
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    fn readdir(&amp;mut self, _req: &amp;Request, ino: u64, _fh: u64, offset: i64, mut reply: ReplyDirectory) {
        let path = match self.backend.inode_to_path(ino) {
            Ok(p) =&gt; p,
            Err(e) =&gt; return reply.error(to_errno(&amp;e)),
        };

        match self.backend.read_dir(&amp;path) {
            Ok(entries) =&gt; {
                for (i, entry) in entries.iter().enumerate().skip(offset as usize) {
                    let file_type = match entry.file_type {
                        FileType::File =&gt; fuser::FileType::RegularFile,
                        FileType::Directory =&gt; fuser::FileType::Directory,
                        FileType::Symlink =&gt; fuser::FileType::Symlink,
                    };

                    if reply.add(entry.inode, (i + 1) as i64, file_type, &amp;entry.name) {
                        break;
                    }
                }
                reply.ok();
            }
            Err(e) =&gt; reply.error(to_errno(&amp;e)),
        }
    }

    // ... write, create, mkdir, unlink, rmdir, rename, symlink, etc.
}

fn to_errno(e: &amp;FsError) -&gt; i32 {
    match e {
        FsError::NotFound { .. } =&gt; libc::ENOENT,
        FsError::AlreadyExists { .. } =&gt; libc::EEXIST,
        FsError::NotADirectory { .. } =&gt; libc::ENOTDIR,
        FsError::NotAFile { .. } =&gt; libc::EISDIR,
        FsError::DirectoryNotEmpty { .. } =&gt; libc::ENOTEMPTY,
        FsError::AccessDenied { .. } =&gt; libc::EACCES,
        FsError::ReadOnly { .. } =&gt; libc::EROFS,
        FsError::QuotaExceeded { .. } =&gt; libc::ENOSPC,
        _ =&gt; libc::EIO,
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="winfsp-adapter-windows"><a class="header" href="#winfsp-adapter-windows">WinFsp Adapter (Windows)</a></h2>
<p>WinFsp has a different API but similar concepts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use winfsp::filesystem::{FileSystem, FileSystemContext, FileInfo, DirInfo};
use anyfs_backend::{FsFuse, FsError};

pub struct WinFspAdapter&lt;B: FsFuse&gt; {
    backend: B,
}

impl&lt;B: FsFuse&gt; FileSystem for WinFspAdapter&lt;B&gt; {
    fn get_file_info(&amp;self, file_context: &amp;FileContext) -&gt; Result&lt;FileInfo, NTSTATUS&gt; {
        let meta = self.backend.metadata(&amp;file_context.path)
            .map_err(to_ntstatus)?;
        Ok(to_file_info(&amp;meta))
    }

    fn read(&amp;self, file_context: &amp;FileContext, buffer: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, NTSTATUS&gt; {
        let data = self.backend.read_range(&amp;file_context.path, offset, buffer.len())
            .map_err(to_ntstatus)?;
        buffer[..data.len()].copy_from_slice(&amp;data);
        Ok(data.len())
    }

    fn read_directory(&amp;self, file_context: &amp;FileContext, marker: Option&lt;&amp;str&gt;, callback: impl FnMut(DirInfo)) -&gt; Result&lt;(), NTSTATUS&gt; {
        let entries = self.backend.read_dir(&amp;file_context.path)
            .map_err(to_ntstatus)?;

        for entry in entries {
            callback(to_dir_info(&amp;entry));
        }
        Ok(())
    }

    // ... write, create, delete, rename, etc.
}

fn to_ntstatus(e: FsError) -&gt; NTSTATUS {
    match e {
        FsError::NotFound { .. } =&gt; STATUS_OBJECT_NAME_NOT_FOUND,
        FsError::AlreadyExists { .. } =&gt; STATUS_OBJECT_NAME_COLLISION,
        FsError::AccessDenied { .. } =&gt; STATUS_ACCESS_DENIED,
        FsError::ReadOnly { .. } =&gt; STATUS_MEDIA_WRITE_PROTECTED,
        _ =&gt; STATUS_INTERNAL_ERROR,
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<h3 id="basic-mount"><a class="header" href="#basic-mount">Basic Mount</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, MountHandle};

// Create backend with middleware
let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build());

// Mount as drive
let mount = MountHandle::mount(backend, "/mnt/ramdisk")?;

// Now /mnt/ramdisk is a real mount point
// Any application can read/write files there

// Unmount when done (or on drop)
mount.unmount()?;
<span class="boring">}</span></code></pre>
<h3 id="windows-drive-letter"><a class="header" href="#windows-drive-letter">Windows Drive Letter</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(windows)]
let mount = MountHandle::mount(backend, "X:")?;

// Now X: is a virtual drive
<span class="boring">}</span></code></pre>
<h3 id="check-availability"><a class="header" href="#check-availability">Check Availability</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if MountHandle::is_available() {
    let mount = MountHandle::mount(backend, path)?;
} else {
    eprintln!("Mounting not available. Install:");
    #[cfg(target_os = "macos")]
    eprintln!("  - macFUSE: https://osxfuse.github.io/");
    #[cfg(windows)]
    eprintln!("  - WinFsp: https://winfsp.dev/");
}
<span class="boring">}</span></code></pre>
<h3 id="mount-options"><a class="header" href="#mount-options">Mount Options</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mount = MountHandle::builder(backend)
    .mount_point("/mnt/data")
    .read_only(true)                    // Force read-only mount
    .allow_other(true)                  // Allow other users (Linux/macOS)
    .auto_unmount(true)                 // Unmount on process exit
    .uid(1000)                          // Override UID (Linux/macOS)
    .gid(1000)                          // Override GID (Linux/macOS)
    .mount()?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MountError {
    /// Platform doesn't support mounting (e.g., WASM)
    PlatformNotSupported,

    /// Required driver not installed (macFUSE, WinFsp)
    DriverNotInstalled {
        driver: &amp;'static str,
        install_url: &amp;'static str,
    },

    /// Mount point doesn't exist or isn't accessible
    InvalidMountPoint { path: PathBuf },

    /// Mount point already in use
    MountPointBusy { path: PathBuf },

    /// Permission denied (need root/admin)
    PermissionDenied,

    /// Backend error during mount
    Backend(FsError),

    /// Platform-specific error
    Platform(String),

    /// Missing mount point in options
    MissingMountPoint,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="integration-with-middleware"><a class="header" href="#integration-with-middleware">Integration with Middleware</a></h2>
<p>All middleware works transparently when mounted:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota, PathFilter, Tracing, RateLimit, MountHandle};

// Build secure, audited, rate-limited mount
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(1024 * 1024 * 1024)  // 1 GB
        .build())
    .layer(PathFilterLayer::builder()
        .deny("**/.git/**")
        .deny("**/.env")
        .build())
    .layer(RateLimitLayer::builder()
        .max_ops(10000)
        .per_second()
        .build())
    .layer(TracingLayer::new());

let mount = MountHandle::mount(backend, "/mnt/secure")?;

// External apps see a normal filesystem
// But all operations are:
// - Quota-limited
// - Path-filtered
// - Rate-limited
// - Traced/audited

// Imagine: A mounted "USB drive" that reports real-time IOPS
// to a Prometheus dashboard!
<span class="boring">}</span></code></pre>
<h3 id="real-time-observability"><a class="header" href="#real-time-observability">Real-Time Observability</a></h3>
<p>Because the mount point sits <em>on top</em> of your middleware stack, you get <strong>live visibility</strong> into OS operations:</p>
<ul>
<li><strong>Metrics:</strong> See valid IOPS, throughput, and latency for your virtual drive in Grafana.</li>
<li><strong>Audit Logs:</strong> Record every file your legacy app touches.</li>
<li><strong>Virus Scanning:</strong> Scan files as the OS writes them, rejecting malware in real-time.</li>
</ul>
<pre><code>
---

## Use Cases

### Temporary Workspace

```rust
let workspace = MemoryBackend::new();
let mount = MountHandle::mount(workspace, "/tmp/workspace")?;

// Run build tools that expect real filesystem
std::process::Command::new("cargo")
    .current_dir("/tmp/workspace")
    .arg("build")
    .status()?;
</code></pre>
<h3 id="portable-database-as-drive"><a class="header" href="#portable-database-as-drive">Portable Database as Drive</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User's files stored in SQLite
let db = SqliteBackend::open("user_files.db")?;
let mount = MountHandle::mount(db, "U:")?;

// User can browse U: in Explorer
// Files are actually in SQLite database
<span class="boring">}</span></code></pre>
<h3 id="network-storage"><a class="header" href="#network-storage">Network Storage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remote backend (future anyfs-s3, anyfs-sftp, etc.)
let remote = S3Backend::new("my-bucket")?;
let cached = remote.layer(CacheLayer::builder()
    .max_size(100 * 1024 * 1024)
    .build());
let mount = MountHandle::mount(cached, "/mnt/cloud")?;

// Local apps see /mnt/cloud as regular filesystem
// Actually reads/writes to S3 with local caching
<span class="boring">}</span></code></pre>
<hr>
<h2 id="platform-requirements-summary"><a class="header" href="#platform-requirements-summary">Platform Requirements Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Driver</th><th>Install Command / URL</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>FUSE</td><td>Usually pre-installed. If not: <code>apt install fuse3</code></td></tr>
<tr><td>macOS</td><td>macFUSE</td><td>https://osxfuse.github.io/</td></tr>
<tr><td>Windows</td><td>WinFsp</td><td>https://winfsp.dev/ (recommended)</td></tr>
<tr><td>Windows</td><td>Dokan</td><td>https://dokan-dev.github.io/ (alternative)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ol>
<li><strong>Requires external driver</strong> - Users must install macFUSE (macOS) or WinFsp (Windows)</li>
<li><strong>Root/admin may be required</strong> - Some mount operations need elevated privileges</li>
<li><strong>Not available on WASM</strong> - Browser environment has no filesystem mounting</li>
<li><strong>Performance overhead</strong> - Userspace filesystem has kernel boundary crossing overhead</li>
<li><strong>Backend must implement FsFuse</strong> - Requires <code>FsInode</code> trait for inode operations</li>
</ol>
<hr>
<h2 id="alternative-no-mount-needed"><a class="header" href="#alternative-no-mount-needed">Alternative: No Mount Needed</a></h2>
<p>For many use cases, mounting isn’t necessary. AnyFS backends can be used directly:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Need</th><th>With Mounting</th><th>Without Mounting</th></tr>
</thead>
<tbody>
<tr><td>Build tools</td><td>Mount, run tools</td><td>Use tool’s VFS plugin if available</td></tr>
<tr><td>File browser</td><td>Mount as drive</td><td>Build custom UI with AnyFS API</td></tr>
<tr><td>Backup</td><td>Mount, use rsync</td><td>Use AnyFS API directly</td></tr>
<tr><td>Database</td><td>Mount for SQL tools</td><td>Query SQLite directly</td></tr>
</tbody>
</table>
</div>
<p><strong>Rule of thumb:</strong> Only mount when you need compatibility with external applications that expect real filesystem paths.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-building-a-txt-backend-yes-really"><a class="header" href="#tutorial-building-a-txt-backend-yes-really">Tutorial: Building a TXT Backend (Yes, Really)</a></h1>
<p><strong>How to turn a humble text file into a functioning virtual filesystem</strong></p>
<hr>
<h2 id="the-absurd-premise"><a class="header" href="#the-absurd-premise">The Absurd Premise</a></h2>
<p>What if your entire filesystem was just… a text file you can edit in Notepad?</p>
<pre><code>path,type,mode,data
/,dir,755,
/hello.txt,file,644,SGVsbG8sIFdvcmxkIQ==
/docs,dir,755,
/docs/readme.md,file,644,IyBXZWxjb21lIQoKWWVzLCB0aGlzIGlzIGluIGEgLnR4dCBmaWxl
</code></pre>
<p>One line per file. Comma-separated. Base64 content. Open it in Notepad, edit a file, save, done.</p>
<p>Sounds ridiculous? It is. But it <em>works</em>. And building it teaches you everything about implementing AnyFS backends.</p>
<p>Let’s do this.</p>
<hr>
<h2 id="why-this-is-actually-useful"><a class="header" href="#why-this-is-actually-useful">Why This Is Actually Useful</a></h2>
<p>Beyond the memes, a TXT backend demonstrates:</p>
<ol>
<li><strong>Backend flexibility</strong> - AnyFS doesn’t care how you store bytes</li>
<li><strong>Trait implementation</strong> - You’ll implement <code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code></li>
<li><strong>Middleware composition</strong> - We’ll add <code>Quota</code> to prevent the file from exploding</li>
<li><strong>Real-world patterns</strong> - The same patterns apply to serious backends</li>
<li><strong>Separation of concerns</strong> - Backends just store bytes; FileStorage handles path resolution</li>
</ol>
<p>Plus, you can literally edit your “filesystem” in Notepad. Try doing that with ext4.</p>
<blockquote>
<p><strong>Important:</strong> Backends receive <strong>already-resolved paths</strong> from FileStorage. You don’t need to handle <code>..</code>, symlinks, or normalization - that’s FileStorage’s job. Your backend just stores and retrieves bytes at the given paths.</p>
</blockquote>
<hr>
<h2 id="the-format"><a class="header" href="#the-format">The Format</a></h2>
<p>One line per entry. Four comma-separated fields. Dead simple:</p>
<pre><code>path,type,mode,data
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td>Absolute path</td><td><code>/docs/file.txt</code></td></tr>
<tr><td><code>type</code></td><td><code>file</code> or <code>dir</code></td><td><code>file</code></td></tr>
<tr><td><code>mode</code></td><td>Unix permissions (octal)</td><td><code>644</code></td></tr>
<tr><td><code>data</code></td><td>Base64-encoded content</td><td><code>SGVsbG8=</code></td></tr>
</tbody>
</table>
</div>
<p>Directories have empty data field. That’s the entire format. Open in Notepad, add a line, you created a file.</p>
<hr>
<h2 id="step-1-data-structures"><a class="header" href="#step-1-data-structures">Step 1: Data Structures</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::path::{Path, PathBuf};
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};

/// A single entry in our TXT filesystem
#[derive(Clone, Debug)]
struct TxtEntry {
    path: PathBuf,
    is_dir: bool,
    mode: u32,
    content: Vec&lt;u8&gt;,
}

impl TxtEntry {
    fn new_dir(path: impl Into&lt;PathBuf&gt;) -&gt; Self {
        Self {
            path: path.into(),
            is_dir: true,
            mode: 0o755,
            content: Vec::new(),
        }
    }

    fn new_file(path: impl Into&lt;PathBuf&gt;, content: Vec&lt;u8&gt;) -&gt; Self {
        Self {
            path: path.into(),
            is_dir: false,
            mode: 0o644,
            content,
        }
    }

    /// Serialize to a line: path,type,mode,data
    fn to_line(&amp;self) -&gt; String {
        let file_type = if self.is_dir { "dir" } else { "file" };
        let data_b64 = if self.content.is_empty() {
            String::new()
        } else {
            BASE64.encode(&amp;self.content)
        };

        format!("{},{},{:o},{}", self.path.display(), file_type, self.mode, data_b64)
    }

    /// Parse from line: path,type,mode,data
    fn from_line(line: &amp;str) -&gt; Result&lt;Self, TxtParseError&gt; {
        let parts: Vec&lt;&amp;str&gt; = line.splitn(4, ',').collect();
        if parts.len() &lt; 3 {
            return Err(TxtParseError::InvalidFormat);
        }

        let content = if parts.len() == 4 &amp;&amp; !parts[3].is_empty() {
            BASE64.decode(parts[3]).map_err(|_| TxtParseError::InvalidBase64)?
        } else {
            Vec::new()
        };

        Ok(Self {
            path: PathBuf::from(parts[0]),
            is_dir: parts[1] == "dir",
            mode: u32::from_str_radix(parts[2], 8)
                .map_err(|_| TxtParseError::InvalidNumber)?,
            content,
        })
    }
}

#[derive(Debug)]
enum TxtParseError {
    InvalidFormat,
    InvalidBase64,
    InvalidNumber,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-2-the-backend-structure"><a class="header" href="#step-2-the-backend-structure">Step 2: The Backend Structure</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, RwLock};
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

/// A filesystem backend that stores everything in a .txt file.
///
/// Yes, this is cursed. Yes, it works. Yes, you can edit it in Notepad.
pub struct TxtBackend {
    /// Path to the .txt file on the host filesystem
    txt_path: PathBuf,
    /// In-memory cache of entries (path -&gt; entry)
    entries: Arc&lt;RwLock&lt;HashMap&lt;PathBuf, TxtEntry&gt;&gt;&gt;,
}

impl TxtBackend {
    /// Create a new TXT backend, loading from file if it exists
    pub fn open(txt_path: impl Into&lt;PathBuf&gt;) -&gt; Result&lt;Self, FsError&gt; {
        let txt_path = txt_path.into();
        let mut entries = HashMap::new();

        // Always ensure root directory exists
        entries.insert(PathBuf::from("/"), TxtEntry::new_dir("/"));

        // Load existing entries if file exists
        if txt_path.exists() {
            let file = File::open(&amp;txt_path)
                .map_err(|e| FsError::Io {
                    operation: "open txt",
                    path: txt_path.clone(),
                    source: e,
                })?;

            for (line_num, line) in BufReader::new(file).lines().enumerate() {
                let line = line.map_err(|e| FsError::Io {
                    operation: "read line",
                    path: txt_path.clone(),
                    source: e,
                })?;

                // Skip header line
                if line_num == 0 &amp;&amp; line.starts_with("path,") {
                    continue;
                }

                // Skip empty lines
                if line.trim().is_empty() {
                    continue;
                }

                let entry = TxtEntry::from_line(&amp;line)
                    .map_err(|_| FsError::CorruptedData {
                        path: txt_path.clone(),
                        details: format!("line {}", line_num + 1),
                    })?;

                entries.insert(entry.path.clone(), entry);
            }
        }

        Ok(Self {
            txt_path,
            entries: Arc::new(RwLock::new(entries)),
        })
    }

    /// Create a new in-memory backend (won't persist to disk)
    pub fn in_memory() -&gt; Self {
        let mut entries = HashMap::new();
        entries.insert(PathBuf::from("/"), TxtEntry::new_dir("/"));

        Self {
            txt_path: PathBuf::from(":memory:"),
            entries: Arc::new(RwLock::new(entries)),
        }
    }

    /// Flush all entries to the .txt file
    fn flush(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        // Skip if in-memory mode
        if self.txt_path.as_os_str() == ":memory:" {
            return Ok(());
        }

        let entries = self.entries.read().unwrap();

        let mut file = File::create(&amp;self.txt_path)
            .map_err(|e| FsError::Io {
                operation: "create txt",
                path: self.txt_path.clone(),
                source: e,
            })?;

        // Write header
        writeln!(file, "path,type,mode,data")
            .map_err(|e| FsError::Io {
                operation: "write header",
                path: self.txt_path.clone(),
                source: e,
            })?;

        // Write entries (sorted for consistency)
        let mut paths: Vec&lt;_&gt; = entries.keys().collect();
        paths.sort();

        for path in paths {
            let entry = &amp;entries[path];
            writeln!(file, "{}", entry.to_line())
                .map_err(|e| FsError::Io {
                    operation: "write entry",
                    path: path.clone(),
                    source: e,
                })?;
        }

        Ok(())
    }

}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-3-implement-fsread"><a class="header" href="#step-3-implement-fsread">Step 3: Implement FsRead</a></h2>
<p>Now the fun part - making it quack like a filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsError, Metadata, FileType};

impl FsRead for TxtBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        let entries = self.entries.read().unwrap();

        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        Ok(entry.content.clone())
    }

    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt; {
        let bytes = self.read(path.as_ref())?;
        String::from_utf8(bytes)
            .map_err(|_| FsError::InvalidData {
                path: path.as_ref().to_path_buf(),
                details: "not valid UTF-8".to_string(),
            })
    }

    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let content = self.read(path)?;
        let start = offset as usize;

        if start &gt;= content.len() {
            return Ok(Vec::new());
        }

        let end = (start + len).min(content.len());
        Ok(content[start..end].to_vec())
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        let path = path.as_ref();
        let entries = self.entries.read().unwrap();
        Ok(entries.contains_key(path))
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = path.as_ref();
        let entries = self.entries.read().unwrap();

        let entry = entries.get(path)
            .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;

        Ok(Metadata {
            file_type: if entry.is_dir { FileType::Directory } else { FileType::File },
            size: entry.content.len() as u64,
            created: None,  // We keep it simple - no timestamps
            modified: None,
            accessed: None,
            permissions: Some(entry.mode),
            inode: None,
        })
    }

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Read + Send&gt;, FsError&gt; {
        let content = self.read(path)?;
        Ok(Box::new(std::io::Cursor::new(content)))
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-4-implement-fswrite"><a class="header" href="#step-4-implement-fswrite">Step 4: Implement FsWrite</a></h2>
<p>Where the magic happens - writing files to a text file:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsWrite;

impl FsWrite for TxtBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            let parent_str = parent.to_string_lossy();
            if parent_str != "/" &amp;&amp; !parent_str.is_empty() {
                let entries = self.entries.read().unwrap();
                if !entries.contains_key(parent) {
                    drop(entries);
                    return Err(FsError::NotFound {
                        path: parent.to_path_buf()
                    });
                }
            }
        }

        let mut entries = self.entries.write().unwrap();

        // Check if it's a directory
        if let Some(existing) = entries.get(&amp;path) {
            if existing.is_dir {
                return Err(FsError::NotAFile { path });
            }
        }

        // Create or update the file
        let entry = TxtEntry::new_file(path.clone(), data.to_vec());
        entries.insert(path, entry);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn append(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let mut entries = self.entries.write().unwrap();

        let entry = entries.get_mut(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        entry.content.extend_from_slice(data);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let mut entries = self.entries.write().unwrap();

        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        entries.remove(&amp;path);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let from = from.as_ref().to_path_buf();
        let to = to.as_ref().to_path_buf();

        let mut entries = self.entries.write().unwrap();

        let mut entry = entries.remove(&amp;from)
            .ok_or_else(|| FsError::NotFound { path: from.clone() })?;

        entry.path = to.clone();
        entries.insert(to, entry);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let from = from.as_ref().to_path_buf();
        let to = to.as_ref().to_path_buf();

        let entries = self.entries.read().unwrap();

        let source = entries.get(&amp;from)
            .ok_or_else(|| FsError::NotFound { path: from.clone() })?;

        if source.is_dir {
            return Err(FsError::NotAFile { path: from });
        }

        let mut new_entry = source.clone();
        new_entry.path = to.clone();

        drop(entries);

        let mut entries = self.entries.write().unwrap();
        entries.insert(to, new_entry);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn truncate(&amp;self, path: &amp;Path, size: u64) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let mut entries = self.entries.write().unwrap();

        let entry = entries.get_mut(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if entry.is_dir {
            return Err(FsError::NotAFile { path });
        }

        entry.content.truncate(size as usize);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Write + Send&gt;, FsError&gt; {
        // For simplicity, we buffer writes and apply on drop
        // A real implementation would be more sophisticated
        let path = path.as_ref().to_path_buf();

        // Ensure file exists (create empty if not)
        if !self.exists(&amp;path)? {
            self.write(&amp;path, b"")?;
        }

        Ok(Box::new(TxtFileWriter {
            backend: self.entries.clone(),
            txt_path: self.txt_path.clone(),
            path,
            buffer: Vec::new(),
        }))
    }
}

/// Writer that buffers content and writes to TXT on drop
struct TxtFileWriter {
    backend: Arc&lt;RwLock&lt;HashMap&lt;PathBuf, TxtEntry&gt;&gt;&gt;,
    txt_path: PathBuf,
    path: PathBuf,
    buffer: Vec&lt;u8&gt;,
}

impl std::io::Write for TxtFileWriter {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; std::io::Result&lt;usize&gt; {
        self.buffer.extend_from_slice(buf);
        Ok(buf.len())
    }

    fn flush(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        Ok(())
    }
}

impl Drop for TxtFileWriter {
    fn drop(&amp;mut self) {
        let mut entries = self.backend.write().unwrap();
        if let Some(entry) = entries.get_mut(&amp;self.path) {
            entry.content = std::mem::take(&amp;mut self.buffer);
        }
        // Note: flush to disk happens on next explicit flush() call
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-5-implement-fsdir"><a class="header" href="#step-5-implement-fsdir">Step 5: Implement FsDir</a></h2>
<p>Directory operations to complete the <code>Fs</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsDir, DirEntry};

impl FsDir for TxtBackend {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        let path = path.as_ref().to_path_buf();
        let entries = self.entries.read().unwrap();

        // Verify the path is a directory
        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if !entry.is_dir {
            return Err(FsError::NotADirectory { path });
        }

        // Find all direct children
        let mut children = Vec::new();

        for (child_path, child_entry) in entries.iter() {
            if let Some(parent) = child_path.parent() {
                if parent == path &amp;&amp; child_path != &amp;path {
                    children.push(DirEntry {
                        name: child_path.file_name()
                            .unwrap_or_default()
                            .to_string_lossy()
                            .into_owned(),
                        path: child_path.clone(),
                        file_type: if child_entry.is_dir {
                            FileType::Directory
                        } else {
                            FileType::File
                        },
                        size: child_entry.size,
                        inode: None,
                    });
                }
            }
        }

        // Sort for consistent ordering
        children.sort_by(|a, b| a.name.cmp(&amp;b.name));

        // Wrap in ReadDirIter (items are Ok since we've already validated them)
        Ok(ReadDirIter::new(children.into_iter().map(Ok)))
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Check parent exists
        if let Some(parent) = path.parent() {
            let parent_str = parent.to_string_lossy();
            if parent_str != "/" &amp;&amp; !parent_str.is_empty() {
                let entries = self.entries.read().unwrap();
                let parent_entry = entries.get(parent)
                    .ok_or_else(|| FsError::NotFound {
                        path: parent.to_path_buf()
                    })?;

                if !parent_entry.is_dir {
                    return Err(FsError::NotADirectory {
                        path: parent.to_path_buf()
                    });
                }
            }
        }

        let mut entries = self.entries.write().unwrap();

        // Check if already exists
        if entries.contains_key(&amp;path) {
            return Err(FsError::AlreadyExists { path, operation: "create_dir" });
        }

        entries.insert(path.clone(), TxtEntry::new_dir(path));

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Build list of directories to create
        let mut to_create = Vec::new();
        let mut current = path.clone();

        loop {
            {
                let entries = self.entries.read().unwrap();
                if entries.contains_key(&amp;current) {
                    break;
                }
            }

            to_create.push(current.clone());

            match current.parent() {
                Some(parent) if !parent.as_os_str().is_empty() =&gt; {
                    current = parent.to_path_buf();
                }
                _ =&gt; break,
            }
        }

        // Create directories from root to leaf
        to_create.reverse();
        for dir_path in to_create {
            let mut entries = self.entries.write().unwrap();
            if !entries.contains_key(&amp;dir_path) {
                entries.insert(dir_path.clone(), TxtEntry::new_dir(dir_path));
            }
        }

        self.flush()?;
        Ok(())
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Can't remove root
        if path.to_string_lossy() == "/" {
            return Err(FsError::PermissionDenied {
                path,
                operation: "remove root directory"
            });
        }

        let entries = self.entries.read().unwrap();

        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if !entry.is_dir {
            return Err(FsError::NotADirectory { path });
        }

        // Check if empty
        let has_children = entries.keys().any(|p| {
            p != &amp;path &amp;&amp; p.starts_with(&amp;path)
        });

        if has_children {
            return Err(FsError::DirectoryNotEmpty { path });
        }

        drop(entries);

        let mut entries = self.entries.write().unwrap();
        entries.remove(&amp;path);

        drop(entries);
        self.flush()?;

        Ok(())
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Can't remove root
        if path.to_string_lossy() == "/" {
            return Err(FsError::PermissionDenied {
                path,
                operation: "remove root directory"
            });
        }

        let mut entries = self.entries.write().unwrap();

        // Verify it exists and is a directory
        let entry = entries.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if !entry.is_dir {
            return Err(FsError::NotADirectory { path: path.clone() });
        }

        // Remove all entries under this path
        let to_remove: Vec&lt;_&gt; = entries.keys()
            .filter(|p| p.starts_with(&amp;path))
            .cloned()
            .collect();

        for p in to_remove {
            entries.remove(&amp;p);
        }

        drop(entries);
        self.flush()?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-6-putting-it-all-together"><a class="header" href="#step-6-putting-it-all-together">Step 6: Putting It All Together</a></h2>
<p>Now you have a complete <code>Fs</code> implementation! Let’s use it:</p>
<pre class="playground"><code class="language-rust">use anyfs::{FileStorage, QuotaLayer, TracingLayer};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create our glorious TXT filesystem
    let backend = TxtBackend::open("my_filesystem.txt")?
        // Wrap it with middleware to prevent the file from exploding
        .layer(QuotaLayer::builder()
            .max_total_size(10 * 1024 * 1024)  // 10 MB max
            .max_file_size(1 * 1024 * 1024)    // 1 MB per file
            .build())
        // Add tracing because why not
        .layer(TracingLayer::new());

    // Create the filesystem wrapper
    let fs = FileStorage::new(backend);

    // Use it like any other filesystem!
    fs.create_dir_all("/projects/secret")?;
    fs.write("/projects/secret/plans.txt", b"World domination via TXT")?;
    fs.write("/projects/readme.md", b"# My TXT-backed project\n\nYes, really.")?;

    // Read it back
    let content = fs.read_to_string("/projects/secret/plans.txt")?;
    println!("Plans: {}", content);

    // List directory
    for entry in fs.read_dir("/projects")? {
        println!("  {} ({})", entry.name,
            if entry.file_type == FileType::Directory { "dir" } else { "file" });
    }

    // Copy a file
    fs.copy("/projects/readme.md", "/projects/readme_backup.md")?;

    // Delete a file
    fs.remove_file("/projects/readme_backup.md")?;

    println!("\nNow open my_filesystem.txt in Notepad!");

    Ok(())
}</code></pre>
<hr>
<h2 id="the-result"><a class="header" href="#the-result">The Result</a></h2>
<p>After running the code, your <code>my_filesystem.txt</code> looks like:</p>
<pre><code>path,type,mode,data
/,dir,755,
/projects,dir,755,
/projects/secret,dir,755,
/projects/secret/plans.txt,file,644,V29ybGQgZG9taW5hdGlvbiB2aWEgVFhU
/projects/readme.md,file,644,IyBNeSBUWFQtYmFja2VkIHByb2plY3QKCllzLCByZWFsbHku
</code></pre>
<p>Open it in Notepad. Marvel at your filesystem. Edit a line. Save. You just modified a file.</p>
<hr>
<h2 id="why-this-actually-matters"><a class="header" href="#why-this-actually-matters">Why This Actually Matters</a></h2>
<p>This ridiculous example demonstrates the power of AnyFS’s design:</p>
<ol>
<li>
<p><strong>True backend abstraction</strong> - The <code>FileStorage</code> API doesn’t know or care that it’s backed by a text file</p>
</li>
<li>
<p><strong>Middleware just works</strong> - <code>Quota</code> and <code>Tracing</code> wrap your custom backend with zero extra code</p>
</li>
<li>
<p><strong>Type safety preserved</strong> - Compile-time guarantees work with any backend</p>
</li>
<li>
<p><strong>Easy to implement</strong> - ~250 lines for a complete working backend</p>
</li>
<li>
<p><strong>Testable</strong> - Use <code>TxtBackend::in_memory()</code> for fast tests</p>
</li>
<li>
<p><strong>Human-editable</strong> - Open in Notepad, add a line, you created a file</p>
</li>
</ol>
<hr>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>If you’re feeling brave:</p>
<ol>
<li><strong>Add symlink support</strong> - Implement <code>FsLink</code> trait</li>
<li><strong>Make it async</strong> - Wrap with <code>tokio::fs</code> for the host CSV file</li>
<li><strong>Add compression</strong> - Gzip the base64 content</li>
<li><strong>Excel integration</strong> - Add formulas that compute file sizes (why not?)</li>
</ol>
<hr>
<h2 id="bonus-mount-it-as-a-drive"><a class="header" href="#bonus-mount-it-as-a-drive">Bonus: Mount It as a Drive</a></h2>
<p>With the <code>fuse</code> feature enabled, you can mount your text file as a real filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MountHandle;

let backend = TxtBackend::open("filesystem.txt")?;
let mount = MountHandle::mount(backend, "/mnt/txt")?;

// Now /mnt/txt is a real mount point backed by a .txt file
// Any application can read/write files there
// The data goes into a text file you can edit in Notepad
// This is fine
<span class="boring">}</span></code></pre>
<hr>
<h2 id="the-moral"><a class="header" href="#the-moral">The Moral</a></h2>
<p>AnyFS doesn’t care where bytes come from or where they go. Memory, SQLite, a text file, a REST API, carrier pigeons with USB drives - if you can implement the traits, it’s a valid backend.</p>
<p>The middleware layer (quotas, sandboxing, rate limiting, logging) works transparently on any backend. That’s the power of good abstractions.</p>
<p>Now go build something less cursed. Or don’t. I’m not your supervisor.</p>
<hr>
<p><em>“I store my production data in text files” - Nobody, ever (until now)</em></p>
<p><em>“Can I edit my filesystem in Notepad?” - Yes. Yes you can.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-building-your-first-middleware"><a class="header" href="#tutorial-building-your-first-middleware">Tutorial: Building Your First Middleware</a></h1>
<p><strong>From zero to intercepting filesystem operations in 15 minutes</strong></p>
<hr>
<h2 id="what-is-middleware"><a class="header" href="#what-is-middleware">What is Middleware?</a></h2>
<p>Middleware wraps a backend and intercepts operations. That’s it.</p>
<pre><code>User Request → [Your Middleware] → [Backend] → Storage
              ↑                  ↓
              └── intercept ─────┘
</code></pre>
<p>You can:</p>
<ul>
<li><strong>Block</strong> operations (ReadOnly, PathFilter)</li>
<li><strong>Transform</strong> data (Encryption, Compression)</li>
<li><strong>Count/Log</strong> operations (Counter, Tracing)</li>
<li><strong>Enforce limits</strong> (Quota, RateLimit)</li>
</ul>
<p>Let’s build one.</p>
<hr>
<h2 id="the-simplest-middleware-operation-counter"><a class="header" href="#the-simplest-middleware-operation-counter">The Simplest Middleware: Operation Counter</a></h2>
<p>We’ll count every operation. That’s our entire goal.</p>
<h3 id="step-1-the-struct"><a class="header" href="#step-1-the-struct">Step 1: The Struct</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU64, Ordering};

/// Counts every operation performed on the wrapped backend.
pub struct Counter&lt;B&gt; {
    inner: B,                    // The backend we're wrapping
    pub count: AtomicU64,        // Our counter
}

impl&lt;B&gt; Counter&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self {
            inner,
            count: AtomicU64::new(0),
        }
    }

    pub fn operations(&amp;self) -&gt; u64 {
        self.count.load(Ordering::Relaxed)
    }
}
<span class="boring">}</span></code></pre>
<p>That’s the entire struct. We wrap something (<code>inner</code>) and add our state (<code>count</code>).</p>
<h3 id="step-2-implement-fsread"><a class="header" href="#step-2-implement-fsread">Step 2: Implement FsRead</a></h3>
<p>Now we implement the same traits as the inner backend, intercepting each method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsError, Metadata};
use std::path::Path;

impl&lt;B: FsRead&gt; FsRead for Counter&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);  // COUNT IT
        self.inner.read(path)                         // DELEGATE
    }

    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.read_to_string(path)
    }

    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.read_range(path, offset, len)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.exists(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.metadata(path)
    }

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Read + Send&gt;, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.open_read(path)
    }
}
<span class="boring">}</span></code></pre>
<p>The pattern is always the same:</p>
<ol>
<li>Do your thing (count)</li>
<li>Call <code>self.inner.method(args)</code> (delegate)</li>
</ol>
<h3 id="step-3-implement-fswrite"><a class="header" href="#step-3-implement-fswrite">Step 3: Implement FsWrite</a></h3>
<p>Same pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsWrite;

impl&lt;B: FsWrite&gt; FsWrite for Counter&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.write(path, data)
    }

    fn append(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.append(path, data)
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.remove_file(path)
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.rename(from, to)
    }

    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.copy(from, to)
    }

    fn truncate(&amp;self, path: &amp;Path, size: u64) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.truncate(path, size)
    }

    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Write + Send&gt;, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.open_write(path)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="step-4-implement-fsdir"><a class="header" href="#step-4-implement-fsdir">Step 4: Implement FsDir</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsDir, ReadDirIter};

impl&lt;B: FsDir&gt; FsDir for Counter&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.create_dir(path)
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.create_dir_all(path)
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.remove_dir(path)
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.remove_dir_all(path)
    }
}

// Counter&lt;B&gt; now implements Fs when B: Fs (blanket impl)!
<span class="boring">}</span></code></pre>
<h3 id="step-5-use-it"><a class="header" href="#step-5-use-it">Step 5: Use It</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::{FileStorage, MemoryBackend};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fs = FileStorage::new(Counter::new(MemoryBackend::new()));

    fs.write("/hello.txt", b"Hello, World!")?;
    fs.read("/hello.txt")?;
    fs.read("/hello.txt")?;
    fs.exists("/hello.txt")?;

    println!("Total operations: {}", fs.operations());  // 4

    Ok(())
}</code></pre>
<p><strong>That’s it.</strong> You built middleware.</p>
<hr>
<h2 id="adding-layer-support"><a class="header" href="#adding-layer-support">Adding .layer() Support</a></h2>
<p>Want the fluent <code>.layer()</code> syntax? Add a Layer struct:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Layer, Fs};

/// Layer for creating Counter middleware.
pub struct CounterLayer;

impl&lt;B: Fs&gt; Layer&lt;B&gt; for CounterLayer {
    type Backend = Counter&lt;B&gt;;

    fn layer(self, backend: B) -&gt; Counter&lt;B&gt; {
        Counter::new(backend)
    }
}
<span class="boring">}</span></code></pre>
<p>Now you can do:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::FileStorage;

let fs = FileStorage::new(
    MemoryBackend::new()
        .layer(CounterLayer)
);

fs.write("/test.txt", b"data")?;
println!("Operations: {}", fs.operations());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="a-more-useful-middleware-secretblocker"><a class="header" href="#a-more-useful-middleware-secretblocker">A More Useful Middleware: SecretBlocker</a></h2>
<p>Let’s build something practical - block access to files matching a pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter};
use std::path::Path;

/// Blocks access to files containing "secret" in the path.
pub struct SecretBlocker&lt;B&gt; {
    inner: B,
}

impl&lt;B&gt; SecretBlocker&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner }
    }

    /// Check if path is forbidden.
    fn is_secret(&amp;self, path: &amp;Path) -&gt; bool {
        path.to_string_lossy().to_lowercase().contains("secret")
    }

    /// Return error if path is secret.
    fn check(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        if self.is_secret(path) {
            Err(FsError::AccessDenied {
                path: path.to_path_buf(),
                reason: "secret files are blocked".to_string(),
            })
        } else {
            Ok(())
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="implement-the-traits"><a class="header" href="#implement-the-traits">Implement the Traits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for SecretBlocker&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;           // BLOCK if secret
        self.inner.read(path)        // DELEGATE otherwise
    }

    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.read_to_string(path)
    }

    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.read_range(path, offset, len)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.exists(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.metadata(path)
    }

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Read + Send&gt;, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.open_read(path)
    }
}

impl&lt;B: FsWrite&gt; FsWrite for SecretBlocker&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.write(path, data)
    }

    fn append(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.append(path, data)
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.remove_file(path)
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let from = from.as_ref();
        let to = to.as_ref();
        self.check(from)?;
        self.check(to)?;  // Block both source and destination
        self.inner.rename(from, to)
    }

    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let from = from.as_ref();
        let to = to.as_ref();
        self.check(from)?;
        self.check(to)?;
        self.inner.copy(from, to)
    }

    fn truncate(&amp;self, path: &amp;Path, size: u64) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.truncate(path, size)
    }

    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Write + Send&gt;, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.open_write(path)
    }
}

impl&lt;B: FsDir&gt; FsDir for SecretBlocker&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.create_dir(path)
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.create_dir_all(path)
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.remove_dir(path)
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.check(path)?;
        self.inner.remove_dir_all(path)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="use-it"><a class="header" href="#use-it">Use It</a></h3>
<pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fs = FileStorage::new(SecretBlocker::new(MemoryBackend::new()));

    // These work fine
    fs.write("/public/data.txt", b"Hello!")?;
    fs.read("/public/data.txt")?;

    // These are blocked
    assert!(fs.write("/secret/passwords.txt", b"hunter2").is_err());
    assert!(fs.read("/my-secret-diary.txt").is_err());
    assert!(fs.create_dir("/SECRET").is_err());

    println!("Secret files successfully blocked!");
    Ok(())
}</code></pre>
<hr>
<h2 id="the-middleware-pattern-cheat-sheet"><a class="header" href="#the-middleware-pattern-cheat-sheet">The Middleware Pattern Cheat Sheet</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>What You Want</th><th>Intercept</th><th>Delegate</th><th>Return</th></tr>
</thead>
<tbody>
<tr><td>Count operations</td><td>Before call</td><td>Always</td><td>Inner result</td></tr>
<tr><td>Block some paths</td><td>Before call</td><td>If allowed</td><td>Error or inner result</td></tr>
<tr><td>Block writes</td><td>Write methods</td><td>Read methods</td><td>Error or inner result</td></tr>
<tr><td>Transform data</td><td>read/write</td><td>Everything else</td><td>Modified data</td></tr>
<tr><td>Log operations</td><td>Before/after</td><td>Always</td><td>Inner result</td></tr>
</tbody>
</table>
</div>
<h3 id="three-types-of-middleware"><a class="header" href="#three-types-of-middleware">Three Types of Middleware</a></h3>
<p><strong>1. Pass-through with side effects</strong> (Counter, Logger)</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
    log::info!("Reading: {:?}", path.as_ref());  // Side effect
    self.inner.read(path)                         // Always delegate
}
<span class="boring">}</span></code></pre>
<p><strong>2. Conditional blocking</strong> (PathFilter, ReadOnly)</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
    if self.is_blocked(path.as_ref()) {
        return Err(FsError::AccessDenied { ... });  // Block
    }
    self.inner.write(path, data)                    // Allow
}
<span class="boring">}</span></code></pre>
<p><strong>3. Data transformation</strong> (Encryption, Compression)</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
    let encrypted = self.inner.read(path)?;  // Get data
    Ok(self.decrypt(&amp;encrypted))              // Transform
}

fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
    let encrypted = self.encrypt(data);       // Transform
    self.inner.write(path, &amp;encrypted)        // Store
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="example-indexing-middleware-future"><a class="header" href="#example-indexing-middleware-future">Example: Indexing Middleware (Future)</a></h2>
<p>Use <code>IndexLayer</code> to keep a queryable index of file activity:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{IndexLayer, FileStorage, MemoryBackend};

let backend = MemoryBackend::new()
    .layer(IndexLayer::builder()
        .index_file("index.db")
        .consistency(IndexConsistency::Strict)
        .track_reads(false)
        .build());

let fs = FileStorage::new(backend);
fs.write("/docs/hello.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="complete-example-readonly-middleware"><a class="header" href="#complete-example-readonly-middleware">Complete Example: ReadOnly Middleware</a></h2>
<p>The classic - block all writes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter, Layer, Fs};
use std::path::Path;

/// Makes any backend read-only.
pub struct ReadOnly&lt;B&gt; {
    inner: B,
}

impl&lt;B&gt; ReadOnly&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner }
    }
}

// FsRead: delegate everything
impl&lt;B: FsRead&gt; FsRead for ReadOnly&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read(path)
    }

    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt; {
        self.inner.read_to_string(path)
    }

    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read_range(path, offset, len)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        self.inner.exists(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Read + Send&gt;, FsError&gt; {
        self.inner.open_read(path)
    }
}

// FsWrite: block everything
impl&lt;B: FsWrite&gt; FsWrite for ReadOnly&lt;B&gt; {
    fn write(&amp;self, _: &amp;Path, _: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "write" })
    }

    fn append(&amp;self, _: &amp;Path, _: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "append" })
    }

    fn remove_file(&amp;self, _: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_file" })
    }

    fn rename(&amp;self, _: &amp;Path, _: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "rename" })
    }

    fn copy(&amp;self, _: &amp;Path, _: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "copy" })
    }

    fn truncate(&amp;self, _: &amp;Path, _: u64) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "truncate" })
    }

    fn open_write(&amp;self, _: &amp;Path) -&gt; Result&lt;Box&lt;dyn std::io::Write + Send&gt;, FsError&gt; {
        Err(FsError::ReadOnly { operation: "open_write" })
    }
}

// FsDir: delegate reads, block writes
impl&lt;B: FsDir&gt; FsDir for ReadOnly&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)  // Reading is OK
    }

    fn create_dir(&amp;self, _: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir" })
    }

    fn create_dir_all(&amp;self, _: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir_all" })
    }

    fn remove_dir(&amp;self, _: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir" })
    }

    fn remove_dir_all(&amp;self, _: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir_all" })
    }
}

// Layer for .layer() syntax
pub struct ReadOnlyLayer;

impl&lt;B: Fs&gt; Layer&lt;B&gt; for ReadOnlyLayer {
    type Backend = ReadOnly&lt;B&gt;;

    fn layer(self, backend: B) -&gt; Self::Backend {
        ReadOnly::new(backend)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = FileStorage::new(
    MemoryBackend::new()
        .layer(ReadOnlyLayer)
);

// Reads work
fs.exists("/anything")?;

// Writes fail
assert!(fs.write("/file.txt", b"data").is_err());
assert!(fs.create_dir("/new").is_err());
<span class="boring">}</span></code></pre>
<hr>
<h2 id="stacking-middleware"><a class="header" href="#stacking-middleware">Stacking Middleware</a></h2>
<p>Middleware composes naturally:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = MemoryBackend::new()
    .layer(SecretBlockerLayer)      // Block secret files
    .layer(ReadOnlyLayer)           // Make read-only
    .layer(CounterLayer);           // Count operations

// Layers wrap from inside out. For a request:
// Counter (outermost) → ReadOnly → SecretBlocker → MemoryBackend (innermost)
// The innermost middleware (closest to backend) applies first to the actual operation.
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware-checklist"><a class="header" href="#middleware-checklist">Middleware Checklist</a></h2>
<p>Before publishing your middleware:</p>
<ul>
<li><input disabled="" type="checkbox"> Depends only on <code>anyfs-backend</code></li>
<li><input disabled="" type="checkbox"> Implements same traits as inner backend (<code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code>)</li>
<li><input disabled="" type="checkbox"> Has a <code>Layer</code> implementation for <code>.layer()</code> syntax</li>
<li><input disabled="" type="checkbox"> Documents which operations are intercepted vs delegated</li>
<li><input disabled="" type="checkbox"> Handles errors properly (doesn’t panic)</li>
<li><input disabled="" type="checkbox"> Is thread-safe (<code>&amp;self</code> methods, use atomics/locks for state)</li>
</ul>
<hr>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p><strong>Middleware is just:</strong></p>
<ol>
<li>A struct wrapping <code>inner: B</code></li>
<li>Implementing the same traits as <code>B</code></li>
<li>Intercepting some methods, delegating others</li>
</ol>
<p><strong>The three patterns:</strong></p>
<ol>
<li><strong>Side effects:</strong> Do something, then delegate</li>
<li><strong>Blocking:</strong> Check condition, return error or delegate</li>
<li><strong>Transform:</strong> Modify data on the way in/out</li>
</ol>
<p><strong>That’s it.</strong> Go build something useful.</p>
<hr>
<p><em>“Middleware: because sometimes you need to do something between nothing and everything.”</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="remote-backend-patterns"><a class="header" href="#remote-backend-patterns">Remote Backend Patterns</a></h1>
<p><strong>Building networked filesystem backends and clients</strong></p>
<p>This guide covers patterns for exposing AnyFS backends over a network and building clients that mount remote filesystems.</p>
<hr>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>A remote filesystem has three components:</p>
<pre><code>┌─────────────┐      Network       ┌─────────────┐      ┌─────────────┐
│   Client    │ ←───────────────→  │   Server    │  ──→ │   Backend   │
│  (FUSE)     │     RPC/REST       │   (API)     │      │  (Storage)  │
└─────────────┘                    └─────────────┘      └─────────────┘
     User's                           Cloud               SQLite/CAS
     Machine                          Service             Hybrid/etc
</code></pre>
<p>AnyFS backends are local by design. To go remote, you need:</p>
<ol>
<li><strong>Server</strong>: Exposes backend operations over network</li>
<li><strong>Protocol</strong>: Wire format for requests/responses</li>
<li><strong>Client</strong>: Implements <code>Fs</code> traits by calling server</li>
</ol>
<hr>
<h2 id="protocol-design"><a class="header" href="#protocol-design">Protocol Design</a></h2>
<h3 id="operations-to-expose"><a class="header" href="#operations-to-expose">Operations to Expose</a></h3>
<p>Map <code>Fs</code> trait methods to RPC operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait Method</th><th>RPC Operation</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>read(path)</code></td><td><code>Read(path, range?)</code></td><td>Support partial reads</td></tr>
<tr><td><code>write(path, data)</code></td><td><code>Write(path, data)</code></td><td>Chunked for large files</td></tr>
<tr><td><code>exists(path)</code></td><td><code>Exists(path)</code></td><td>Or combine with Metadata</td></tr>
<tr><td><code>metadata(path)</code></td><td><code>Metadata(path)</code></td><td>Return full stat</td></tr>
<tr><td><code>read_dir(path)</code></td><td><code>ListDir(path, cursor?)</code></td><td>Paginated for large dirs</td></tr>
<tr><td><code>create_dir(path)</code></td><td><code>CreateDir(path)</code></td><td></td></tr>
<tr><td><code>create_dir_all(path)</code></td><td><code>CreateDirAll(path)</code></td><td>Or client-side loop</td></tr>
<tr><td><code>remove_file(path)</code></td><td><code>Remove(path)</code></td><td></td></tr>
<tr><td><code>remove_dir(path)</code></td><td><code>RemoveDir(path)</code></td><td></td></tr>
<tr><td><code>remove_dir_all(path)</code></td><td><code>RemoveDirAll(path)</code></td><td>Recursive</td></tr>
<tr><td><code>rename(from, to)</code></td><td><code>Rename(from, to)</code></td><td></td></tr>
<tr><td><code>copy(from, to)</code></td><td><code>Copy(from, to)</code></td><td>Server-side copy</td></tr>
</tbody>
</table>
</div>
<h3 id="requestresponse-format"><a class="header" href="#requestresponse-format">Request/Response Format</a></h3>
<p>Use a simple, efficient format. Here’s a protobuf-style schema:</p>
<pre><code class="language-protobuf">// requests.proto

message Request {
  string request_id = 1;  // For idempotency
  string auth_token = 2;  // Authentication

  oneof operation {
    ReadRequest read = 10;
    WriteRequest write = 11;
    MetadataRequest metadata = 12;
    ListDirRequest list_dir = 13;
    CreateDirRequest create_dir = 14;
    RemoveRequest remove = 15;
    RenameRequest rename = 16;
    CopyRequest copy = 17;
  }
}

message ReadRequest {
  string path = 1;
  optional uint64 offset = 2;
  optional uint64 length = 3;
}

message WriteRequest {
  string path = 1;
  bytes data = 2;
  bool append = 3;
}

message MetadataRequest {
  string path = 1;
}

message ListDirRequest {
  string path = 1;
  optional string cursor = 2;  // For pagination
  optional uint32 limit = 3;
}

// ... other requests

message Response {
  string request_id = 1;
  bool success = 2;

  oneof result {
    ErrorResult error = 10;
    ReadResult read = 11;
    WriteResult write = 12;
    MetadataResult metadata = 13;
    ListDirResult list_dir = 14;
    // ... others return empty success
  }
}

message ErrorResult {
  string code = 1;    // "not_found", "permission_denied", etc.
  string message = 2;
  string path = 3;
}

message MetadataResult {
  string file_type = 1;  // "file", "dir", "symlink"
  uint64 size = 2;
  uint32 mode = 3;
  optional uint64 created_at = 4;
  optional uint64 modified_at = 5;
  optional uint64 inode = 6;
}

message ListDirResult {
  repeated DirEntry entries = 1;
  optional string next_cursor = 2;  // Null if no more
}

message DirEntry {
  string name = 1;
  string file_type = 2;
  uint64 size = 3;
}
</code></pre>
<h3 id="protocol-choices"><a class="header" href="#protocol-choices">Protocol Choices</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Protocol</th><th>Pros</th><th>Cons</th><th>Use When</th></tr>
</thead>
<tbody>
<tr><td><strong>gRPC</strong></td><td>Fast, typed, streaming</td><td>Complex setup</td><td>High performance</td></tr>
<tr><td><strong>REST/JSON</strong></td><td>Simple, debuggable</td><td>Slower, no streaming</td><td>Compatibility</td></tr>
<tr><td><strong>WebSocket</strong></td><td>Bidirectional, real-time</td><td>More complex</td><td>Live updates</td></tr>
<tr><td><strong>Custom TCP</strong></td><td>Maximum control</td><td>Build everything</td><td>Special needs</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> Start with gRPC (tonic in Rust). Fall back to REST for web clients.</p>
<hr>
<h2 id="server-implementation"><a class="header" href="#server-implementation">Server Implementation</a></h2>
<h3 id="basic-server-structure"><a class="header" href="#basic-server-structure">Basic Server Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tonic::{transport::Server, Request, Response, Status};
use anyfs_backend::Fs;
use anyfs::FileStorage;

pub struct FsServer&lt;B: Fs&gt; {
    backend: FileStorage&lt;B&gt;,
}

impl&lt;B: Fs + Send + Sync + 'static&gt; FsServer&lt;B&gt; {
    pub fn new(backend: B) -&gt; Self {
        Self { backend: FileStorage::new(backend) }
    }

    pub async fn serve(self, addr: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let addr = addr.parse()?;

        Server::builder()
            .add_service(FsServiceServer::new(self))
            .serve(addr)
            .await?;

        Ok(())
    }
}

#[tonic::async_trait]
impl&lt;B: Fs + Send + Sync + 'static&gt; FsService for FsServer&lt;B&gt; {
    async fn read(
        &amp;self,
        request: Request&lt;ReadRequest&gt;,
    ) -&gt; Result&lt;Response&lt;ReadResponse&gt;, Status&gt; {
        let req = request.into_inner();

        let data = match req.length {
            Some(len) =&gt; self.backend.read_range(&amp;req.path, req.offset.unwrap_or(0), len as usize),
            None =&gt; self.backend.read(&amp;req.path),
        };

        match data {
            Ok(bytes) =&gt; Ok(Response::new(ReadResponse {
                data: bytes,
                success: true,
                error: None,
            })),
            Err(e) =&gt; Ok(Response::new(ReadResponse {
                data: vec![],
                success: false,
                error: Some(fs_error_to_proto(e)),
            })),
        }
    }

    async fn write(
        &amp;self,
        request: Request&lt;WriteRequest&gt;,
    ) -&gt; Result&lt;Response&lt;WriteResponse&gt;, Status&gt; {
        let req = request.into_inner();

        let result = if req.append {
            self.backend.append(&amp;req.path, &amp;req.data)
        } else {
            self.backend.write(&amp;req.path, &amp;req.data)
        };

        match result {
            Ok(()) =&gt; Ok(Response::new(WriteResponse {
                success: true,
                error: None,
            })),
            Err(e) =&gt; Ok(Response::new(WriteResponse {
                success: false,
                error: Some(fs_error_to_proto(e)),
            })),
        }
    }

    // ... implement other methods
}

fn fs_error_to_proto(e: FsError) -&gt; ProtoError {
    match e {
        FsError::NotFound { path } =&gt; ProtoError {
            code: "not_found".into(),
            message: "File not found".into(),
            path: path.to_string_lossy().into(),
        },
        FsError::AlreadyExists { path, .. } =&gt; ProtoError {
            code: "already_exists".into(),
            message: "File already exists".into(),
            path: path.to_string_lossy().into(),
        },
        // ... map other errors
        _ =&gt; ProtoError {
            code: "internal".into(),
            message: e.to_string(),
            path: String::new(),
        },
    }
}
<span class="boring">}</span></code></pre>
<h3 id="authentication-middleware"><a class="header" href="#authentication-middleware">Authentication Middleware</a></h3>
<p>Add authentication as a tower layer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tonic::service::Interceptor;

#[derive(Clone)]
pub struct AuthInterceptor {
    valid_tokens: Arc&lt;HashSet&lt;String&gt;&gt;,
}

impl Interceptor for AuthInterceptor {
    fn call(&amp;mut self, mut request: Request&lt;()&gt;) -&gt; Result&lt;Request&lt;()&gt;, Status&gt; {
        let token = request
            .metadata()
            .get("authorization")
            .and_then(|v| v.to_str().ok())
            .map(|s| s.trim_start_matches("Bearer "));

        match token {
            Some(t) if self.valid_tokens.contains(t) =&gt; Ok(request),
            _ =&gt; Err(Status::unauthenticated("Invalid or missing token")),
        }
    }
}

// Usage
Server::builder()
    .add_service(FsServiceServer::with_interceptor(fs_server, auth_interceptor))
    .serve(addr)
    .await?;
<span class="boring">}</span></code></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<p>Protect against abuse:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use governor::{Quota, RateLimiter};
use std::num::NonZeroU32;

pub struct RateLimitedServer&lt;B: Fs&gt; {
    inner: FsServer&lt;B&gt;,
    limiter: RateLimiter&lt;String&gt;,  // Per-user rate limiter
}

impl&lt;B: Fs&gt; RateLimitedServer&lt;B&gt; {
    pub fn new(backend: B, requests_per_second: u32) -&gt; Self {
        let quota = Quota::per_second(NonZeroU32::new(requests_per_second).unwrap());
        Self {
            inner: FsServer::new(backend),
            limiter: RateLimiter::keyed(quota),
        }
    }

    async fn check_rate_limit(&amp;self, user_id: &amp;str) -&gt; Result&lt;(), Status&gt; {
        self.limiter
            .check_key(&amp;user_id.to_string())
            .map_err(|_| Status::resource_exhausted("Rate limit exceeded"))?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="idempotency"><a class="header" href="#idempotency">Idempotency</a></h3>
<p>Handle retried requests safely:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::time::{Duration, Instant};

pub struct IdempotencyCache {
    cache: RwLock&lt;HashMap&lt;String, (Instant, Response)&gt;&gt;,
    ttl: Duration,
}

impl IdempotencyCache {
    pub fn new(ttl: Duration) -&gt; Self {
        Self {
            cache: RwLock::new(HashMap::new()),
            ttl,
        }
    }

    /// Check if we've seen this request before.
    pub fn get(&amp;self, request_id: &amp;str) -&gt; Option&lt;Response&gt; {
        let cache = self.cache.read().unwrap();
        cache.get(request_id)
            .filter(|(ts, _)| ts.elapsed() &lt; self.ttl)
            .map(|(_, resp)| resp.clone())
    }

    /// Store response for future duplicate requests.
    pub fn put(&amp;self, request_id: String, response: Response) {
        let mut cache = self.cache.write().unwrap();
        cache.insert(request_id, (Instant::now(), response));
    }

    /// Clean up expired entries (call periodically).
    pub fn cleanup(&amp;self) {
        let mut cache = self.cache.write().unwrap();
        cache.retain(|_, (ts, _)| ts.elapsed() &lt; self.ttl);
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="client-implementation"><a class="header" href="#client-implementation">Client Implementation</a></h2>
<h3 id="remote-backend-client-side"><a class="header" href="#remote-backend-client-side">Remote Backend (Client-Side)</a></h3>
<p>The client implements <code>Fs</code> traits by making RPC calls:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter, DirEntry};
use std::path::Path;

pub struct RemoteBackend {
    client: FsServiceClient&lt;tonic::transport::Channel&gt;,
    auth_token: String,
}

impl RemoteBackend {
    pub async fn connect(addr: &amp;str, auth_token: String) -&gt; Result&lt;Self, FsError&gt; {
        let client = FsServiceClient::connect(addr.to_string())
            .await
            .map_err(|e| FsError::Backend(format!("connect failed: {}", e)))?;

        Ok(Self { client, auth_token })
    }

    fn request&lt;T&gt;(&amp;self, req: T) -&gt; tonic::Request&lt;T&gt; {
        let mut request = tonic::Request::new(req);
        request.metadata_mut().insert(
            "authorization",
            format!("Bearer {}", self.auth_token).parse().unwrap(),
        );
        request
    }
}

impl FsRead for RemoteBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Note: This is sync, but we're calling async code
        // In practice, use tokio::runtime::Handle or async traits

        let rt = tokio::runtime::Handle::current();
        rt.block_on(async {
            let req = self.request(ReadRequest {
                path: path.as_ref().to_string_lossy().into(),
                offset: None,
                length: None,
            });

            let response = self.client.clone().read(req)
                .await
                .map_err(|e| FsError::Backend(format!("rpc failed: {}", e)))?
                .into_inner();

            if response.success {
                Ok(response.data)
            } else {
                Err(proto_error_to_fs(response.error.unwrap()))
            }
        })
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        // Could be a dedicated RPC or use metadata
        match self.metadata(path) {
            Ok(_) =&gt; Ok(true),
            Err(FsError::NotFound { .. }) =&gt; Ok(false),
            Err(e) =&gt; Err(e),
        }
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let rt = tokio::runtime::Handle::current();
        rt.block_on(async {
            let req = self.request(MetadataRequest {
                path: path.as_ref().to_string_lossy().into(),
            });

            let response = self.client.clone().metadata(req)
                .await
                .map_err(|e| FsError::Backend(format!("rpc failed: {}", e)))?
                .into_inner();

            if response.success {
                Ok(proto_metadata_to_fs(response.metadata.unwrap()))
            } else {
                Err(proto_error_to_fs(response.error.unwrap()))
            }
        })
    }

    // ... other methods
}

impl FsWrite for RemoteBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let rt = tokio::runtime::Handle::current();
        rt.block_on(async {
            let req = self.request(WriteRequest {
                path: path.as_ref().to_string_lossy().into(),
                data: data.to_vec(),
                append: false,
            });

            let response = self.client.clone().write(req)
                .await
                .map_err(|e| FsError::Backend(format!("rpc failed: {}", e)))?
                .into_inner();

            if response.success {
                Ok(())
            } else {
                Err(proto_error_to_fs(response.error.unwrap()))
            }
        })
    }

    // ... other methods
}

impl FsDir for RemoteBackend {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        let rt = tokio::runtime::Handle::current();
        rt.block_on(async {
            let mut all_entries = Vec::new();
            let mut cursor = None;

            // Paginate through all results
            loop {
                let req = self.request(ListDirRequest {
                    path: path.as_ref().to_string_lossy().into(),
                    cursor: cursor.clone(),
                    limit: Some(1000),
                });

                let response = self.client.clone().list_dir(req)
                    .await
                    .map_err(|e| FsError::Backend(format!("rpc failed: {}", e)))?
                    .into_inner();

                if !response.success {
                    return Err(proto_error_to_fs(response.error.unwrap()));
                }

                all_entries.extend(response.entries.into_iter().map(proto_entry_to_fs));

                match response.next_cursor {
                    Some(c) =&gt; cursor = Some(c),
                    None =&gt; break,
                }
            }

            Ok(ReadDirIter::new(all_entries.into_iter().map(Ok)))
        })
    }

    // ... other methods
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="caching-layer"><a class="header" href="#caching-layer">Caching Layer</a></h2>
<p>Network calls are slow. Add caching:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::RwLock;
use std::time::{Duration, Instant};

/// Client-side cache for remote filesystem.
pub struct CachingBackend&lt;B&gt; {
    inner: B,
    metadata_cache: RwLock&lt;HashMap&lt;PathBuf, (Instant, Metadata)&gt;&gt;,
    content_cache: RwLock&lt;LruCache&lt;PathBuf, Vec&lt;u8&gt;&gt;&gt;,
    metadata_ttl: Duration,
    max_cached_file_size: u64,
}

impl&lt;B&gt; CachingBackend&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self {
            inner,
            metadata_cache: RwLock::new(HashMap::new()),
            content_cache: RwLock::new(LruCache::new(100)),  // 100 files
            metadata_ttl: Duration::from_secs(5),
            max_cached_file_size: 1024 * 1024,  // 1 MB
        }
    }

    /// Invalidate cache for a path (call after writes).
    pub fn invalidate(&amp;self, path: &amp;Path) {
        self.metadata_cache.write().unwrap().remove(path);
        self.content_cache.write().unwrap().pop(path);
    }

    /// Invalidate everything under a directory.
    pub fn invalidate_prefix(&amp;self, prefix: &amp;Path) {
        let mut meta = self.metadata_cache.write().unwrap();
        let mut content = self.content_cache.write().unwrap();

        meta.retain(|k, _| !k.starts_with(prefix));
        // LruCache doesn't have retain, so we'd need a different structure
    }
}

impl&lt;B: FsRead&gt; FsRead for CachingBackend&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();

        // Check cache first
        if let Some(data) = self.content_cache.read().unwrap().peek(path) {
            return Ok(data.clone());
        }

        // Cache miss - fetch from remote
        let data = self.inner.read(path)?;

        // Cache if small enough
        if data.len() as u64 &lt;= self.max_cached_file_size {
            self.content_cache.write().unwrap().put(path.to_path_buf(), data.clone());
        }

        Ok(data)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = path.as_ref();

        // Check cache
        {
            let cache = self.metadata_cache.read().unwrap();
            if let Some((ts, meta)) = cache.get(path) {
                if ts.elapsed() &lt; self.metadata_ttl {
                    return Ok(meta.clone());
                }
            }
        }

        // Cache miss
        let meta = self.inner.metadata(path)?;

        // Store in cache
        self.metadata_cache.write().unwrap()
            .insert(path.to_path_buf(), (Instant::now(), meta.clone()));

        Ok(meta)
    }

    // ... other methods
}

impl&lt;B: FsWrite&gt; FsWrite for CachingBackend&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();

        // Write through to remote
        self.inner.write(path, data)?;

        // Invalidate cache
        self.invalidate(path);

        Ok(())
    }

    // ... other methods - all invalidate cache after modifying
}
<span class="boring">}</span></code></pre>
<h3 id="cache-invalidation-strategies"><a class="header" href="#cache-invalidation-strategies">Cache Invalidation Strategies</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>How</th><th>When to Use</th></tr>
</thead>
<tbody>
<tr><td><strong>TTL</strong></td><td>Expire after N seconds</td><td>Read-heavy, eventual consistency OK</td></tr>
<tr><td><strong>Write-through</strong></td><td>Invalidate on local write</td><td>Single client</td></tr>
<tr><td><strong>Server push</strong></td><td>WebSocket notifications</td><td>Real-time consistency</td></tr>
<tr><td><strong>Version/ETag</strong></td><td>Check version on read</td><td>Balance of consistency/perf</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="offline-mode"><a class="header" href="#offline-mode">Offline Mode</a></h2>
<p>Handle network failures gracefully:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::FileStorage;

pub struct OfflineCapableBackend&lt;B&gt; {
    remote: FileStorage&lt;B&gt;,
    local_cache: SqliteBackend,  // Local SQLite for offline ops
    mode: RwLock&lt;ConnectionMode&gt;,
    pending_writes: RwLock&lt;Vec&lt;PendingWrite&gt;&gt;,
}

#[derive(Clone, Copy)]
enum ConnectionMode {
    Online,
    Offline,
    Reconnecting,
}

struct PendingWrite {
    path: PathBuf,
    operation: WriteOperation,
    timestamp: Instant,
}

enum WriteOperation {
    Write(Vec&lt;u8&gt;),
    Append(Vec&lt;u8&gt;),
    Remove,
    CreateDir,
    // ...
}

impl&lt;B: Fs&gt; OfflineCapableBackend&lt;B&gt; {
    fn is_online(&amp;self) -&gt; bool {
        matches!(*self.mode.read().unwrap(), ConnectionMode::Online)
    }

    fn go_offline(&amp;self) {
        *self.mode.write().unwrap() = ConnectionMode::Offline;
    }

    fn try_reconnect(&amp;self) -&gt; bool {
        *self.mode.write().unwrap() = ConnectionMode::Reconnecting;

        // Try a simple operation
        if self.remote.exists("/").is_ok() {
            *self.mode.write().unwrap() = ConnectionMode::Online;
            self.sync_pending_writes();
            true
        } else {
            *self.mode.write().unwrap() = ConnectionMode::Offline;
            false
        }
    }

    fn sync_pending_writes(&amp;self) {
        let mut pending = self.pending_writes.write().unwrap();

        for write in pending.drain(..) {
            let result = match write.operation {
                WriteOperation::Write(data) =&gt; self.remote.write(&amp;write.path, &amp;data),
                WriteOperation::Append(data) =&gt; self.remote.append(&amp;write.path, &amp;data),
                WriteOperation::Remove =&gt; self.remote.remove_file(&amp;write.path),
                WriteOperation::CreateDir =&gt; self.remote.create_dir(&amp;write.path),
            };

            if result.is_err() {
                // Put back and stop syncing
                // (In practice, need conflict resolution)
                break;
            }
        }
    }
}

impl&lt;B: FsRead&gt; FsRead for OfflineCapableBackend&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();

        if self.is_online() {
            match self.remote.read(path) {
                Ok(data) =&gt; {
                    // Update local cache
                    let _ = self.local_cache.write(path, &amp;data);
                    Ok(data)
                }
                Err(FsError::Backend(_)) =&gt; {
                    // Network error - go offline, try cache
                    self.go_offline();
                    self.local_cache.read(path)
                }
                Err(e) =&gt; Err(e),
            }
        } else {
            // Offline - use cache
            self.local_cache.read(path)
        }
    }
}

impl&lt;B: FsWrite&gt; FsWrite for OfflineCapableBackend&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();

        // Always write to local cache
        self.local_cache.write(path, data)?;

        if self.is_online() {
            match self.remote.write(path, data) {
                Ok(()) =&gt; Ok(()),
                Err(FsError::Backend(_)) =&gt; {
                    // Network error - queue for later
                    self.go_offline();
                    self.pending_writes.write().unwrap().push(PendingWrite {
                        path: path.to_path_buf(),
                        operation: WriteOperation::Write(data.to_vec()),
                        timestamp: Instant::now(),
                    });
                    Ok(())  // Return success - we wrote locally
                }
                Err(e) =&gt; Err(e),
            }
        } else {
            // Offline - queue for later sync
            self.pending_writes.write().unwrap().push(PendingWrite {
                path: path.to_path_buf(),
                operation: WriteOperation::Write(data.to_vec()),
                timestamp: Instant::now(),
            });
            Ok(())
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h3>
<p>When syncing offline writes, conflicts can occur:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ConflictResolution {
    /// Server version wins (discard local changes)
    ServerWins,
    /// Client version wins (overwrite server)
    ClientWins,
    /// Keep both (rename local to .conflict)
    KeepBoth,
    /// Ask user
    Manual,
}

fn resolve_conflict(
    path: &amp;str,
    local_data: &amp;[u8],
    server_data: &amp;[u8],
    strategy: ConflictResolution,
) -&gt; Result&lt;(), FsError&gt; {
    match strategy {
        ConflictResolution::ServerWins =&gt; {
            // Discard local, use server version
            Ok(())
        }
        ConflictResolution::ClientWins =&gt; {
            // Overwrite server with local
            remote.write(path, local_data)
        }
        ConflictResolution::KeepBoth =&gt; {
            // Rename local to path.conflict
            let conflict_path = format!("{}.conflict", path);
            remote.write(&amp;conflict_path, local_data)?;
            Ok(())
        }
        ConflictResolution::Manual =&gt; {
            Err(FsError::Conflict { path: path.to_path_buf() })
        }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="fuse-client"><a class="header" href="#fuse-client">FUSE Client</a></h2>
<p>Mount the remote filesystem locally using FUSE:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fuser::{Filesystem, MountOption, Request, ReplyData, ReplyEntry, ReplyAttr, ReplyDirectory};

pub struct RemoteFuse&lt;B: Fs&gt; {
    backend: B,
    // Inode management for FUSE
    inodes: RwLock&lt;BiMap&lt;u64, PathBuf&gt;&gt;,
    next_inode: AtomicU64,
}

impl&lt;B: Fs&gt; Filesystem for RemoteFuse&lt;B&gt; {
    fn lookup(&amp;mut self, _req: &amp;Request, parent: u64, name: &amp;OsStr, reply: ReplyEntry) {
        let parent_path = self.inode_to_path(parent);
        let path = parent_path.join(name);

        match self.backend.metadata(&amp;path) {
            Ok(meta) =&gt; {
                let inode = self.path_to_inode(&amp;path);
                let attr = metadata_to_fuse_attr(inode, &amp;meta);
                reply.entry(&amp;Duration::from_secs(1), &amp;attr, 0);
            }
            Err(_) =&gt; reply.error(libc::ENOENT),
        }
    }

    fn read(
        &amp;mut self,
        _req: &amp;Request,
        ino: u64,
        _fh: u64,
        offset: i64,
        size: u32,
        _flags: i32,
        _lock_owner: Option&lt;u64&gt;,
        reply: ReplyData,
    ) {
        let path = self.inode_to_path(ino);

        match self.backend.read_range(&amp;path, offset as u64, size as usize) {
            Ok(data) =&gt; reply.data(&amp;data),
            Err(_) =&gt; reply.error(libc::EIO),
        }
    }

    fn write(
        &amp;mut self,
        _req: &amp;Request,
        ino: u64,
        _fh: u64,
        offset: i64,
        data: &amp;[u8],
        _write_flags: u32,
        _flags: i32,
        _lock_owner: Option&lt;u64&gt;,
        reply: fuser::ReplyWrite,
    ) {
        let path = self.inode_to_path(ino);

        // For simplicity, read-modify-write
        // (Real impl would use open_write with seeking)
        match self.backend.read(&amp;path) {
            Ok(mut content) =&gt; {
                let offset = offset as usize;
                if offset &gt; content.len() {
                    content.resize(offset, 0);
                }
                if offset + data.len() &gt; content.len() {
                    content.resize(offset + data.len(), 0);
                }
                content[offset..offset + data.len()].copy_from_slice(data);

                match self.backend.write(&amp;path, &amp;content) {
                    Ok(()) =&gt; reply.written(data.len() as u32),
                    Err(_) =&gt; reply.error(libc::EIO),
                }
            }
            Err(_) =&gt; reply.error(libc::EIO),
        }
    }

    fn readdir(
        &amp;mut self,
        _req: &amp;Request,
        ino: u64,
        _fh: u64,
        offset: i64,
        mut reply: ReplyDirectory,
    ) {
        let path = self.inode_to_path(ino);

        match self.backend.read_dir(&amp;path) {
            Ok(entries) =&gt; {
                let entries: Vec&lt;_&gt; = entries.filter_map(|e| e.ok()).collect();

                for (i, entry) in entries.iter().enumerate().skip(offset as usize) {
                    let child_path = path.join(&amp;entry.name);
                    let child_inode = self.path_to_inode(&amp;child_path);
                    let file_type = match entry.file_type {
                        FileType::File =&gt; fuser::FileType::RegularFile,
                        FileType::Directory =&gt; fuser::FileType::Directory,
                        FileType::Symlink =&gt; fuser::FileType::Symlink,
                    };

                    if reply.add(child_inode, (i + 1) as i64, file_type, &amp;entry.name) {
                        break;  // Buffer full
                    }
                }
                reply.ok();
            }
            Err(_) =&gt; reply.error(libc::EIO),
        }
    }

    // ... implement other FUSE methods
}

// Mount the remote filesystem
pub fn mount_remote(backend: impl Fs, mountpoint: &amp;Path) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let fuse = RemoteFuse::new(backend);

    fuser::mount2(
        fuse,
        mountpoint,
        &amp;[
            MountOption::RO,  // Or RW
            MountOption::FSName("anyfs-remote".to_string()),
            MountOption::AutoUnmount,
        ],
    )?;

    Ok(())
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="summary-building-a-cloud-filesystem"><a class="header" href="#summary-building-a-cloud-filesystem">Summary: Building a Cloud Filesystem</a></h2>
<p>To build a complete cloud filesystem service:</p>
<h3 id="server-side"><a class="header" href="#server-side">Server Side</a></h3>
<ol>
<li>Wrap your backend (e.g., <code>IndexedBackend</code> or custom) with middleware</li>
<li>Expose via gRPC/REST server</li>
<li>Add authentication, rate limiting, idempotency</li>
</ol>
<h3 id="client-side"><a class="header" href="#client-side">Client Side</a></h3>
<ol>
<li>Implement <code>RemoteBackend</code> that calls server RPC</li>
<li>Wrap with <code>CachingBackend</code> for performance</li>
<li>Optionally add <code>OfflineCapableBackend</code></li>
<li>Mount via FUSE for native OS integration</li>
</ol>
<h3 id="architecture-4"><a class="header" href="#architecture-4">Architecture</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  Client Machine                                             │
│  ┌─────────┐    ┌────────────┐    ┌───────────────────┐    │
│  │  FUSE   │ →  │  Caching   │ →  │  RemoteBackend    │    │
│  │ Mount   │    │  Backend   │    │  (RPC Client)     │    │
│  └─────────┘    └────────────┘    └─────────┬─────────┘    │
└────────────────────────────────────────────│───────────────┘
                                              │ Network
┌────────────────────────────────────────────│───────────────┐
│  Server                                     ▼               │
│  ┌─────────────────┐    ┌─────────────────────────────┐    │
│  │   RPC Server    │ →  │  Middleware Stack           │    │
│  │  (Auth, Rate)   │    │  Quota → Tracing → Backend  │    │
│  └─────────────────┘    └─────────────┬───────────────┘    │
│                                        ▼                    │
│                         ┌─────────────────────────────┐    │
│                         │     IndexedBackend          │    │
│                         │  SQLite Index + Disk Blobs  │    │
│                         └─────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p>This gives you a complete cloud filesystem with:</p>
<ul>
<li>Native OS mounting (FUSE)</li>
<li>Offline support</li>
<li>Caching for performance</li>
<li>Server-side quotas and logging</li>
<li>Large file streaming performance</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-comparison-positioning--honest-assessment"><a class="header" href="#anyfs-comparison-positioning--honest-assessment">AnyFS: Comparison, Positioning &amp; Honest Assessment</a></h1>
<p><strong>A comprehensive look at why AnyFS exists, how it compares, and where it falls short</strong></p>
<hr>
<h2 id="origin-story"><a class="header" href="#origin-story">Origin Story</a></h2>
<p>AnyFS didn’t start as a filesystem abstraction. It started as a security problem.</p>
<h3 id="the-path-security-problem"><a class="header" href="#the-path-security-problem">The Path Security Problem</a></h3>
<p>While exploring filesystem security, I created the <a href="https://github.com/DK26/strict-path-rs"><code>strict-path</code></a> crate to ensure that externally-sourced paths could never escape their boundaries. The approach: resolve a boundary path, resolve the provided path, and validate containment.</p>
<p>This proved far more challenging than expected. Attack vectors kept appearing:</p>
<ul>
<li>Symlinks pointing outside the boundary</li>
<li>Windows junction points</li>
<li>NTFS Alternate Data Streams (<code>file.txt:hidden:$DATA</code>)</li>
<li>Windows 8.3 short names (<code>PROGRA~1</code>)</li>
<li>Linux <code>/proc</code> magic symlinks that escape namespaces</li>
<li>Unicode normalization tricks (NFC vs NFD)</li>
<li>URL-encoded traversal (<code>%2e%2e</code>)</li>
<li>TOCTOU race conditions</li>
</ul>
<p>Eventually, <code>strict-path</code> addressed 19+ attack vectors, making it (apparently) comprehensive. But it came with costs:</p>
<ul>
<li><strong>I/O overhead</strong> - Real filesystem resolution is expensive</li>
<li><strong>Existing paths only</strong> - <code>std::fs::canonicalize</code> requires paths to exist</li>
<li><strong>Residual TOCTOU risk</strong> - A symlink created between verification and operation (extremely rare, but possible)</li>
</ul>
<h3 id="the-sqlite-revelation"><a class="header" href="#the-sqlite-revelation">The SQLite Revelation</a></h3>
<p>Then a new idea emerged: <em>What if the filesystem didn’t exist on disk at all?</em></p>
<p>A SQLite-backed virtual filesystem would:</p>
<ul>
<li><strong>Eliminate path security issues</strong> - Paths are just database keys, not real files</li>
<li><strong>Be fully portable</strong> - A tenant’s entire filesystem in one <code>.db</code> file</li>
<li><strong>Have no TOCTOU</strong> - Database transactions are atomic</li>
<li><strong>Work on non-existing paths</strong> - No canonicalization needed</li>
</ul>
<h3 id="the-abstraction-need"><a class="header" href="#the-abstraction-need">The Abstraction Need</a></h3>
<p>But then: <em>What if I wanted to switch from SQLite to something else later?</em></p>
<p>I didn’t want to rewrite code just to explore different backends. I needed an abstraction.</p>
<h3 id="the-framework-vision"><a class="header" href="#the-framework-vision">The Framework Vision</a></h3>
<p>Research revealed that existing VFS solutions were either:</p>
<ul>
<li><strong>Too simple</strong> - Just swappable backends, no policies</li>
<li><strong>Too fixed</strong> - Specific to one use case (AI agents, archives, etc.)</li>
<li><strong>Insecure</strong> - Basic <code>..</code> traversal prevention, missing 17+ attack vectors</li>
</ul>
<p>My niche is security: <strong>isolating filesystems, limiting actions, controlling resources</strong>.</p>
<p>The Tower/Axum pattern for HTTP showed how to compose middleware elegantly. Why not apply the same pattern to filesystems?</p>
<p>Thus AnyFS: <strong>A composable middleware framework for filesystem operations.</strong></p>
<hr>
<h2 id="the-landscape-what-already-exists"><a class="header" href="#the-landscape-what-already-exists">The Landscape: What Already Exists</a></h2>
<h3 id="rust-ecosystem"><a class="header" href="#rust-ecosystem">Rust Ecosystem</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Library</th><th>Stars</th><th>Downloads</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><a href="https://github.com/manuel-woelker/rust-vfs"><code>vfs</code></a></td><td>464</td><td>1,700+ deps</td><td>Swappable filesystem backends</td></tr>
<tr><td><a href="https://lib.rs/crates/virtual-filesystem"><code>virtual-filesystem</code></a></td><td>~30</td><td>~260/mo</td><td>Backends with basic sandboxing</td></tr>
<tr><td><a href="https://github.com/tursodatabase/agentfs"><code>AgentFS</code></a></td><td>New</td><td>Alpha</td><td>AI agent state management</td></tr>
</tbody>
</table>
</div>
<h3 id="other-languages"><a class="header" href="#other-languages">Other Languages</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Library</th><th>Language</th><th>Strength</th></tr>
</thead>
<tbody>
<tr><td><a href="https://filesystem-spec.readthedocs.io/">fsspec</a></td><td>Python</td><td>Async, caching, 20+ backends</td></tr>
<tr><td><a href="https://github.com/PyFilesystem/pyfilesystem2">PyFilesystem2</a></td><td>Python</td><td>Clean URL-based API</td></tr>
<tr><td><a href="https://github.com/spf13/afero">Afero</a></td><td>Go</td><td>Composition patterns</td></tr>
<tr><td><a href="https://commons.apache.org/vfs/">Apache Commons VFS</a></td><td>Java</td><td>Enterprise, many backends</td></tr>
<tr><td><a href="https://github.com/TestableIO/System.IO.Abstractions">System.IO.Abstractions</a></td><td>.NET</td><td>Testing, mirrors System.IO</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="honest-comparison"><a class="header" href="#honest-comparison">Honest Comparison</a></h2>
<h3 id="what-others-do-well"><a class="header" href="#what-others-do-well">What Others Do Well</a></h3>
<p><strong><code>vfs</code> crate:</strong></p>
<ul>
<li>Mature (464 stars, 1,700+ dependent projects)</li>
<li>Multiple backends (Memory, Physical, Overlay, Embedded)</li>
<li>Async support (though being sunset)</li>
<li>Simple, focused API</li>
</ul>
<p><strong><code>virtual-filesystem</code>:</strong></p>
<ul>
<li>ZIP/TAR archive support</li>
<li>Mountable filesystem</li>
<li>Basic sandboxing attempt</li>
</ul>
<p><strong>AgentFS:</strong></p>
<ul>
<li>Purpose-built for AI agents</li>
<li>SQLite backend with FUSE mounting</li>
<li>Key-value store included</li>
<li>Audit trail built-in</li>
<li>Backed by Turso (funded company)</li>
<li>TypeScript/Python SDKs</li>
</ul>
<p><strong>fsspec (Python):</strong></p>
<ul>
<li>Block-wise caching (not just whole-file)</li>
<li>Async-first design</li>
<li>Excellent data science integration</li>
</ul>
<h3 id="what-others-do-poorly"><a class="header" href="#what-others-do-poorly">What Others Do Poorly</a></h3>
<p><strong>Security in existing solutions is inadequate.</strong></p>
<p>I examined <code>virtual-filesystem</code>’s <code>SandboxedPhysicalFS</code>. Here’s their <strong>entire</strong> security implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PathResolver for SandboxedPathResolver {
    fn resolve_path(root: &amp;Path, path: &amp;str) -&gt; Result&lt;PathBuf&gt; {
        let root = root.canonicalize()?;
        let host_path = root.join(make_relative(path)).canonicalize()?;

        if !host_path.starts_with(root) {
            return Err(io::Error::new(ErrorKind::PermissionDenied, "Traversal prevented"));
        }
        Ok(host_path)
    }
}
<span class="boring">}</span></code></pre>
<p>That’s it. ~10 lines covering <strong>2 out of 19+</strong> attack vectors.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attack Vector</th><th style="text-align: center">virtual-filesystem</th><th style="text-align: center">strict-path</th></tr>
</thead>
<tbody>
<tr><td>Basic <code>..</code> traversal</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>Symlink following</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>NTFS Alternate Data Streams</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Windows 8.3 short names</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Unicode normalization</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>TOCTOU race conditions</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Non-existing paths</td><td style="text-align: center">❌ FAILS</td><td style="text-align: center">✅</td></tr>
<tr><td>URL-encoded traversal</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Windows UNC paths</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Linux /proc magic symlinks</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Null byte injection</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Unicode direction override</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Windows reserved names</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Junction point escapes</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td><strong>Coverage</strong></td><td style="text-align: center"><strong>2/19</strong></td><td style="text-align: center"><strong>19/19</strong></td></tr>
</tbody>
</table>
</div>
<p>The <code>vfs</code> crate’s <code>AltrootFS</code> is similarly basic - just path prefix translation.</p>
<p><strong>No middleware composition exists anywhere.</strong></p>
<p>None of the filesystem libraries offer Tower-style middleware. You can’t do something like:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hypothetical - doesn't exist in other libraries
backend
    .layer(QuotaLayer)
    .layer(RateLimitLayer)
    .layer(TracingLayer)
<span class="boring">}</span></code></pre>
<p>If you want quotas in <code>vfs</code>, you’d have to build it INTO each backend. Then build it again for the next backend.</p>
<hr>
<h2 id="what-makes-anyfs-unique"><a class="header" href="#what-makes-anyfs-unique">What Makes AnyFS Unique</a></h2>
<h3 id="1-middleware-composition-nobody-else-has-this"><a class="header" href="#1-middleware-composition-nobody-else-has-this">1. Middleware Composition (Nobody Else Has This)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100_MB)
        .max_file_count(1000)
        .build())
    .layer(RateLimitLayer::builder()
        .max_ops_per_second(100)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("/workspace/.git/**")
        .build())
    .layer(TracingLayer::new());
<span class="boring">}</span></code></pre>
<p>Add, remove, or reorder middleware without touching backends. Write middleware once, use with any backend.</p>
<h3 id="2-type-safe-domain-separation-nobody-else-has-this"><a class="header" href="#2-type-safe-domain-separation-nobody-else-has-this">2. Type-Safe Domain Separation (Nobody Else Has This)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Sandbox;
struct UserData;

let sandbox: FileStorage&lt;_, _, Sandbox&gt; = FileStorage::new(memory_backend);
let userdata: FileStorage&lt;_, _, UserData&gt; = FileStorage::new(sqlite_backend);

fn process_sandbox(fs: &amp;FileStorage&lt;impl Fs, IterativeResolver, Sandbox&gt;) { ... }

process_sandbox(&amp;sandbox);   // OK
process_sandbox(&amp;userdata);  // COMPILE ERROR
<span class="boring">}</span></code></pre>
<p>Compile-time prevention of mixing storage domains.</p>
<h3 id="3-backend-agnostic-policies-nobody-else-has-this"><a class="header" href="#3-backend-agnostic-policies-nobody-else-has-this">3. Backend-Agnostic Policies (Nobody Else Has This)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Function</th><th style="text-align: center">Works on ANY backend</th></tr>
</thead>
<tbody>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Size/count limits</td><td style="text-align: center">✅</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Ops per second</td><td style="text-align: center">✅</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Path-based access control</td><td style="text-align: center">✅</td></tr>
<tr><td><code>Restrictions&lt;B&gt;</code></td><td>Disable operations</td><td style="text-align: center">✅</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Audit logging</td><td style="text-align: center">✅</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Block all writes</td><td style="text-align: center">✅</td></tr>
<tr><td><code>Cache&lt;B&gt;</code></td><td>LRU caching</td><td style="text-align: center">✅</td></tr>
<tr><td><code>Overlay&lt;B1,B2&gt;</code></td><td>Union filesystem</td><td style="text-align: center">✅</td></tr>
</tbody>
</table>
</div>
<h3 id="4-comprehensive-security-testing"><a class="header" href="#4-comprehensive-security-testing">4. Comprehensive Security Testing</a></h3>
<p>The planned conformance test suite targets 50+ security tests covering:</p>
<ul>
<li>Path traversal (URL-encoded, backslash, mixed)</li>
<li>Symlink attacks (escape, loops, TOCTOU)</li>
<li>Platform-specific (NTFS ADS, 8.3 names, /proc)</li>
<li>Unicode (normalization, RTL override, homoglyphs)</li>
<li>Resource exhaustion</li>
</ul>
<p>Derived from vulnerabilities in Apache Commons VFS, Afero, PyFilesystem2, and our own <code>strict-path</code> research.</p>
<hr>
<h2 id="honest-downsides-of-anyfs"><a class="header" href="#honest-downsides-of-anyfs">Honest Downsides of AnyFS</a></h2>
<h3 id="1-were-new-theyre-established"><a class="header" href="#1-were-new-theyre-established">1. We’re New, They’re Established</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th><code>vfs</code></th><th>AnyFS</th></tr>
</thead>
<tbody>
<tr><td>Stars</td><td>464</td><td>0 (new)</td></tr>
<tr><td>Dependent projects</td><td>1,700+</td><td>0 (new)</td></tr>
<tr><td>Years maintained</td><td>5+</td><td>New</td></tr>
<tr><td>Contributors</td><td>17</td><td>1</td></tr>
</tbody>
</table>
</div>
<p><strong>Reality:</strong> The <code>vfs</code> crate works fine for 90% of use cases. If you just need swappable backends for testing, <code>vfs</code> is battle-tested.</p>
<h3 id="2-complexity-vs-simplicity"><a class="header" href="#2-complexity-vs-simplicity">2. Complexity vs Simplicity</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vfs: Simple
let fs = MemoryFS::new();
fs.create_file("test.txt")?.write_all(b"hello")?;

// AnyFS: More setup if you use middleware
let fs = MemoryBackend::new()
    .layer(QuotaLayer::builder().max_total_size(1_MB).build());
fs.write("/test.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<p>If you don’t need middleware, AnyFS adds conceptual overhead.</p>
<h3 id="3-sync-only-for-now"><a class="header" href="#3-sync-only-for-now">3. Sync-Only (For Now)</a></h3>
<p>AnyFS is sync-first. In an async-dominated ecosystem (Tokio, etc.), this may limit adoption.</p>
<p><code>fsspec</code> (Python) and <code>OpenDAL</code> (Rust) are async-first. We’re not.</p>
<p><strong>Mitigation:</strong> ADR-024 plans async support. Our <code>Send + Sync</code> bounds enable <code>spawn_blocking</code> wrappers today.</p>
<h3 id="4-agentfs-has-momentum-for-ai-agents"><a class="header" href="#4-agentfs-has-momentum-for-ai-agents">4. AgentFS Has Momentum for AI Agents</a></h3>
<p>If you’re building AI agents specifically:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>AgentFS</th><th>AnyFS</th></tr>
</thead>
<tbody>
<tr><td>SQLite backend</td><td>✅</td><td>✅</td></tr>
<tr><td>FUSE mounting</td><td>✅</td><td>Planned</td></tr>
<tr><td>Key-value store</td><td>✅</td><td>❌ (different abstraction)</td></tr>
<tr><td>Tool call auditing</td><td>✅ Built-in</td><td>Via Tracing middleware</td></tr>
<tr><td>TypeScript SDK</td><td>✅</td><td>❌</td></tr>
<tr><td>Python SDK</td><td>Coming</td><td>❌</td></tr>
<tr><td>Corporate backing</td><td>Turso</td><td>None</td></tr>
</tbody>
</table>
</div>
<p>AgentFS is purpose-built for AI agents with corporate resources. We’re a general-purpose framework.</p>
<h3 id="5-performance-overhead"><a class="header" href="#5-performance-overhead">5. Performance Overhead</a></h3>
<p>Middleware composition has costs:</p>
<ul>
<li>Each layer adds a function call</li>
<li>Quota tracking requires size accounting</li>
<li>Rate limiting needs timestamp checks</li>
</ul>
<p>For hot paths with millions of ops/second, this matters. For normal usage, it doesn’t.</p>
<h3 id="6-real-filesystem-security-has-limits"><a class="header" href="#6-real-filesystem-security-has-limits">6. Real Filesystem Security Has Limits</a></h3>
<p>For <code>VRootFsBackend</code> (wrapping real filesystem):</p>
<ul>
<li>Still has I/O costs for path resolution</li>
<li>Residual TOCTOU risk (extremely rare)</li>
<li><code>strict-path</code> covers 19 vectors, but unknown unknowns exist</li>
</ul>
<p><strong>Virtual backends (Memory, SQLite) don’t have these issues</strong> - paths are just keys.</p>
<hr>
<h2 id="feature-matrix"><a class="header" href="#feature-matrix">Feature Matrix</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center">AnyFS</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center"><code>virtual-fs</code></th><th style="text-align: center">AgentFS</th><th style="text-align: center">OpenDAL</th></tr>
</thead>
<tbody>
<tr><td>Composable middleware</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Multiple backends</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>SQLite backend</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>Memory backend</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Quota enforcement</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Rate limiting</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Type-safe markers</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Path sandboxing</td><td style="text-align: center">✅</td><td style="text-align: center">Basic</td><td style="text-align: center">Basic (2 vectors)</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Async API</td><td style="text-align: center">🔜</td><td style="text-align: center">Partial</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>std::fs-aligned API</td><td style="text-align: center">✅</td><td style="text-align: center">Custom</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">Custom</td></tr>
<tr><td>FUSE mounting</td><td style="text-align: center">MVP scope</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>Conformance tests</td><td style="text-align: center">Planned (80+)</td><td style="text-align: center">Unknown</td><td style="text-align: center">Unknown</td><td style="text-align: center">Unknown</td><td style="text-align: center">Unknown</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="when-to-use-anyfs"><a class="header" href="#when-to-use-anyfs">When to Use AnyFS</a></h2>
<h3 id="good-fit"><a class="header" href="#good-fit">Good Fit</a></h3>
<ul>
<li><strong>Multi-tenant SaaS</strong> - Per-tenant quotas, path isolation, rate limiting</li>
<li><strong>Untrusted input sandboxing</strong> - Comprehensive path security</li>
<li><strong>Policy-heavy environments</strong> - When you need composable rules</li>
<li><strong>Backend flexibility</strong> - When you might swap storage later</li>
<li><strong>Type-safe domain separation</strong> - When mixing containers is dangerous</li>
</ul>
<h3 id="not-a-good-fit"><a class="header" href="#not-a-good-fit">Not a Good Fit</a></h3>
<ul>
<li><strong>Simple testing</strong> - <code>vfs</code> is simpler if you just need mock FS</li>
<li><strong>AI agent runtime</strong> - AgentFS has more features for that specific use case</li>
<li><strong>Cloud storage</strong> - OpenDAL is async-first with cloud backends</li>
<li><strong>Async-first codebases</strong> - Wait for AnyFS async support</li>
<li><strong>Must mount filesystem</strong> - Use <code>anyfs</code> with <code>fuse</code>/<code>winfsp</code> feature flags</li>
</ul>
<hr>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p><strong>AnyFS exists because:</strong></p>
<ol>
<li>Existing VFS libraries have basic, inadequate security (2/19 attack vectors)</li>
<li>No filesystem library offers middleware composition</li>
<li>No filesystem library offers type-safe domain separation</li>
<li>Policy enforcement (quotas, rate limits, path filtering) doesn’t exist elsewhere</li>
</ol>
<p><strong>AnyFS is honest about:</strong></p>
<ol>
<li>We’re new, <code>vfs</code> is established</li>
<li>We add complexity if you don’t need middleware</li>
<li>We’re sync-only for now</li>
<li>AgentFS has more resources for AI-specific use cases</li>
</ol>
<p><strong>AnyFS is positioned as:</strong></p>
<blockquote>
<p><strong>“Tower for filesystems”</strong> - Composable middleware over pluggable backends, with comprehensive security testing.</p>
</blockquote>
<hr>
<h2 id="sources"><a class="header" href="#sources">Sources</a></h2>
<ul>
<li><a href="https://github.com/manuel-woelker/rust-vfs">vfs crate</a></li>
<li><a href="https://lib.rs/crates/virtual-filesystem">virtual-filesystem crate</a></li>
<li><a href="https://github.com/tursodatabase/agentfs">AgentFS</a></li>
<li><a href="https://github.com/DK26/strict-path-rs">strict-path</a></li>
<li><a href="https://github.com/DK26/soft-canonicalize-rs">soft-canonicalize</a></li>
<li><a href="https://andre.arko.net/2025/08/18/in-memory-filesystems-in-rust/">In-Memory Filesystems in Rust</a> - Performance analysis</li>
<li><a href="https://users.rust-lang.org/t/virtual-filesystems-for-rust/117173">Rust Forum: Virtual Filesystems</a></li>
<li><a href="#prior-art-analysis-filesystem-abstraction-libraries">Prior Art Analysis</a> - Detailed vulnerability research</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h1>
<p><strong>Security model, threat analysis, and containment guarantees</strong></p>
<hr>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>AnyFS is designed with security as a primary concern. Security policies are enforced via <strong>composable middleware</strong>, not hardcoded in backends or the container wrapper.</p>
<hr>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<h3 id="in-scope-mitigated-by-middleware"><a class="header" href="#in-scope-mitigated-by-middleware">In Scope (Mitigated by Middleware)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Description</th><th>Middleware</th></tr>
</thead>
<tbody>
<tr><td><strong>Path traversal</strong></td><td>Access files outside allowed paths</td><td><code>PathFilter</code></td></tr>
<tr><td><strong>Symlink attacks</strong></td><td>Use symlinks to bypass controls</td><td>Backend-dependent (see below)</td></tr>
<tr><td><strong>Resource exhaustion</strong></td><td>Fill storage or create excessive files</td><td><code>Quota</code></td></tr>
<tr><td><strong>Runaway processes</strong></td><td>Excessive operations consuming resources</td><td><code>RateLimit</code></td></tr>
<tr><td><strong>Unauthorized writes</strong></td><td>Modifications to read-only data</td><td><code>ReadOnly</code></td></tr>
<tr><td><strong>Sensitive file access</strong></td><td>Access to <code>.env</code>, secrets, etc.</td><td><code>PathFilter</code></td></tr>
</tbody>
</table>
</div>
<h3 id="out-of-scope"><a class="header" href="#out-of-scope">Out of Scope</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><strong>Side-channel attacks</strong></td><td>Requires OS-level mitigations</td></tr>
<tr><td><strong>Physical access</strong></td><td>Disk encryption is application’s responsibility</td></tr>
<tr><td><strong>SQLite vulnerabilities</strong></td><td>Upstream dependency; update regularly</td></tr>
<tr><td><strong>Network attacks</strong></td><td>AnyFS is local storage, not network-facing</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h2>
<h3 id="1-middleware-based-policy"><a class="header" href="#1-middleware-based-policy">1. Middleware-Based Policy</a></h3>
<p>Security policies are composable middleware layers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, RateLimitLayer, TracingLayer};

let secure_backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()              // Limit resources
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()         // Sandbox paths
        .allow("/workspace/**")
        .deny("**/.env")
        .deny("**/secrets/**")
        .build())
    .layer(RateLimitLayer::builder()          // Throttle operations
        .max_ops(1000)
        .per_second()
        .build())
    .layer(TracingLayer::new());              // Audit trail
<span class="boring">}</span></code></pre>
<h3 id="2-path-sandboxing-pathfilter"><a class="header" href="#2-path-sandboxing-pathfilter">2. Path Sandboxing (PathFilter)</a></h3>
<p><code>PathFilter</code> middleware restricts path access using glob patterns:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathFilterLayer::builder()
    .allow("/workspace/**")    // Allow workspace access
    .deny("**/.env")           // Block .env files
    .deny("**/secrets/**")     // Block secrets directories
    .deny("**/*.key")          // Block key files
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Guarantees:</strong></p>
<ul>
<li>First matching rule wins</li>
<li>No rule = denied (deny by default)</li>
<li><code>read_dir</code> filters denied entries from results</li>
</ul>
<h3 id="3-symlink-capability-via-trait-bounds"><a class="header" href="#3-symlink-capability-via-trait-bounds">3. Symlink Capability via Trait Bounds</a></h3>
<p>Symlink/hard-link capability is determined by <strong>trait bounds</strong>, not middleware:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MemoryBackend implements FsLink → symlinks work
let fs = FileStorage::new(MemoryBackend::new());
fs.symlink("/target", "/link")?;  // ✅ Works

// Custom backend without FsLink → symlinks won't compile
let fs = FileStorage::new(MySimpleBackend::new());
fs.symlink("/target", "/link")?;  // ❌ Compile error
<span class="boring">}</span></code></pre>
<p><strong>If you don’t want symlinks:</strong> Use a backend that doesn’t implement <code>FsLink</code>.</p>
<p>The <code>Restrictions</code> middleware only controls permission operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RestrictionsLayer::builder()
    .deny_permissions()        // Block set_permissions() calls
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Sandboxing untrusted code (block permission changes)</li>
<li>Read-only-ish environments (block permission mutations)</li>
</ul>
<h3 id="4-resource-limits-quota"><a class="header" href="#4-resource-limits-quota">4. Resource Limits (Quota)</a></h3>
<p><code>Quota</code> middleware enforces capacity limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>QuotaLayer::builder()
    .max_total_size(100 * 1024 * 1024)  // 100 MB total
    .max_file_size(10 * 1024 * 1024)    // 10 MB per file
    .max_node_count(10_000)             // Max files/dirs
    .max_dir_entries(1_000)             // Max per directory
    .max_path_depth(64)                 // Max nesting
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Guarantees:</strong></p>
<ul>
<li>Writes rejected when limits exceeded</li>
<li>Streaming writes tracked via <code>CountingWriter</code></li>
</ul>
<h3 id="5-rate-limiting-ratelimit"><a class="header" href="#5-rate-limiting-ratelimit">5. Rate Limiting (RateLimit)</a></h3>
<p><code>RateLimit</code> middleware throttles operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RateLimitLayer::builder()
    .max_ops(1000)
    .per_second()
    .build()
    .layer(backend)
<span class="boring">}</span></code></pre>
<p><strong>Guarantees:</strong></p>
<ul>
<li>Operations rejected when limit exceeded</li>
<li>Protects against runaway processes</li>
</ul>
<h3 id="6-backend-level-containment"><a class="header" href="#6-backend-level-containment">6. Backend-Level Containment</a></h3>
<p>Different backends achieve containment differently:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Containment Mechanism</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Isolated in process memory</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Each container is a separate <code>.db</code> file</td></tr>
<tr><td><code>IndexedBackend</code></td><td>SQLite index + isolated blob directory (UUID-named blobs)</td></tr>
<tr><td><code>StdFsBackend</code></td><td><strong>None</strong> - full filesystem access (do NOT use with untrusted input)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Uses <code>strict-path::VirtualRoot</code> to contain paths</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p>⚠️ <strong>Warning:</strong> <code>PathFilter</code> middleware on <code>StdFsBackend</code> does NOT provide sandboxing.
The OS still resolves paths (including symlinks) before <code>PathFilter</code> can check them.
For path containment with real filesystems, use <code>VRootFsBackend</code>.</p>
</blockquote>
<h3 id="7-why-virtual-backends-are-inherently-safe"><a class="header" href="#7-why-virtual-backends-are-inherently-safe">7. Why Virtual Backends Are Inherently Safe</a></h3>
<p>For <code>MemoryBackend</code> and <code>SqliteBackend</code>, the underlying storage is isolated from the host filesystem. There is no OS filesystem to exploit - paths operate entirely within the virtual structure.</p>
<p><strong>Path resolution is symlink-aware but contained</strong>: FileStorage resolves paths by walking the <em>virtual</em> directory structure (using <code>metadata()</code> and <code>read_link()</code> on the backend), not the OS filesystem:</p>
<pre><code>Virtual backend symlink example:
  /foo/bar  where bar → /other/place
  /foo/bar/..  resolves to /other (following the symlink target's parent)

This is correct filesystem semantics - but it happens entirely within
the virtual structure. There is no host filesystem to escape to.
</code></pre>
<p>This means:</p>
<ul>
<li><strong>No host filesystem access</strong> - symlinks point to paths within the virtual structure only</li>
<li><strong>No TOCTOU via OS state</strong> - resolution uses the backend’s own data</li>
<li><strong>Controlled by PathResolver</strong> - the default <code>IterativeResolver</code> follows symlinks when <code>FsLink</code> is available; custom resolvers can implement different behaviors</li>
</ul>
<p>For <code>VRootFsBackend</code> (real filesystem), <code>strict-path::VirtualRoot</code> provides equivalent guarantees by validating and containing all paths before they reach the OS.</p>
<h3 id="8-symlink-security-virtual-vs-real-backends"><a class="header" href="#8-symlink-security-virtual-vs-real-backends">8. Symlink Security: Virtual vs Real Backends</a></h3>
<p><strong>The security concern with symlinks is <em>following</em> them, not <em>creating</em> them.</strong></p>
<p>Symlinks are just data. Creating <code>/sandbox/link -&gt; /etc/passwd</code> is harmless. The danger is when reading <code>/sandbox/link</code> follows the symlink and accesses <code>/etc/passwd</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Type</th><th>Symlink Creation</th><th>Symlink Following</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Supported (<code>FsLink</code>)</td><td><code>FileStorage</code> resolves (non-<code>SelfResolving</code>)</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Supported (<code>FsLink</code>)</td><td><code>FileStorage</code> resolves (non-<code>SelfResolving</code>)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Supported (<code>FsLink</code>)</td><td><strong>OS controls</strong> - <code>strict-path</code> prevents escapes</td></tr>
</tbody>
</table>
</div>
<h4 id="virtual-backends-memory-sqlite"><a class="header" href="#virtual-backends-memory-sqlite">Virtual Backends (Memory, SQLite)</a></h4>
<p>Virtual backends that implement <code>FsLink</code> follow symlinks during <code>FileStorage</code> resolution. Symlink capability is determined by trait bounds:</p>
<ul>
<li><code>MemoryBackend: FsLink</code> → supports symlinks</li>
<li><code>SqliteBackend: FsLink</code> → supports symlinks</li>
<li>Custom backend without <code>FsLink</code> → no symlinks (compile-time enforced)</li>
</ul>
<p>If you need symlink-free behavior, use a backend that does not implement <code>FsLink</code>.</p>
<p><strong>This is the actual security feature</strong> - controlling whether symlinks are even possible via trait bounds.</p>
<h4 id="real-filesystem-backend-vrootfsbackend"><a class="header" href="#real-filesystem-backend-vrootfsbackend">Real Filesystem Backend (VRootFsBackend)</a></h4>
<p>VRootFsBackend calls OS functions (<code>std::fs::read()</code>, etc.) which follow symlinks automatically. <strong>We cannot control this</strong> - the OS does the symlink resolution, not us.</p>
<p><code>strict-path::VirtualRoot</code> prevents <strong>escapes</strong>:</p>
<pre><code>User requests: /sandbox/link
link -&gt; ../../../etc/passwd
strict-path: canonicalize(/sandbox/link) = /etc/passwd
strict-path: /etc/passwd is NOT within /sandbox → DENIED
</code></pre>
<p>This is “follow and verify containment” - symlinks are followed by the OS, but escapes are blocked by strict-path.</p>
<p><strong>Limitation:</strong> Symlinks within the jail are followed. We cannot disable this without implementing custom path resolution (TOCTOU risk) or platform-specific hacks.</p>
<h4 id="summary-5"><a class="header" href="#summary-5">Summary</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Virtual Backend</th><th>VRootFsBackend</th></tr>
</thead>
<tbody>
<tr><td>Symlink creation</td><td>Supported (<code>FsLink</code>)</td><td>Supported (<code>FsLink</code>)</td></tr>
<tr><td>Symlink following</td><td><code>FileStorage</code> resolves (non-<code>SelfResolving</code>)</td><td>OS controls (strict-path prevents escapes)</td></tr>
<tr><td>Jail escape via symlink</td><td>No host FS to escape</td><td>Prevented by strict-path</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="secure-usage-patterns"><a class="header" href="#secure-usage-patterns">Secure Usage Patterns</a></h2>
<h3 id="ai-agent-sandbox"><a class="header" href="#ai-agent-sandbox">AI Agent Sandbox</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, PathFilterLayer, RateLimitLayer, TracingLayer, FileStorage};

let sandbox = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(50 * 1024 * 1024)
        .max_file_size(5 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .deny("**/secrets/**")
        .build())
    .layer(RateLimitLayer::builder()
        .max_ops(1000)
        .per_second()
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(sandbox);
// Agent code can only access /workspace, limited resources, audited
// Note: MemoryBackend implements FsLink, so symlinks work if needed
<span class="boring">}</span></code></pre>
<h3 id="multi-tenant-isolation"><a class="header" href="#multi-tenant-isolation">Multi-Tenant Isolation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota, FileStorage};

fn create_tenant_storage(tenant_id: &amp;str, quota_bytes: u64) -&gt; FileStorage&lt;impl Fs&gt; {
    let db_path = format!("tenants/{}.db", tenant_id);
    let backend = QuotaLayer::builder()
        .max_total_size(quota_bytes)
        .build()
        .layer(SqliteBackend::open(&amp;db_path).unwrap());

    FileStorage::new(backend)
}

// Complete isolation: separate database files
<span class="boring">}</span></code></pre>
<h3 id="read-only-browsing"><a class="header" href="#read-only-browsing">Read-Only Browsing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, ReadOnly, FileStorage};

let readonly_fs = FileStorage::new(
    ReadOnly::new(SqliteBackend::open("archive.db")?)
);

// All write operations return FsError::ReadOnly
<span class="boring">}</span></code></pre>
<hr>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h2>
<h3 id="for-application-developers"><a class="header" href="#for-application-developers">For Application Developers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Use <code>PathFilter</code> to sandbox untrusted code</li>
<li><input disabled="" type="checkbox"> Use <code>Quota</code> to prevent resource exhaustion</li>
<li><input disabled="" type="checkbox"> Use <code>Restrictions</code> when you need to disable risky operations</li>
<li><input disabled="" type="checkbox"> Use <code>RateLimit</code> for untrusted/shared environments</li>
<li><input disabled="" type="checkbox"> Use <code>Tracing</code> for audit trails</li>
<li><input disabled="" type="checkbox"> Use separate backends for separate tenants</li>
<li><input disabled="" type="checkbox"> Keep dependencies updated</li>
</ul>
<h3 id="for-backend-implementers"><a class="header" href="#for-backend-implementers">For Backend Implementers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Ensure paths cannot escape intended scope</li>
<li><input disabled="" type="checkbox"> For filesystem backends: use <code>strict-path</code> for containment</li>
<li><input disabled="" type="checkbox"> Handle concurrent access safely</li>
<li><input disabled="" type="checkbox"> Don’t leak internal paths in errors</li>
</ul>
<h3 id="for-middleware-implementers"><a class="header" href="#for-middleware-implementers">For Middleware Implementers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Handle streaming I/O appropriately (wrap or block)</li>
<li><input disabled="" type="checkbox"> Document which operations are intercepted</li>
<li><input disabled="" type="checkbox"> Fail closed (deny on error)</li>
</ul>
<hr>
<h2 id="encryption-and-integrity-protection"><a class="header" href="#encryption-and-integrity-protection">Encryption and Integrity Protection</a></h2>
<p>AnyFS’s design enables encryption at multiple levels. Understanding the difference between <strong>container-level</strong> and <strong>file-level</strong> protection is crucial for choosing the right approach.</p>
<h3 id="container-level-vs-file-level-protection"><a class="header" href="#container-level-vs-file-level-protection">Container-Level vs File-Level Protection</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>What’s Protected</th><th>Integrity</th><th>Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Container-level</strong></td><td>Entire storage medium (<code>.db</code> file, serialized state)</td><td>Full structure protected</td><td>Encrypted backend</td></tr>
<tr><td><strong>File-level</strong></td><td>Individual file contents</td><td>File contents only</td><td>Encryption middleware</td></tr>
</tbody>
</table>
</div>
<p><strong>Key insight:</strong> File-level encryption alone is NOT sufficient. If an attacker can modify the container structure (directory tree, metadata, file names), they can sabotage integrity even without decrypting file contents.</p>
<h3 id="threat-analysis"><a class="header" href="#threat-analysis">Threat Analysis</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>File-Level Encryption</th><th>Container-Level Encryption</th></tr>
</thead>
<tbody>
<tr><td>Read file contents</td><td>Protected</td><td>Protected</td></tr>
<tr><td>Modify file contents</td><td>Detected (with AEAD)</td><td>Detected</td></tr>
<tr><td>Delete files</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
<tr><td>Rename/move files</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
<tr><td>Corrupt directory structure</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
<tr><td>Replay old file versions</td><td><strong>NOT protected</strong></td><td>Protected (with versioning)</td></tr>
<tr><td>Metadata exposure (filenames, sizes)</td><td><strong>NOT protected</strong></td><td>Protected</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> For sensitive data, prefer container-level encryption. Use file-level encryption when you need selective access (some files encrypted, others not).</p>
<h3 id="container-level-encryption"><a class="header" href="#container-level-encryption">Container-Level Encryption</a></h3>
<h4 id="option-1-sqlcipher-backend"><a class="header" href="#option-1-sqlcipher-backend">Option 1: SQLCipher Backend</a></h4>
<p><a href="https://www.zetetic.net/sqlcipher/">SQLCipher</a> provides transparent AES-256 encryption for SQLite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// SQLite backend with full database encryption via SQLCipher.
pub struct SqliteCipherBackend {
    conn: rusqlite::Connection,  // Built with sqlcipher feature
}

impl SqliteCipherBackend {
    pub fn open(path: &amp;str, password: &amp;str) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path)?;
        // SQLCipher: derive key from password, encrypt everything
        conn.pragma_update(None, "key", password)?;
        Ok(Self { conn })
    }

    pub fn open_with_key(path: &amp;str, key: &amp;[u8; 32]) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path)?;
        // Use raw key instead of password
        conn.pragma_update(None, "key", &amp;format!("x'{}'", hex::encode(key)))?;
        Ok(Self { conn })
    }
}

impl Fs for SqliteCipherBackend { /* same as SqliteBackend */ }
<span class="boring">}</span></code></pre>
<p><strong>What’s protected:</strong></p>
<ul>
<li>All file contents</li>
<li>All metadata (names, sizes, timestamps, permissions)</li>
<li>Directory structure</li>
<li>Inode mappings</li>
<li>Everything in the <code>.db</code> file</li>
</ul>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteCipherBackend::open("secure.db", "correct-horse-battery-staple")?;
let fs = FileStorage::new(backend);

// If someone gets secure.db without the password, they see random bytes
<span class="boring">}</span></code></pre>
<h4 id="option-2-encrypted-serialization-memorybackend"><a class="header" href="#option-2-encrypted-serialization-memorybackend">Option 2: Encrypted Serialization (MemoryBackend)</a></h4>
<p>For in-memory backends that need persistence:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MemoryBackend {
    /// Serialize entire state to encrypted blob.
    pub fn serialize_encrypted(&amp;self, key: &amp;[u8; 32]) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let plaintext = bincode::serialize(&amp;self.state)?;
        let nonce = generate_nonce();
        let ciphertext = aes_gcm_encrypt(key, &amp;nonce, &amp;plaintext)?;
        Ok([nonce.as_slice(), &amp;ciphertext].concat())
    }

    /// Deserialize from encrypted blob.
    pub fn deserialize_encrypted(data: &amp;[u8], key: &amp;[u8; 32]) -&gt; Result&lt;Self, FsError&gt; {
        let (nonce, ciphertext) = data.split_at(12);
        let plaintext = aes_gcm_decrypt(key, nonce, ciphertext)?;
        let state = bincode::deserialize(&amp;plaintext)?;
        Ok(Self { state })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Use case:</strong> Periodically save encrypted snapshots, load on startup.</p>
<h3 id="file-level-encryption-middleware"><a class="header" href="#file-level-encryption-middleware">File-Level Encryption (Middleware)</a></h3>
<p>When you need selective encryption or per-file keys:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Middleware that encrypts file contents on write, decrypts on read.
/// Does NOT protect metadata, filenames, or directory structure.
pub struct FileEncryption&lt;B&gt; {
    inner: B,
    key: Secret&lt;[u8; 32]&gt;,
}

impl&lt;B: Fs&gt; FsWrite for FileEncryption&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        // Encrypt content with authenticated encryption (AES-GCM)
        let nonce = generate_nonce();
        let ciphertext = aes_gcm_encrypt(&amp;self.key, &amp;nonce, data)?;
        let encrypted = [nonce.as_slice(), &amp;ciphertext].concat();
        self.inner.write(path, &amp;encrypted)
    }
}

impl&lt;B: Fs&gt; FsRead for FileEncryption&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let encrypted = self.inner.read(path)?;
        let (nonce, ciphertext) = encrypted.split_at(12);
        aes_gcm_decrypt(&amp;self.key, nonce, ciphertext)
            .map_err(|_| FsError::IntegrityError { path: path.as_ref().to_path_buf() })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>Filenames visible</li>
<li>Directory structure visible</li>
<li>File sizes visible (roughly - ciphertext slightly larger)</li>
<li>Metadata unprotected</li>
</ul>
<p><strong>When to use:</strong></p>
<ul>
<li>Some files need encryption, others don’t</li>
<li>Different files need different keys</li>
<li>Interop with systems that expect plaintext structure</li>
</ul>
<h3 id="integrity-without-encryption"><a class="header" href="#integrity-without-encryption">Integrity Without Encryption</a></h3>
<p>Sometimes you need tamper detection without hiding contents:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Middleware that adds HMAC to each file for integrity verification.
pub struct IntegrityVerified&lt;B&gt; {
    inner: B,
    key: Secret&lt;[u8; 32]&gt;,
}

impl&lt;B: Fs&gt; FsWrite for IntegrityVerified&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let mac = hmac_sha256(&amp;self.key, data);
        let protected = [data, mac.as_slice()].concat();
        self.inner.write(path, &amp;protected)
    }
}

impl&lt;B: Fs&gt; FsRead for IntegrityVerified&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let protected = self.inner.read(path)?;
        let (data, mac) = protected.split_at(protected.len() - 32);
        if !hmac_verify(&amp;self.key, data, mac) {
            return Err(FsError::IntegrityError { path: path.as_ref().to_path_buf() });
        }
        Ok(data.to_vec())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="ram-encryption-and-secure-memory"><a class="header" href="#ram-encryption-and-secure-memory">RAM Encryption and Secure Memory</a></h3>
<p>For high-security scenarios where memory dumps are a threat:</p>
<h4 id="threat-levels"><a class="header" href="#threat-levels">Threat Levels</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Mitigation</th><th>Library-Level?</th></tr>
</thead>
<tbody>
<tr><td>Memory inspection after process exit</td><td><code>zeroize</code> on drop</td><td>Yes</td></tr>
<tr><td>Core dumps</td><td>Disable via <code>setrlimit</code></td><td>Yes (process config)</td></tr>
<tr><td>Swap file exposure</td><td><code>mlock()</code> to pin pages</td><td>Yes (OS permitting)</td></tr>
<tr><td>Live memory scanning (same user)</td><td>OS process isolation</td><td>No</td></tr>
<tr><td>Cold boot attack</td><td>Hardware RAM encryption</td><td>No (Intel TME/AMD SME)</td></tr>
<tr><td>Hypervisor/DMA attack</td><td>SGX/SEV enclaves</td><td>No (hardware)</td></tr>
</tbody>
</table>
</div>
<h4 id="encrypted-memory-backend-illustrative-pattern"><a class="header" href="#encrypted-memory-backend-illustrative-pattern">Encrypted Memory Backend (Illustrative Pattern)</a></h4>
<blockquote>
<p><strong>Note:</strong> <code>EncryptedMemoryBackend</code> is an illustrative pattern for users who need encrypted RAM storage. It is not a built-in backend. Users can implement this pattern using the guidance below.</p>
</blockquote>
<p>Keep data encrypted even in RAM - decrypt only during active use:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zeroize::{Zeroize, ZeroizeOnDrop};
use secrecy::Secret;

/// Memory backend that stores all data encrypted in RAM.
/// Plaintext exists only briefly during read operations.
pub struct EncryptedMemoryBackend {
    /// All nodes stored as encrypted blobs
    nodes: HashMap&lt;PathBuf, EncryptedNode&gt;,
    /// Encryption key - auto-zeroized on drop
    key: Secret&lt;[u8; 32]&gt;,
}

struct EncryptedNode {
    /// Encrypted file content (nonce || ciphertext)
    encrypted_data: Vec&lt;u8&gt;,
    /// Metadata can be encrypted too, or stored in the encrypted blob
    metadata: EncryptedMetadata,
}

impl FsRead for EncryptedMemoryBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let node = self.nodes.get(path.as_ref())
            .ok_or_else(|| FsError::NotFound { path: path.as_ref().to_path_buf() })?;

        // Decrypt - plaintext briefly in RAM
        let plaintext = self.decrypt(&amp;node.encrypted_data)?;

        // Return owned Vec - caller responsible for zeroizing if sensitive
        Ok(plaintext)
    }
}

impl FsWrite for EncryptedMemoryBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        // Encrypt immediately - plaintext never stored
        let encrypted = self.encrypt(data)?;

        self.nodes.insert(path.as_ref().to_path_buf(), EncryptedNode {
            encrypted_data: encrypted,
            metadata: self.encrypt_metadata(...)?,
        });
        Ok(())
    }
}

impl Drop for EncryptedMemoryBackend {
    fn drop(&amp;mut self) {
        // Zeroize all encrypted data (defense in depth)
        for node in self.nodes.values_mut() {
            node.encrypted_data.zeroize();
        }
        // Key is auto-zeroized via Secret&lt;&gt;
    }
}
<span class="boring">}</span></code></pre>
<h4 id="serialization-of-encrypted-ram"><a class="header" href="#serialization-of-encrypted-ram">Serialization of Encrypted RAM</a></h4>
<p>When persisting an encrypted memory backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EncryptedMemoryBackend {
    /// Serialize to disk - data stays encrypted throughout.
    /// RAM encrypted → Serialized encrypted → Disk encrypted
    pub fn save_to_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        // Data is already encrypted in self.nodes
        // Serialize the encrypted blobs directly - no decryption needed
        let serialized = bincode::serialize(&amp;self.nodes)?;

        // Optionally add another encryption layer with different key
        // (defense in depth: compromise of runtime key doesn't expose persisted data)
        std::fs::write(path, &amp;serialized)?;
        Ok(())
    }

    /// Load from disk - data stays encrypted throughout.
    /// Disk encrypted → Deserialized encrypted → RAM encrypted
    pub fn load_from_file(path: &amp;Path, key: Secret&lt;[u8; 32]&gt;) -&gt; Result&lt;Self, FsError&gt; {
        let serialized = std::fs::read(path)?;
        let nodes = bincode::deserialize(&amp;serialized)?;

        Ok(Self { nodes, key })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key property:</strong> Plaintext NEVER exists during save/load. Data flows:</p>
<pre><code>Write: plaintext → encrypt → RAM (encrypted) → serialize → disk (encrypted)
Read:  disk (encrypted) → deserialize → RAM (encrypted) → decrypt → plaintext
</code></pre>
<h4 id="secure-allocator-considerations"><a class="header" href="#secure-allocator-considerations">Secure Allocator Considerations</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In Cargo.toml - mimalloc secure mode zeros on free
mimalloc = { version = "0.1", features = ["secure"] }

// Note: This prevents USE-AFTER-FREE info leaks, but does NOT:
// - Encrypt RAM contents
// - Prevent live memory scanning
// - Protect against cold boot attacks
<span class="boring">}</span></code></pre>
<p>For true defense against memory scanning, combine:</p>
<ol>
<li><code>EncryptedMemoryBackend</code> (data encrypted at rest in RAM)</li>
<li><code>zeroize</code> (immediate cleanup of temporary plaintext)</li>
<li><code>mlock()</code> (prevent swapping sensitive pages)</li>
<li>Minimize plaintext lifetime (decrypt → use → zeroize immediately)</li>
</ol>
<h3 id="encryption-summary"><a class="header" href="#encryption-summary">Encryption Summary</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Protects Contents</th><th>Protects Structure</th><th>RAM Security</th><th>Persistence</th></tr>
</thead>
<tbody>
<tr><td><code>SqliteCipherBackend</code></td><td>Yes</td><td>Yes</td><td>No (SQLite uses plaintext RAM)</td><td>Encrypted <code>.db</code> file</td></tr>
<tr><td><code>FileEncryption&lt;B&gt;</code> middleware</td><td>Yes</td><td>No</td><td>Depends on B</td><td>Depends on B</td></tr>
<tr><td><code>EncryptedMemoryBackend</code> (illustrative)</td><td>Yes</td><td>Yes</td><td>Yes (encrypted in RAM)</td><td>Via <code>save_to_file()</code></td></tr>
<tr><td><code>IntegrityVerified&lt;B&gt;</code> middleware</td><td>No</td><td>No (files only)</td><td>No</td><td>Depends on B</td></tr>
</tbody>
</table>
</div>
<h3 id="recommended-configurations"><a class="header" href="#recommended-configurations">Recommended Configurations</a></h3>
<h4 id="sensitive-data-storage"><a class="header" href="#sensitive-data-storage">Sensitive Data Storage</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Full protection: encrypted container + secure memory practices
let backend = SqliteCipherBackend::open("secure.db", password)?;
let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<h4 id="high-security-ram-processing-illustrative"><a class="header" href="#high-security-ram-processing-illustrative">High-Security RAM Processing (Illustrative)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Data never plaintext at rest (RAM or disk)
// Note: EncryptedMemoryBackend is user-implemented (see pattern above)
let backend = EncryptedMemoryBackend::new(derive_key(password));
// ... use fs ...
backend.save_to_file("snapshot.enc")?;  // Persists encrypted
<span class="boring">}</span></code></pre>
<h4 id="selective-file-encryption"><a class="header" href="#selective-file-encryption">Selective File Encryption</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Some files encrypted, structure visible
let backend = FileEncryption::new(SqliteBackend::open("data.db")?)
    .with_key(key);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="toctou-proof-tenant-isolation-with-virtual-backends"><a class="header" href="#toctou-proof-tenant-isolation-with-virtual-backends">TOCTOU-Proof Tenant Isolation with Virtual Backends</a></h2>
<h3 id="why-virtual-backends-eliminate-toctou"><a class="header" href="#why-virtual-backends-eliminate-toctou">Why Virtual Backends Eliminate TOCTOU</a></h3>
<p>Traditional path security libraries like <code>strict-path</code> work against a <strong>real filesystem</strong>:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    REAL FILESYSTEM SECURITY                      │
│                                                                  │
│   Your Process          OS Filesystem         Other Processes   │
│   ┌──────────┐         ┌───────────┐         ┌──────────────┐   │
│   │ Check    │────────▶│ Canonical │◀────────│ Create       │   │
│   │ path     │         │ path      │         │ symlink      │   │
│   └──────────┘         └───────────┘         └──────────────┘   │
│        │                     │                      │           │
│        │    TOCTOU WINDOW    │                      │           │
│        ▼                     ▼                      ▼           │
│   ┌──────────┐         ┌───────────┐         ┌──────────────┐   │
│   │ Use      │────────▶│ DIFFERENT │◀────────│ Modified!    │   │
│   │ path     │         │ path now! │         │              │   │
│   └──────────┘         └───────────┘         └──────────────┘   │
│                                                                  │
│   Problem: OS state can change between check and use             │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p>Virtual backends eliminate this entirely:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                   VIRTUAL BACKEND SECURITY                       │
│                                                                  │
│   Your Process                                                   │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    FileStorage                           │   │
│   │  ┌──────────┐    ┌───────────┐    ┌──────────────────┐  │   │
│   │  │ Resolve  │───▶│ SQLite    │───▶│ Return data      │  │   │
│   │  │ path     │    │ Transaction│   │                  │  │   │
│   │  └──────────┘    └───────────┘    └──────────────────┘  │   │
│   │                        │                                 │   │
│   │              ATOMIC - No external modification possible  │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   No OS filesystem. No other processes. No TOCTOU.               │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="security-comparison-strict-path-vs-virtual-backend"><a class="header" href="#security-comparison-strict-path-vs-virtual-backend">Security Comparison: strict-path vs Virtual Backend</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>strict-path (Real FS)</th><th>Virtual Backend</th></tr>
</thead>
<tbody>
<tr><td>Path traversal</td><td>Prevented (canonicalize + verify)</td><td><strong>Impossible</strong> (no host FS to traverse to)</td></tr>
<tr><td>Symlink race (TOCTOU)</td><td>Mitigated (canonicalize first)</td><td><strong>Impossible</strong> (we control all symlinks)</td></tr>
<tr><td>External symlink creation</td><td>Vulnerable window exists</td><td><strong>Impossible</strong> (single-process ownership)</td></tr>
<tr><td>Windows 8.3 short names</td><td>Partial (only existing files)</td><td><strong>N/A</strong> (no Windows FS)</td></tr>
<tr><td>Namespace escapes (/proc)</td><td>Fixed in soft-canonicalize</td><td><strong>Impossible</strong> (no /proc exists)</td></tr>
<tr><td>Concurrent modification</td><td>OS handles (may race)</td><td><strong>Atomic</strong> (SQLite transactions)</td></tr>
<tr><td>Tenant A accessing Tenant B</td><td>Requires careful path filtering</td><td><strong>Impossible</strong> (separate .db files)</td></tr>
</tbody>
</table>
</div>
<h3 id="encryption-separation-of-concerns"><a class="header" href="#encryption-separation-of-concerns">Encryption: Separation of Concerns</a></h3>
<p><strong>Design principle:</strong> Backends handle storage, middleware handles policy. Container-level encryption is the exception.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Security Level</th><th>Implementation</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td><strong>Locked (container)</strong></td><td><code>SqliteCipherBackend</code></td><td>Must encrypt entire <code>.db</code> file at storage level</td></tr>
<tr><td><strong>Privacy (file contents)</strong></td><td><code>FileEncryption&lt;SqliteBackend&gt;</code> middleware</td><td>Content encryption is policy</td></tr>
<tr><td><strong>Normal</strong></td><td><code>SqliteBackend</code></td><td>User applies encryption as needed</td></tr>
</tbody>
</table>
</div>
<p><strong>Why Locked mode requires a separate backend:</strong></p>
<ul>
<li>SQLCipher encrypts the entire database file transparently</li>
<li>Connection must be opened with password before ANY query</li>
<li>Cannot be added as middleware - it’s a property of the connection itself</li>
<li>Everything is encrypted: file contents, filenames, directory structure, timestamps, inodes</li>
</ul>
<h3 id="sqlitecipherbackend-built-in-feature-sqlite-cipher"><a class="header" href="#sqlitecipherbackend-built-in-feature-sqlite-cipher">SqliteCipherBackend (Built-in, feature: <code>sqlite-cipher</code>)</a></h3>
<p>Full container encryption using <a href="https://www.zetetic.net/sqlcipher/">SQLCipher</a>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// SQLite backend with full AES-256 encryption via SQLCipher.
/// Requires `sqlite-cipher` feature (uses rusqlite with bundled-sqlcipher).
///
/// Without the password, the .db file is indistinguishable from random bytes.
pub struct SqliteCipherBackend {
    conn: Connection,
}

impl SqliteCipherBackend {
    /// Open with password (derives key via PBKDF2).
    pub fn open(path: impl AsRef&lt;Path&gt;, password: &amp;str) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path.as_ref())?;

        // SQLCipher: Set encryption key derived from password
        conn.pragma_update(None, "key", password)?;

        // Verify we can read (wrong password = SQLITE_NOTADB)
        conn.query_row("SELECT count(*) FROM sqlite_master", [], |_| Ok(()))
            .map_err(|_| FsError::InvalidPassword)?;

        Self::init_schema(&amp;conn)?;
        Ok(Self { conn })
    }

    /// Open with raw 256-bit key (no key derivation).
    pub fn open_with_key(path: impl AsRef&lt;Path&gt;, key: &amp;[u8; 32]) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path.as_ref())?;

        // SQLCipher: Set raw key (hex-encoded with x'' prefix)
        let hex_key = format!("x'{}'", hex::encode(key));
        conn.pragma_update(None, "key", &amp;hex_key)?;

        conn.query_row("SELECT count(*) FROM sqlite_master", [], |_| Ok(()))
            .map_err(|_| FsError::InvalidPassword)?;

        Self::init_schema(&amp;conn)?;
        Ok(Self { conn })
    }

    /// Create new encrypted database with password.
    pub fn create(path: impl AsRef&lt;Path&gt;, password: &amp;str) -&gt; Result&lt;Self, FsError&gt; {
        if path.as_ref().exists() {
            return Err(FsError::AlreadyExists { path: path.as_ref().to_path_buf(), operation: "create" });
        }
        Self::open(path, password)
    }

    /// Change the password on an open database.
    pub fn change_password(&amp;self, new_password: &amp;str) -&gt; Result&lt;(), FsError&gt; {
        self.conn.pragma_update(None, "rekey", new_password)?;
        Ok(())
    }

    fn init_schema(conn: &amp;Connection) -&gt; Result&lt;(), FsError&gt; {
        conn.execute_batch(r#"
            -- Node table: directories, files, symlinks
            CREATE TABLE IF NOT EXISTS nodes (
                inode INTEGER PRIMARY KEY,
                parent_inode INTEGER NOT NULL,
                name TEXT NOT NULL,
                node_type INTEGER NOT NULL,  -- 0=file, 1=dir, 2=symlink
                size INTEGER NOT NULL DEFAULT 0,
                mode INTEGER NOT NULL DEFAULT 0o644,
                nlink INTEGER NOT NULL DEFAULT 1,
                uid INTEGER NOT NULL DEFAULT 0,
                gid INTEGER NOT NULL DEFAULT 0,
                created_at INTEGER,
                modified_at INTEGER,
                accessed_at INTEGER,
                symlink_target TEXT,
                UNIQUE(parent_inode, name),
                FOREIGN KEY (parent_inode) REFERENCES nodes(inode)
            );

            -- Content table: file data (separate for efficient large files)
            CREATE TABLE IF NOT EXISTS content (
                inode INTEGER PRIMARY KEY,
                data BLOB NOT NULL,
                FOREIGN KEY (inode) REFERENCES nodes(inode) ON DELETE CASCADE
            );

            -- Index for directory listing performance
            CREATE INDEX IF NOT EXISTS idx_parent ON nodes(parent_inode);

            -- Root directory (inode 1, parent is self)
            INSERT OR IGNORE INTO nodes (inode, parent_inode, name, node_type, mode)
            VALUES (1, 1, '', 1, 0o755);
        "#)?;
        Ok(())
    }
}

// Implements same traits as SqliteBackend - only difference is encrypted storage
impl Fs for SqliteCipherBackend { /* ... */ }
impl FsFull for SqliteCipherBackend { /* ... */ }
impl FsFuse for SqliteCipherBackend { /* ... */ }
<span class="boring">}</span></code></pre>
<h4 id="what-sqlcipher-encrypts"><a class="header" href="#what-sqlcipher-encrypts">What SQLCipher Encrypts</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Data</th><th>Encrypted?</th></tr>
</thead>
<tbody>
<tr><td>File contents</td><td>Yes</td></tr>
<tr><td>Filenames</td><td>Yes</td></tr>
<tr><td>Directory structure</td><td>Yes</td></tr>
<tr><td>File sizes</td><td>Yes</td></tr>
<tr><td>Timestamps</td><td>Yes</td></tr>
<tr><td>Permissions</td><td>Yes</td></tr>
<tr><td>Inode mappings</td><td>Yes</td></tr>
<tr><td>SQLite metadata</td><td>Yes</td></tr>
<tr><td><strong>Everything in the .db file</strong></td><td><strong>Yes</strong></td></tr>
</tbody>
</table>
</div>
<h4 id="cargo-configuration"><a class="header" href="#cargo-configuration">Cargo Configuration</a></h4>
<pre><code class="language-toml">[dependencies]
# Regular SQLite (no encryption)
rusqlite = { version = "0.31", features = ["bundled"] }

# SQLCipher (full encryption) - mutually exclusive with above
rusqlite = { version = "0.31", features = ["bundled-sqlcipher"] }
</code></pre>
<p><strong>Feature flags in anyfs:</strong></p>
<pre><code class="language-toml">[features]
default = ["memory"]
sqlite = ["rusqlite/bundled"]
sqlite-cipher = ["rusqlite/bundled-sqlcipher"]  # Replaces sqlite
</code></pre>
<p><strong>Note:</strong> <code>sqlite</code> and <code>sqlite-cipher</code> are mutually exclusive. SQLCipher is a drop-in replacement with the same schema and API.</p>
<h3 id="achieving-security-modes-with-composition"><a class="header" href="#achieving-security-modes-with-composition">Achieving Security Modes with Composition</a></h3>
<p>Users compose backends and middleware to achieve their desired security level:</p>
<h4 id="locked-mode-full-container-encryption"><a class="header" href="#locked-mode-full-container-encryption">Locked Mode (Full Container Encryption)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Everything encrypted - password required to access anything
let backend = SqliteCipherBackend::open("tenant.db", "correct-horse-battery-staple")?;
let fs = FileStorage::new(backend);

// Without password: .db file is random bytes
// With password: full access to everything
<span class="boring">}</span></code></pre>
<h4 id="privacy-mode-contents-encrypted-metadata-visible"><a class="header" href="#privacy-mode-contents-encrypted-metadata-visible">Privacy Mode (Contents Encrypted, Metadata Visible)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File contents encrypted, metadata (names, sizes, structure) visible
let backend = FileEncryption::new(
    SqliteBackend::open("tenant.db")?
)
.with_key(content_key);

let fs = FileStorage::new(backend);

// Host can: list files, see sizes, run statistics
// Host cannot: read file contents
<span class="boring">}</span></code></pre>
<h4 id="normal-mode-no-encryption"><a class="header" href="#normal-mode-no-encryption">Normal Mode (No Encryption)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// No encryption - user encrypts sensitive files themselves
let backend = SqliteBackend::open("tenant.db")?;
let fs = FileStorage::new(backend);

// User applies per-file encryption as needed
<span class="boring">}</span></code></pre>
<h4 id="mode-comparison"><a class="header" href="#mode-comparison">Mode Comparison</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Locked</th><th>Privacy</th><th>Normal</th></tr>
</thead>
<tbody>
<tr><td>Implementation</td><td><code>SqliteCipherBackend</code></td><td><code>FileEncryption&lt;SqliteBackend&gt;</code></td><td><code>SqliteBackend</code></td></tr>
<tr><td>File contents</td><td>Encrypted (SQLCipher)</td><td>Encrypted (AES-GCM)</td><td>Plaintext</td></tr>
<tr><td>Filenames</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>Directory structure</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>File sizes</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>Timestamps</td><td>Encrypted</td><td>Visible</td><td>Visible</td></tr>
<tr><td>Host can analyze</td><td>Nothing</td><td>Metadata only</td><td>Everything</td></tr>
<tr><td>Performance</td><td>Slowest (~10-15% overhead)</td><td>Medium</td><td>Fastest</td></tr>
<tr><td>Feature flag</td><td><code>sqlite-cipher</code></td><td><code>sqlite</code> + middleware</td><td><code>sqlite</code></td></tr>
</tbody>
</table>
</div>
<h4 id="why-this-is-toctou-proof"><a class="header" href="#why-this-is-toctou-proof">Why This Is TOCTOU-Proof</a></h4>
<ol>
<li><strong>No external filesystem</strong> - Paths exist only in our SQLite tables</li>
<li><strong>Atomic transactions</strong> - Path resolution + data access in single transaction</li>
<li><strong>Single-process ownership</strong> - No other process can modify the .db during operation</li>
<li><strong>We control symlinks</strong> - Symlinks are just rows in <code>nodes</code> table, we decide when to follow</li>
<li><strong>No OS involvement</strong> - OS never resolves our virtual paths</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is TOCTOU-proof:
impl SecureSqliteBackend {
    fn resolve_and_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Single transaction wraps everything
        let tx = self.conn.transaction()?;

        // 1. Resolve path (following symlinks in OUR table)
        let inode = self.resolve_path_internal(&amp;tx, path)?;

        // 2. Read content
        // No TOCTOU - same transaction, same snapshot
        let data = tx.query_row(
            "SELECT data FROM content WHERE inode = ?",
            [inode],
            |row| row.get(0)
        )?;

        // Transaction ensures atomicity
        Ok(data)
    }
}
<span class="boring">}</span></code></pre>
<h4 id="multi-tenant-isolation-1"><a class="header" href="#multi-tenant-isolation-1">Multi-Tenant Isolation</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Each tenant gets their own .db file - complete physical isolation
fn create_tenant_storage(tenant_id: &amp;str, encrypted: bool) -&gt; impl Fs {
    let path = format!("tenants/{}.db", tenant_id);

    if encrypted {
        let password = get_tenant_password(tenant_id);
        SqliteCipherBackend::open(&amp;path, &amp;password).unwrap()
    } else {
        SqliteBackend::open(&amp;path).unwrap()
    }
}

// Tenant A literally cannot access Tenant B's data:
// - Different .db files
// - Different passwords (if encrypted)
// - No shared state whatsoever
// - No path filtering bugs possible - there's nothing to filter
<span class="boring">}</span></code></pre>
<p><strong>Comparison with strict-path approach:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Tenant Isolation</th></tr>
</thead>
<tbody>
<tr><td>Shared filesystem + strict-path</td><td>Logical isolation (paths filtered)</td></tr>
<tr><td>Shared filesystem + PathFilter</td><td>Logical isolation (middleware enforced)</td></tr>
<tr><td><strong>Separate .db file per tenant</strong></td><td><strong>Physical isolation (separate files)</strong></td></tr>
</tbody>
</table>
</div>
<p>Physical isolation is strictly stronger - there’s no bug in path filtering that could leak data because <strong>there’s no shared data to leak</strong>.</p>
<h4 id="host-analysis-with-privacy-mode"><a class="header" href="#host-analysis-with-privacy-mode">Host Analysis with Privacy Mode</a></h4>
<p>When using <code>FileEncryption&lt;SqliteBackend&gt;</code> (Privacy mode), the host can query metadata directly from SQLite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Host can analyze metadata without the content encryption key
fn get_tenant_statistics(tenant_db: &amp;str) -&gt; TenantStats {
    // Connect directly to SQLite (no content key needed)
    let conn = Connection::open(tenant_db)?;

    let (file_count, dir_count, total_size) = conn.query_row(
        "SELECT
            COUNT(*) FILTER (WHERE node_type = 0),
            COUNT(*) FILTER (WHERE node_type = 1),
            SUM(size)
         FROM nodes",
        [],
        |row| Ok((row.get(0)?, row.get(1)?, row.get(2)?))
    )?;

    TenantStats { file_count, dir_count, total_size }
}

// List all files (names visible, contents encrypted)
fn list_tenant_files(tenant_db: &amp;str) -&gt; Vec&lt;FileInfo&gt; {
    let conn = Connection::open(tenant_db)?;
    conn.prepare("SELECT name, size, modified_at FROM nodes WHERE node_type = 0")?
        .query_map([], |row| Ok(FileInfo { ... }))?
        .collect()
}
<span class="boring">}</span></code></pre>
<h4 id="replacing-strict-path-usage"><a class="header" href="#replacing-strict-path-usage">Replacing strict-path Usage</a></h4>
<p>For projects currently using strict-path for tenant isolation:</p>
<p><strong>Before (strict-path):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualRoot;

fn handle_tenant_request(tenant_id: &amp;str, requested_path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    // Shared filesystem, path containment via strict-path
    let root = VirtualRoot::new(format!("/data/tenants/{}", tenant_id))?;
    let safe_path = root.resolve(requested_path)?;  // TOCTOU window here
    std::fs::read(safe_path)  // Another process could have modified
}
<span class="boring">}</span></code></pre>
<p><strong>After (SqliteCipherBackend):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteCipherBackend;

fn handle_tenant_request(tenant_id: &amp;str, requested_path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    // Separate encrypted database per tenant - no path containment needed
    let backend = get_tenant_backend(tenant_id);  // Cached connection
    backend.read(requested_path)  // Atomic, TOCTOU-proof
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>strict-path</th><th>Virtual Backend</th></tr>
</thead>
<tbody>
<tr><td>Isolation model</td><td>Logical (path filtering)</td><td>Physical (separate files)</td></tr>
<tr><td>TOCTOU</td><td>Mitigated</td><td><strong>Eliminated</strong></td></tr>
<tr><td>External interference</td><td>Possible</td><td><strong>Impossible</strong></td></tr>
<tr><td>Symlink attacks</td><td>Resolved at check time</td><td><strong>We control all symlinks</strong></td></tr>
<tr><td>Cross-tenant leakage</td><td>Bug in filtering could leak</td><td><strong>No shared data exists</strong></td></tr>
<tr><td>Performance</td><td>Real FS I/O + canonicalization</td><td>SQLite (often faster for small files)</td></tr>
<tr><td>Encryption</td><td>Separate concern</td><td>Built-in (<code>SqliteCipherBackend</code>) or middleware</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<ol>
<li><strong>No ACLs</strong>: Simple permissions only (Unix mode bits)</li>
<li><strong>Side channels</strong>: Timing attacks, cache attacks require OS/hardware mitigations</li>
<li><strong>SQLite file access</strong>: Host OS can still access the <code>.db</code> file (use Locked mode for encryption)</li>
</ol>
<hr>
<p><em>For implementation details, see <a href="#anyfs---architecture-decision-records">Architecture Decision Records</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---technical-comparison-with-alternatives"><a class="header" href="#anyfs---technical-comparison-with-alternatives">AnyFS - Technical Comparison with Alternatives</a></h1>
<p>This document compares AnyFS with existing Rust filesystem abstractions.</p>
<hr>
<h2 id="executive-summary"><a class="header" href="#executive-summary">Executive Summary</a></h2>
<p>AnyFS is <strong>to filesystems what Axum/Tower is to HTTP</strong>: a composable middleware stack with pluggable backends.</p>
<p><strong>Key differentiators:</strong></p>
<ul>
<li><strong>Composable middleware</strong> - Stack quota, sandboxing, tracing, caching as independent layers</li>
<li><strong>Backend agnostic</strong> - Swap Memory/SQLite/RealFS without code changes</li>
<li><strong>Policy separation</strong> - Storage logic separate from policy enforcement</li>
<li><strong>Third-party extensibility</strong> - Custom backends and middleware depend only on <code>anyfs-backend</code></li>
</ul>
<hr>
<h2 id="compared-solutions"><a class="header" href="#compared-solutions">Compared Solutions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Solution</th><th>What it is</th><th style="text-align: center">Middleware</th><th style="text-align: center">Multiple Backends</th></tr>
</thead>
<tbody>
<tr><td><code>vfs</code></td><td>VFS trait + backends</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td>AgentFS</td><td>SQLite agent runtime</td><td style="text-align: center">No</td><td style="text-align: center">No (SQLite only)</td></tr>
<tr><td>OpenDAL</td><td>Object storage layer</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes (cloud-focused)</td></tr>
<tr><td><strong>AnyFS</strong></td><td>VFS + middleware stack</td><td style="text-align: center"><strong>Yes</strong></td><td style="text-align: center"><strong>Yes</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-architecture-comparison"><a class="header" href="#1-architecture-comparison">1. Architecture Comparison</a></h2>
<h3 id="vfs-crate"><a class="header" href="#vfs-crate"><code>vfs</code> Crate</a></h3>
<p>Path-based trait, no middleware pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FileSystem: Send + Sync {
    fn read_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn Iterator&lt;Item = String&gt;&gt;&gt;;
    fn open_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndRead&gt;&gt;;
    fn create_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite&gt;&gt;;
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>No standard way to add quotas, logging, sandboxing</li>
<li>Each concern must be built into backends or wrapped externally</li>
<li>Path validation is backend-specific</li>
</ul>
<h3 id="agentfs"><a class="header" href="#agentfs">AgentFS</a></h3>
<p>SQLite-based agent runtime:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fixed to SQLite, includes KV store and tool auditing
let fs = AgentFS::open("agent.db")?;
fs.write_file("/path", data)?;
fs.kv_set("key", "value")?;  // KV store bundled
fs.toolcall_start("tool")?;  // Auditing bundled
<span class="boring">}</span></code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>Locked to SQLite (no memory backend for testing, no real FS)</li>
<li>Monolithic design (can’t use FS without KV/auditing)</li>
<li>No composable middleware</li>
</ul>
<h3 id="anyfs"><a class="header" href="#anyfs">AnyFS</a></h3>
<p>Tower-style middleware + pluggable backends:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, PathFilterLayer, RestrictionsLayer, TracingLayer, FileStorage};

// Compose middleware stack
let backend = SqliteBackend::open("data.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .deny("**/.env")
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Add/remove middleware without touching backends</li>
<li>Swap backends without touching middleware</li>
<li>Third-party extensions via <code>anyfs-backend</code> trait</li>
</ul>
<hr>
<h2 id="2-feature-comparison"><a class="header" href="#2-feature-comparison">2. Feature Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center">AnyFS</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center">AgentFS</th><th style="text-align: center">OpenDAL</th></tr>
</thead>
<tbody>
<tr><td><strong>Middleware pattern</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>Multiple backends</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>SQLite backend</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Memory backend</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>Real FS backend</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Quota enforcement</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">Manual</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Path sandboxing</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">Manual</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Feature gating</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Rate limiting</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>Tracing/logging</strong></td><td style="text-align: center">Middleware</td><td style="text-align: center">Manual</td><td style="text-align: center">Built-in</td><td style="text-align: center">Middleware</td></tr>
<tr><td><strong>Streaming I/O</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>Async API</strong></td><td style="text-align: center">Future</td><td style="text-align: center">Partial</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td></tr>
<tr><td><strong>POSIX extension</strong></td><td style="text-align: center">Future</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>FUSE mountable</strong></td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td><strong>KV store</strong></td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="3-middleware-stack"><a class="header" href="#3-middleware-stack">3. Middleware Stack</a></h2>
<p>AnyFS middleware can <strong>intercept, transform, and control</strong> operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Intercepts</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td><code>Quota</code></td><td>Writes</td><td>Reject if over limit</td></tr>
<tr><td><code>PathFilter</code></td><td>All ops</td><td>Block denied paths</td></tr>
<tr><td><code>Restrictions</code></td><td>Permission changes</td><td>Block via <code>.deny_permissions()</code></td></tr>
<tr><td><code>RateLimit</code></td><td>All ops</td><td>Throttle per second</td></tr>
<tr><td><code>ReadOnly</code></td><td>Writes</td><td>Block all writes</td></tr>
<tr><td><code>Tracing</code></td><td>All ops</td><td>Log with tracing crate</td></tr>
<tr><td><code>DryRun</code></td><td>Writes</td><td>Log without executing</td></tr>
<tr><td><code>Cache</code></td><td>Reads</td><td>LRU caching</td></tr>
<tr><td><code>Overlay</code></td><td>All ops</td><td>Union filesystem</td></tr>
<tr><td>Custom</td><td>Any</td><td>Encryption, compression, …</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="4-backend-trait"><a class="header" href="#4-backend-trait">4. Backend Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fs: Send + Sync {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
    // ... methods aligned with std::fs
}
<span class="boring">}</span></code></pre>
<p><strong>Design principles:</strong></p>
<ul>
<li><code>&amp;Path</code> in core traits (object-safe); <code>FileStorage</code>/<code>FsExt</code> accept <code>impl AsRef&lt;Path&gt;</code> for ergonomics</li>
<li>Aligned with <code>std::fs</code> naming</li>
<li>Streaming I/O via <code>open_read</code>/<code>open_write</code></li>
<li><code>Send</code> bound for async compatibility</li>
</ul>
<hr>
<h2 id="5-when-to-use-what"><a class="header" href="#5-when-to-use-what">5. When to Use What</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Need composable middleware</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need backend flexibility</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need SQLite + Memory + RealFS</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need just VFS abstraction (no policies)</td><td><code>vfs</code></td></tr>
<tr><td>Need AI agent runtime with KV + auditing</td><td>AgentFS</td></tr>
<tr><td>Need cloud object storage</td><td>OpenDAL</td></tr>
<tr><td>Need async-first design</td><td>OpenDAL (or wait for AnyFS async)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="6-deep-dive-vfs-crate-compatibility"><a class="header" href="#6-deep-dive-vfs-crate-compatibility">6. Deep Dive: <code>vfs</code> Crate Compatibility</a></h2>
<p>The <a href="https://github.com/manuel-woelker/rust-vfs"><code>vfs</code></a> crate is the most similar project. This section details why we don’t adopt their trait and how we’ll provide interop.</p>
<h3 id="vfsfilesystem-trait-complete"><a class="header" href="#vfsfilesystem-trait-complete"><code>vfs::FileSystem</code> Trait (Complete)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FileSystem: Send + Sync {
    // Required (9 methods)
    fn read_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn Iterator&lt;Item = String&gt;&gt;&gt;;
    fn create_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn open_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndRead&gt;&gt;;
    fn create_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite&gt;&gt;;
    fn append_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite&gt;&gt;;
    fn metadata(&amp;self, path: &amp;str) -&gt; VfsResult&lt;VfsMetadata&gt;;
    fn exists(&amp;self, path: &amp;str) -&gt; VfsResult&lt;bool&gt;;
    fn remove_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn remove_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;

    // Optional - default to NotSupported (6 methods)
    fn set_creation_time(&amp;self, path: &amp;str, time: SystemTime) -&gt; VfsResult&lt;()&gt;;
    fn set_modification_time(&amp;self, path: &amp;str, time: SystemTime) -&gt; VfsResult&lt;()&gt;;
    fn set_access_time(&amp;self, path: &amp;str, time: SystemTime) -&gt; VfsResult&lt;()&gt;;
    fn copy_file(&amp;self, src: &amp;str, dest: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn move_file(&amp;self, src: &amp;str, dest: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn move_dir(&amp;self, src: &amp;str, dest: &amp;str) -&gt; VfsResult&lt;()&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="feature-gap-analysis"><a class="header" href="#feature-gap-analysis">Feature Gap Analysis</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center">AnyFS</th><th>Gap</th></tr>
</thead>
<tbody>
<tr><td>Basic read/write</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td>Directory ops</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td>Streaming I/O</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td><code>rename</code></td><td style="text-align: center"><code>move_file</code></td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td><code>copy</code></td><td style="text-align: center"><code>copy_file</code></td><td style="text-align: center">Yes</td><td>-</td></tr>
<tr><td><strong>Symlinks</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Critical</td></tr>
<tr><td><strong>Hard links</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Critical</td></tr>
<tr><td><strong>Permissions</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Critical</td></tr>
<tr><td><strong>truncate</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>sync/fsync</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>statfs</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>read_range</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td><strong>symlink_metadata</strong></td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Missing</td></tr>
<tr><td>Path type</td><td style="text-align: center"><code>&amp;str</code></td><td style="text-align: center"><code>&amp;Path</code> (core) + <code>impl AsRef&lt;Path&gt;</code> in ergonomic layer</td><td>Different</td></tr>
<tr><td>Middleware</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td>Architectural</td></tr>
</tbody>
</table>
</div>
<h3 id="why-not-adopt-their-trait"><a class="header" href="#why-not-adopt-their-trait">Why Not Adopt Their Trait?</a></h3>
<ol>
<li><strong>No symlinks/hardlinks</strong> - Can’t virtualize real filesystem semantics</li>
<li><strong>No permissions</strong> - Our <code>Restrictions</code> middleware needs <code>set_permissions</code> to gate</li>
<li><strong>No durability primitives</strong> - No <code>sync</code>/<code>fsync</code> for data integrity</li>
<li><strong>No middleware pattern</strong> - Their <code>VfsPath</code> bakes in behaviors we want composable</li>
<li><strong><code>&amp;str</code> paths</strong> - Core traits use <code>&amp;Path</code> for object safety; ergonomics come from <code>FileStorage</code>/<code>FsExt</code></li>
</ol>
<p><strong>Our trait is a strict superset.</strong> Everything <code>vfs</code> can do, we can do. The reverse is not true.</p>
<h3 id="vfs-backends"><a class="header" href="#vfs-backends"><code>vfs</code> Backends</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>vfs Backend</th><th>AnyFS Equivalent</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>PhysicalFS</code></td><td><code>StdFsBackend</code></td><td>Both use real filesystem directly</td></tr>
<tr><td><code>MemoryFS</code></td><td><code>MemoryBackend</code></td><td>Both in-memory</td></tr>
<tr><td><code>OverlayFS</code></td><td><code>Overlay&lt;B1,B2&gt;</code></td><td>Both union filesystems</td></tr>
<tr><td><code>AltrootFS</code></td><td><code>VRootFsBackend</code></td><td>Both provide path containment</td></tr>
<tr><td><code>EmbeddedFS</code></td><td>(none)</td><td>Read-only embedded assets</td></tr>
<tr><td>(none)</td><td><code>SqliteBackend</code></td><td>We have SQLite</td></tr>
</tbody>
</table>
</div>
<h3 id="interoperability-plan"><a class="header" href="#interoperability-plan">Interoperability Plan</a></h3>
<p>Future <code>anyfs-vfs-compat</code> crate provides bidirectional adapters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_vfs_compat::{VfsCompat, AnyFsCompat};

// Use a vfs backend in AnyFS
// Missing features return FsError::NotSupported
let backend = VfsCompat::new(vfs::MemoryFS::new());
let fs = FileStorage::new(backend);

// Use an AnyFS backend in vfs-based code
// Only exposes what vfs supports
let anyfs_backend = MemoryBackend::new();
let vfs_fs: Box&lt;dyn vfs::FileSystem&gt; = Box::new(AnyFsCompat::new(anyfs_backend));
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Migrate from <code>vfs</code> to AnyFS incrementally</li>
<li>Use <code>vfs::EmbeddedFS</code> in AnyFS (read-only embedded assets)</li>
<li>Use AnyFS backends in projects depending on <code>vfs</code></li>
</ul>
<hr>
<h2 id="7-tradeoffs"><a class="header" href="#7-tradeoffs">7. Tradeoffs</a></h2>
<h3 id="anyfs-advantages"><a class="header" href="#anyfs-advantages">AnyFS Advantages</a></h3>
<ul>
<li>Composable middleware pattern</li>
<li>Backend-agnostic</li>
<li>Third-party extensibility</li>
<li>Clean separation of concerns</li>
<li>Full filesystem semantics (symlinks, permissions, durability)</li>
</ul>
<h3 id="anyfs-limitations"><a class="header" href="#anyfs-limitations">AnyFS Limitations</a></h3>
<ul>
<li>Sync-first (async planned)</li>
<li>Smaller ecosystem (new project)</li>
<li>Not full POSIX emulation</li>
</ul>
<hr>
<p>If this document conflicts with <code>AGENTS.md</code> or <code>src/architecture/design-overview.md</code>, treat those as authoritative.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---build-vs-reuse-analysis"><a class="header" href="#anyfs---build-vs-reuse-analysis">AnyFS - Build vs. Reuse Analysis</a></h1>
<p><strong>Can your goals be achieved with existing crates, or does this project need to exist?</strong></p>
<hr>
<h2 id="core-requirements"><a class="header" href="#core-requirements">Core Requirements</a></h2>
<ol>
<li><strong>Backend flexibility</strong> - swap storage without changing application code</li>
<li><strong>Composable middleware</strong> - add/remove capabilities (quotas, sandboxing, logging)</li>
<li><strong>Tenant isolation</strong> - each tenant gets an isolated namespace</li>
<li><strong>Portable storage</strong> - single-file backend (SQLite) for easy move/copy/backup</li>
<li><strong>Filesystem semantics</strong> - <code>std::fs</code>-aligned operations including symlinks and hard links</li>
<li><strong>Path containment</strong> - prevent traversal attacks</li>
</ol>
<hr>
<h2 id="what-already-exists"><a class="header" href="#what-already-exists">What Already Exists</a></h2>
<h3 id="vfs-crate-rust"><a class="header" href="#vfs-crate-rust"><code>vfs</code> crate (Rust)</a></h3>
<p><strong>What it provides:</strong></p>
<ul>
<li>Filesystem abstraction with multiple backends</li>
<li>MemoryFS, PhysicalFS, AltrootFS, OverlayFS, EmbeddedFS</li>
</ul>
<p><strong>What it lacks:</strong></p>
<ul>
<li>SQLite backend</li>
<li>Composable middleware pattern</li>
<li>Quota/limit enforcement</li>
<li>Policy layers (feature gating, path filtering)</li>
</ul>
<h3 id="agentfs-turso"><a class="header" href="#agentfs-turso">AgentFS (Turso)</a></h3>
<p><strong>What it provides:</strong></p>
<ul>
<li>SQLite-based filesystem for AI agents</li>
<li>Key-value store</li>
<li>Tool call auditing</li>
<li>FUSE mounting</li>
</ul>
<p><strong>What it lacks:</strong></p>
<ul>
<li>Multiple backend types (SQLite only)</li>
<li>Composable middleware</li>
<li>Backend-agnostic abstraction</li>
</ul>
<h3 id="rusqlite"><a class="header" href="#rusqlite"><code>rusqlite</code></a></h3>
<p><strong>What it provides:</strong> SQLite bindings, transactions, blobs.</p>
<p><strong>What it lacks:</strong> Filesystem semantics, quota enforcement.</p>
<h3 id="strict-path"><a class="header" href="#strict-path"><code>strict-path</code></a></h3>
<p><strong>What it provides:</strong> Path validation and containment (<code>VirtualRoot</code>).</p>
<p><strong>What it lacks:</strong> Storage backends, filesystem API.</p>
<hr>
<h2 id="gap-analysis"><a class="header" href="#gap-analysis">Gap Analysis</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Requirement</th><th style="text-align: center"><code>vfs</code></th><th style="text-align: center">AgentFS</th><th style="text-align: center"><code>rusqlite</code></th><th style="text-align: center"><code>strict-path</code></th></tr>
</thead>
<tbody>
<tr><td>Filesystem API</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Multiple backends</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">N/A</td><td style="text-align: center">No</td></tr>
<tr><td>SQLite backend</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes (raw)</td><td style="text-align: center">No</td></tr>
<tr><td>Composable middleware</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td>Quota enforcement</td><td style="text-align: center">No</td><td style="text-align: center">No</td><td style="text-align: center">Manual</td><td style="text-align: center">No</td></tr>
<tr><td>Path sandboxing</td><td style="text-align: center">Partial</td><td style="text-align: center">No</td><td style="text-align: center">Manual</td><td style="text-align: center">Yes</td></tr>
<tr><td>Symlink/hard link control</td><td style="text-align: center">Backend-dep</td><td style="text-align: center">Yes</td><td style="text-align: center">Manual</td><td style="text-align: center">N/A</td></tr>
</tbody>
</table>
</div>
<p><strong>Conclusion:</strong> No existing crate provides:</p>
<blockquote>
<p>“Backend-agnostic filesystem abstraction with composable middleware for quotas, sandboxing, and policy enforcement.”</p>
</blockquote>
<hr>
<h2 id="why-anyfs-exists"><a class="header" href="#why-anyfs-exists">Why AnyFS Exists</a></h2>
<p>AnyFS fills the gap by separating concerns:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Responsibility</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Trait (<code>Fs</code>, <code>Layer</code>) + types</td></tr>
<tr><td><code>anyfs</code></td><td>Backends + middleware + ergonomic wrapper (<code>FileStorage&lt;B, R, M&gt;</code>)</td></tr>
</tbody>
</table>
</div>
<p>The middleware pattern (like Tower/Axum) enables composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, PathFilterLayer, TracingLayer, FileStorage};

let backend = SqliteBackend::open("tenant.db")?
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024)
        .build())
    .layer(PathFilterLayer::builder()
        .allow("/workspace/**")
        .build())
    .layer(TracingLayer::new());

let fs = FileStorage::new(backend);
fs.write("/workspace/doc.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="alternatives-considered-1"><a class="header" href="#alternatives-considered-1">Alternatives Considered</a></h2>
<h3 id="option-a-implement-sqlite-backend-for-vfs-crate"><a class="header" href="#option-a-implement-sqlite-backend-for-vfs-crate">Option A: Implement SQLite backend for <code>vfs</code> crate</a></h3>
<p><strong>Pros:</strong> Ecosystem compatibility.</p>
<p><strong>Cons:</strong></p>
<ul>
<li>No middleware pattern for quotas/policies</li>
<li>Would still need to build quota/sandboxing outside the trait</li>
<li>Doesn’t solve the composability problem</li>
</ul>
<h3 id="option-b-use-agentfs"><a class="header" href="#option-b-use-agentfs">Option B: Use AgentFS</a></h3>
<p><strong>Pros:</strong> Already exists, SQLite-based, FUSE support.</p>
<p><strong>Cons:</strong></p>
<ul>
<li>Locked to SQLite (can’t swap to memory/real FS)</li>
<li>No composable middleware</li>
<li>Includes KV store and auditing we may not need</li>
</ul>
<h3 id="option-c-anyfs-recommended"><a class="header" href="#option-c-anyfs-recommended">Option C: AnyFS (recommended)</a></h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Backend-agnostic (swap storage without code changes)</li>
<li>Composable middleware (add/remove capabilities)</li>
<li>Clean separation of concerns</li>
<li>Third-party extensibility</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>New project, not yet widely adopted</li>
</ul>
<hr>
<h2 id="recommendation-1"><a class="header" href="#recommendation-1">Recommendation</a></h2>
<p>Build AnyFS with reusable primitives (<code>rusqlite</code>, <code>strict-path</code>, <code>thiserror</code>, <code>tracing</code>) but maintain the two-crate split. The middleware pattern is what makes the design both flexible and safe.</p>
<p><strong>Compatibility option:</strong> Later, provide an adapter that implements <code>vfs</code> traits on top of <code>Fs</code> for projects that need <code>vfs</code> compatibility.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="prior-art-analysis-filesystem-abstraction-libraries"><a class="header" href="#prior-art-analysis-filesystem-abstraction-libraries">Prior Art Analysis: Filesystem Abstraction Libraries</a></h1>
<p>This document analyzes filesystem abstraction libraries in other languages to learn from their successes, identify features we should adopt, and avoid known vulnerabilities.</p>
<hr>
<h2 id="executive-summary-1"><a class="header" href="#executive-summary-1">Executive Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Library</th><th>Language</th><th>Key Strength</th><th>Key Weakness</th><th>What We Can Learn</th></tr>
</thead>
<tbody>
<tr><td><a href="https://filesystem-spec.readthedocs.io/">fsspec</a></td><td>Python</td><td>Async + caching + data science integration</td><td>No middleware composition</td><td>Caching strategies, async design</td></tr>
<tr><td><a href="https://github.com/PyFilesystem/pyfilesystem2">PyFilesystem2</a></td><td>Python</td><td>Clean URL-based API</td><td>Symlink handling issues</td><td>Path normalization</td></tr>
<tr><td><a href="https://github.com/spf13/afero">Afero</a></td><td>Go</td><td>Composition (CopyOnWrite, Cache, BasePathFs)</td><td>Symlink escape in BasePathFs</td><td>Composition patterns</td></tr>
<tr><td><a href="https://commons.apache.org/vfs/">Apache Commons VFS</a></td><td>Java</td><td>Enterprise-grade, many backends</td><td><strong>CVE: Path traversal with encoded <code>..</code></strong></td><td>URL encoding attacks</td></tr>
<tr><td><a href="https://github.com/TestableIO/System.IO.Abstractions">System.IO.Abstractions</a></td><td>.NET</td><td>Perfect for testing, mirrors System.IO</td><td>No middleware/composition</td><td>MockFileSystem patterns</td></tr>
<tr><td><a href="https://github.com/streamich/memfs">memfs</a></td><td>Node.js</td><td>Browser + Node unified API</td><td>Fork exists due to “longstanding bugs”</td><td>In-memory implementation</td></tr>
<tr><td><a href="https://github.com/DK26/soft-canonicalize-rs">soft-canonicalize</a></td><td>Rust</td><td>Non-existing path resolution, TOCTOU-safe</td><td>Real FS only (not virtual)</td><td>Attack patterns to defend</td></tr>
<tr><td><a href="https://github.com/DK26/strict-path-rs">strict-path</a></td><td>Rust</td><td>19+ attack types blocked, type-safe markers</td><td>Real FS only (not virtual)</td><td>Attack catalog for testing</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="detailed-analysis"><a class="header" href="#detailed-analysis">Detailed Analysis</a></h2>
<h3 id="1-python-fsspec"><a class="header" href="#1-python-fsspec">1. Python: fsspec</a></h3>
<p><strong>Repository:</strong> <a href="https://github.com/fsspec/filesystem_spec">fsspec/filesystem_spec</a></p>
<p><strong>What they do well:</strong></p>
<ol>
<li>
<p><strong>Unified Interface Across 20+ Backends</strong></p>
<ul>
<li>Local, S3, GCS, Azure, HDFS, HTTP, FTP, SFTP, ZIP, TAR, Git, etc.</li>
<li>Same API regardless of backend</li>
</ul>
</li>
<li>
<p><strong>Sophisticated Caching</strong></p>
<pre><code class="language-python"># Block-wise caching - only download accessed parts
fs = fsspec.filesystem('blockcache', target_protocol='s3',
                       cache_storage='/tmp/cache')

# Whole-file caching
fs = fsspec.filesystem('filecache', target_protocol='s3',
                       cache_storage='/tmp/cache')
</code></pre>
</li>
<li>
<p><strong>Async Support</strong></p>
<ul>
<li><code>AsyncFileSystem</code> base class for async implementations</li>
<li>Concurrent bulk operations (<code>cat</code> fetches many files at once)</li>
<li>Used by Dask for parallel data processing</li>
</ul>
</li>
<li>
<p><strong>Data Science Integration</strong></p>
<ul>
<li>Native integration with Pandas, Dask, Intake</li>
<li>Parquet optimization with parallel chunk fetching</li>
</ul>
</li>
</ol>
<p><strong>What we should adopt:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Block-wise caching strategy (not just whole-file LRU)</li>
<li><input disabled="" type="checkbox"> Async design from the start (our ADR-024 async plan)</li>
<li><input disabled="" type="checkbox"> Consider “parts caching” for large file access patterns</li>
</ul>
<p><strong>What they lack that we have:</strong></p>
<ul>
<li>No middleware composition pattern</li>
<li>No quota/rate limiting built-in</li>
<li>No path filtering/sandboxing</li>
</ul>
<hr>
<h3 id="2-python-pyfilesystem2"><a class="header" href="#2-python-pyfilesystem2">2. Python: PyFilesystem2</a></h3>
<p><strong>Repository:</strong> <a href="https://github.com/PyFilesystem/pyfilesystem2">PyFilesystem/pyfilesystem2</a></p>
<p><strong>What they do well:</strong></p>
<ol>
<li>
<p><strong>URL-based Filesystem Specification</strong></p>
<pre><code class="language-python">from fs import open_fs

home_fs = open_fs('osfs://~/')
zip_fs = open_fs('zip://foo.zip')
ftp_fs = open_fs('ftp://ftp.example.com')
mem_fs = open_fs('mem://')
</code></pre>
</li>
<li>
<p><strong>Consistent Path Handling</strong></p>
<ul>
<li>Forward slashes everywhere (even on Windows)</li>
<li>Paths normalized automatically</li>
</ul>
</li>
<li>
<p><strong>Glob Support Built-in</strong></p>
<pre><code class="language-python">for match in fs.glob('**/*.py'):
    print(match.path)
</code></pre>
</li>
</ol>
<p><strong>Known Issues (from GitHub):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Issue</th><th>Description</th><th>Impact</th></tr>
</thead>
<tbody>
<tr><td><a href="https://github.com/PyFilesystem/pyfilesystem2/issues/171">#171</a></td><td>Symlink loops cause infinite recursion</td><td>DoS potential</td></tr>
<tr><td><a href="https://github.com/PyFilesystem/pyfilesystem2/issues/417">#417</a></td><td>No symlink creation support</td><td>Missing feature</td></tr>
<tr><td><a href="https://github.com/PyFilesystem/pyfilesystem2/issues/411">#411</a></td><td>Incorrect handling of symlinks with non-existing targets</td><td>Broken functionality</td></tr>
<tr><td><a href="https://github.com/PyFilesystem/pyfilesystem2/issues/61">#61</a></td><td>Symlinks not detected properly</td><td>Security concern</td></tr>
</tbody>
</table>
</div>
<p><strong>Lessons for AnyFS:</strong></p>
<ul>
<li>⚠️ <strong>Symlink handling is complex</strong> - we must handle loops, non-existent targets, and escaping</li>
<li>✅ <strong>URL-based opening is convenient</strong> - consider for future</li>
<li>✅ <strong>Consistent path format</strong> - we already do this (forward slashes always)</li>
</ul>
<hr>
<h3 id="3-go-afero"><a class="header" href="#3-go-afero">3. Go: Afero</a></h3>
<p><strong>Repository:</strong> <a href="https://github.com/spf13/afero">spf13/afero</a></p>
<p><strong>What they do well:</strong></p>
<ol>
<li>
<p><strong>Composition Pattern (Similar to Ours!)</strong></p>
<pre><code class="language-go">// Sandboxing
baseFs := afero.NewOsFs()
restrictedFs := afero.NewBasePathFs(baseFs, "/var/data")

// Caching layer
cachedFs := afero.NewCacheOnReadFs(baseFs, afero.NewMemMapFs(), time.Hour)

// Copy-on-write
cowFs := afero.NewCopyOnWriteFs(baseFs, afero.NewMemMapFs())
</code></pre>
</li>
<li>
<p><strong>io/fs Compatibility</strong></p>
<ul>
<li>Works with Go 1.16+ standard library interfaces</li>
<li><code>ReadDirFS</code>, <code>ReadFileFS</code>, etc.</li>
</ul>
</li>
<li>
<p><strong>Extensive Backend Support</strong></p>
<ul>
<li>OS, Memory, SFTP, GCS</li>
<li>Community: S3, MinIO, Dropbox, Google Drive, Git</li>
</ul>
</li>
</ol>
<p><strong>Known Issues:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Issue</th><th>Description</th><th>Our Mitigation</th></tr>
</thead>
<tbody>
<tr><td><a href="https://github.com/spf13/afero/issues/282">#282</a></td><td>Symlinks in BasePathFs can escape jail</td><td>Use <code>strict-path</code> crate for VRootFsBackend</td></tr>
<tr><td><a href="https://github.com/spf13/afero/issues/88">#88</a></td><td>Symlink handling inconsistent</td><td>Document behavior clearly</td></tr>
<tr><td><a href="https://github.com/spf13/afero/issues/344">#344</a></td><td>BasePathFs fails when basepath is <code>.</code></td><td>Test edge cases</td></tr>
</tbody>
</table>
</div>
<p><strong>BasePathFs Symlink Escape Issue:</strong></p>
<blockquote>
<p>“SymlinkIfPossible will resolve the RealPath of underlayer filesystem before make a symlink. For example, creating a link like ‘/foo/bar’ -&gt; ‘/foo/file’ will be transform into a link point to ‘/{basepath}/foo/file.’”</p>
</blockquote>
<p>This means symlinks can potentially point outside the base path!</p>
<p><strong>Our Solution:</strong></p>
<ul>
<li><code>VRootFsBackend</code> uses <a href="https://github.com/DK26/strict-path-rs"><code>strict-path</code></a> for real filesystem containment</li>
<li>Virtual backends (Memory, SQLite) are inherently safe - paths are just keys</li>
<li><code>PathFilter</code> middleware provides additional sandboxing layer</li>
</ul>
<p><strong>What we should verify:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Test symlink creation pointing outside VRootFsBackend</li>
<li><input disabled="" type="checkbox"> Test <code>..</code> in symlink targets</li>
<li><input disabled="" type="checkbox"> Test symlink loops with max depth</li>
</ul>
<hr>
<h3 id="4-java-apache-commons-vfs"><a class="header" href="#4-java-apache-commons-vfs">4. Java: Apache Commons VFS</a></h3>
<p><strong>Repository:</strong> <a href="https://commons.apache.org/vfs/">Apache Commons VFS</a></p>
<p><strong>🔴 CRITICAL VULNERABILITY: CVE in versions &lt; 2.10.0</strong></p>
<p><strong>The Bug:</strong></p>
<pre><code class="language-java">// FileObject API has resolveFile with scope parameter
FileObject file = baseFile.resolveFile("../secret.txt", NameScope.DESCENDENT);
// SHOULD throw exception - "../secret.txt" is not a descendent

// BUT with URL encoding:
FileObject file = baseFile.resolveFile("%2e%2e/secret.txt", NameScope.DESCENDENT);
// DOES NOT throw exception! Returns file outside base directory.
</code></pre>
<p><strong>Root Cause:</strong> Path validation happened BEFORE URL decoding.</p>
<p><strong>Lesson for AnyFS:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - validate then decode
fn resolve(path: &amp;str) -&gt; Result&lt;PathBuf, FsError&gt; {
    validate_no_traversal(path)?;  // Checks for ".."
    let decoded = url_decode(path);  // "../" appears after decode!
    Ok(PathBuf::from(decoded))
}

// CORRECT - decode then validate
fn resolve(path: &amp;str) -&gt; Result&lt;PathBuf, FsError&gt; {
    let decoded = url_decode(path);
    let normalized = normalize_path(&amp;decoded);  // Resolve all ".."
    validate_containment(&amp;normalized)?;
    Ok(normalized)
}
<span class="boring">}</span></code></pre>
<p><strong>Action Items:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Add test: URL-encoded <code>%2e%2e</code> path traversal attempt</li>
<li><input disabled="" type="checkbox"> Add test: Double-encoding <code>%252e%252e</code></li>
<li><input disabled="" type="checkbox"> Ensure path normalization happens BEFORE validation</li>
<li><input disabled="" type="checkbox"> Document in security model</li>
</ul>
<hr>
<h3 id="5-net-systemioabstractions"><a class="header" href="#5-net-systemioabstractions">5. .NET: System.IO.Abstractions</a></h3>
<p><strong>Repository:</strong> <a href="https://github.com/TestableIO/System.IO.Abstractions">TestableIO/System.IO.Abstractions</a></p>
<p><strong>What they do well:</strong></p>
<ol>
<li>
<p><strong>Perfect API Compatibility</strong></p>
<ul>
<li>Mirrors <code>System.IO</code> exactly</li>
<li>Drop-in replacement for testing</li>
</ul>
</li>
<li>
<p><strong>MockFileSystem for Testing</strong></p>
<pre><code class="language-csharp">var fileSystem = new MockFileSystem(new Dictionary&lt;string, MockFileData&gt;
{
    { @"c:\myfile.txt", new MockFileData("Testing") },
    { @"c:\demo\jQuery.js", new MockFileData("jQuery content") },
});

// Use in tests
var sut = new MyComponent(fileSystem);
</code></pre>
</li>
<li>
<p><strong>Analyzers Package</strong></p>
<ul>
<li>Roslyn analyzers warn when using <code>System.IO</code> directly</li>
<li>Guides developers to use abstractions</li>
</ul>
</li>
</ol>
<p><strong>What they lack:</strong></p>
<ul>
<li>No middleware/composition</li>
<li>No caching layer</li>
<li>No sandboxing/path filtering</li>
<li>Testing-focused, not production backends</li>
</ul>
<p><strong>What we should adopt:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Consider Rust analyzer/clippy lint for <code>std::fs</code> usage</li>
<li><input disabled="" type="checkbox"> MockFileSystem pattern is similar to our <code>MemoryBackend</code></li>
</ul>
<hr>
<h3 id="6-nodejs-memfs--unionfs"><a class="header" href="#6-nodejs-memfs--unionfs">6. Node.js: memfs + unionfs</a></h3>
<p><strong>Repository:</strong> <a href="https://github.com/streamich/memfs">streamich/memfs</a></p>
<p><strong>What they do well:</strong></p>
<ol>
<li>
<p><strong>Browser + Node Unified</strong></p>
<ul>
<li>Works in browser via File System API</li>
<li>Same API as Node’s <code>fs</code></li>
</ul>
</li>
<li>
<p><strong>Union Filesystem Composition</strong></p>
<pre><code class="language-javascript">import { Union } from 'unionfs';
import { fs as memfs } from 'memfs';
import * as fs from 'fs';

const ufs = new Union();
ufs.use(fs);        // Real filesystem as base
ufs.use(memfs);     // Memory overlay
</code></pre>
</li>
</ol>
<p><strong>Known Issues:</strong></p>
<blockquote>
<p>“There is a fork of memfs maintained by SageMath (sagemathinc/memfs-js) which was created to fix 13 security vulnerabilities revealed by npm audit. This fork exists because, as their GitHub description notes, ‘there are longstanding bugs’ in the upstream memfs.”</p>
</blockquote>
<p><strong>Lesson:</strong> Even popular libraries can have security issues. Our conformance test suite should be comprehensive.</p>
<hr>
<h2 id="vulnerabilities-summary"><a class="header" href="#vulnerabilities-summary">Vulnerabilities Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Library</th><th>Vulnerability</th><th>Type</th><th>Our Mitigation</th></tr>
</thead>
<tbody>
<tr><td><strong>Apache Commons VFS</strong></td><td>CVE (pre-2.10.0)</td><td>URL-encoded path traversal</td><td>Decode before validate</td></tr>
<tr><td><strong>Afero (Go)</strong></td><td>Issue #282, #88</td><td>Symlink escape from BasePathFs</td><td>Use <code>strict-path</code>, test thoroughly</td></tr>
<tr><td><strong>PyFilesystem2</strong></td><td>Issue #171</td><td>Symlink loop causes infinite recursion</td><td>Loop detection with max depth</td></tr>
<tr><td><strong>memfs (Node)</strong></td><td>13 vulns in npm audit</td><td>Various (unspecified)</td><td>Comprehensive test suite</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="features-comparison-matrix"><a class="header" href="#features-comparison-matrix">Features Comparison Matrix</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th style="text-align: center">fsspec</th><th style="text-align: center">PyFS2</th><th style="text-align: center">Afero</th><th style="text-align: center">Commons VFS</th><th style="text-align: center">System.IO.Abs</th><th style="text-align: center">AnyFS</th></tr>
</thead>
<tbody>
<tr><td>Middleware composition</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Quota enforcement</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Path sandboxing</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Rate limiting</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Caching layer</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Async support</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">🔜</td></tr>
<tr><td>Block-wise caching</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>URL-based opening</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Union/overlay FS</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Memory backend</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>SQLite backend</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>FUSE mounting</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">🔜</td></tr>
<tr><td>Type-safe markers</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="future-ideas-to-consider"><a class="header" href="#future-ideas-to-consider">Future Ideas to Consider</a></h2>
<p>These are optional extensions inspired by other ecosystems. They are intentionally not part of the core scope.</p>
<p><strong>Keep (add-ons that fit the current design):</strong></p>
<ul>
<li>URL-based backend registry (<code>sqlite://</code>, <code>mem://</code>, <code>stdfs://</code>) as a helper crate, not in core APIs.</li>
<li>Bulk operation helpers (<code>read_many</code>, <code>write_many</code>, <code>copy_many</code>, <code>glob</code>, <code>walk</code>) as <code>FsExt</code> or a utilities crate.</li>
<li>Early async adapter crate (<code>anyfs-async</code>) to support remote backends without changing sync traits.</li>
<li>Bash-style shell (example app or <code>anyfs-shell</code> crate) that routes <code>ls/cd/cat/cp/mv/rm/mkdir/stat</code> through <code>FileStorage</code> to demonstrate middleware and backend neutrality (navigation and file management only, not full bash scripting).</li>
<li>Copy-on-write overlay middleware (Afero-style <code>CopyOnWriteFs</code>) as a specialized <code>Overlay</code> variant.</li>
<li>Archive backends (zip/tar) as separate crates implementing <code>Fs</code> (PyFilesystem/fsspec-style).</li>
</ul>
<p><strong>Defer (valuable, but needs data or wider review):</strong></p>
<ul>
<li>Range/block caching middleware for <code>read_range</code> heavy workloads (fsspec-style block cache).</li>
<li>Runtime capability discovery (<code>Capabilities</code> struct) for feature detection (symlink control, case sensitivity, max path length).</li>
<li>Lint/analyzer to discourage direct <code>std::fs</code> usage in app code (System.IO.Abstractions-style).</li>
<li>Retry/timeout middleware for remote backends (once remote backends exist).</li>
</ul>
<p><strong>Drop for now (adds noise or cross-platform complexity):</strong></p>
<ul>
<li>Change notification support (optional <code>FsWatch</code> trait or polling middleware).</li>
</ul>
<hr>
<h2 id="security-tests-to-add"><a class="header" href="#security-tests-to-add">Security Tests to Add</a></h2>
<p>Based on vulnerabilities found in other libraries, add these to our conformance test suite:</p>
<h3 id="path-traversal-tests"><a class="header" href="#path-traversal-tests">Path Traversal Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_url_encoded_path_traversal() {
    let fs = create_sandboxed_fs("/sandbox");

    // These should all fail or be contained
    assert!(fs.read("%2e%2e/etc/passwd").is_err());      // URL-encoded ../
    assert!(fs.read("%252e%252e/secret").is_err());      // Double-encoded
    assert!(fs.read("..%2f..%2fetc/passwd").is_err());   // Mixed encoding
    assert!(fs.read("....//....//etc/passwd").is_err()); // Extra dots
}

#[test]
fn test_symlink_escape() {
    let fs = create_sandboxed_fs("/sandbox");

    // Symlink pointing outside should fail or be contained
    assert!(fs.symlink("/etc/passwd", "/sandbox/link").is_err());
    assert!(fs.symlink("../../../etc/passwd", "/sandbox/link").is_err());

    // Even if symlink created, reading should fail
    fs.symlink("../secret", "/sandbox/link").ok();
    assert!(fs.read("/sandbox/link").is_err());
}

#[test]
fn test_symlink_loop_detection() {
    let fs = MemoryBackend::new();

    // Create loop: a -&gt; b -&gt; a
    fs.symlink("/b", "/a").unwrap();
    fs.symlink("/a", "/b").unwrap();

    // Should detect loop, not hang
    let result = fs.read("/a");
    assert!(matches!(result, Err(FsError::TooManySymlinks { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="resource-exhaustion-tests"><a class="header" href="#resource-exhaustion-tests">Resource Exhaustion Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_deep_directory_traversal() {
    let fs = create_fs_with_depth_limit(64);

    // Creating very deep paths should fail
    let deep_path = "/".to_string() + &amp;"a/".repeat(100);
    assert!(fs.create_dir_all(&amp;deep_path).is_err());
}

#[test]
fn test_many_open_handles() {
    let fs = create_fs();
    let mut handles = vec![];

    // Opening many files shouldn't crash
    for i in 0..10000 {
        fs.write(format!("/file{}", i), b"x").unwrap();
        if let Ok(h) = fs.open_read(format!("/file{}", i)) {
            handles.push(h);
        }
    }
    // Should either succeed or return resource error, not crash
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="action-items"><a class="header" href="#action-items">Action Items</a></h2>
<h3 id="high-priority"><a class="header" href="#high-priority">High Priority</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Task</th><th>Source</th><th>Priority</th></tr>
</thead>
<tbody>
<tr><td>Add URL-encoded path traversal tests</td><td>Apache Commons VFS CVE</td><td>🔴 Critical</td></tr>
<tr><td>Add symlink escape tests for VRootFsBackend</td><td>Afero issues</td><td>🔴 Critical</td></tr>
<tr><td>Add symlink loop detection</td><td>PyFilesystem2 #171</td><td>🔴 Critical</td></tr>
<tr><td>Verify <code>strict-path</code> handles all edge cases</td><td>Afero BasePathFs issues</td><td>🔴 Critical</td></tr>
</tbody>
</table>
</div>
<h3 id="medium-priority-future"><a class="header" href="#medium-priority-future">Medium Priority (Future)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Task</th><th>Source</th><th>Priority</th></tr>
</thead>
<tbody>
<tr><td>Consider block-wise caching for large files</td><td>fsspec</td><td>🟡 Enhancement</td></tr>
<tr><td>Add async support</td><td>fsspec async design</td><td>🟡 Enhancement</td></tr>
<tr><td>URL-based filesystem specification</td><td>PyFilesystem2, Commons VFS</td><td>🟢 Nice-to-have</td></tr>
</tbody>
</table>
</div>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Task</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>Document symlink behavior for each backend</td><td>All libraries have issues</td></tr>
<tr><td>Add security considerations for path handling</td><td>Apache Commons VFS CVE</td></tr>
<tr><td>Compare AnyFS to alternatives</td><td>This analysis</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="sibling-rust-projects-path-security-libraries"><a class="header" href="#sibling-rust-projects-path-security-libraries">Sibling Rust Projects: Path Security Libraries</a></h2>
<p>AnyFS builds on foundational security work from two related Rust crates that specifically address path resolution vulnerabilities. These crates are planned to be used in AnyFS’s path handling implementation.</p>
<h3 id="soft-canonicalize-rs"><a class="header" href="#soft-canonicalize-rs">soft-canonicalize-rs</a></h3>
<p><strong>Repository:</strong> <a href="https://github.com/DK26/soft-canonicalize-rs">DK26/soft-canonicalize-rs</a></p>
<p><strong>Purpose:</strong> Path canonicalization that works with non-existing paths—a critical gap in <code>std::fs::canonicalize</code>.</p>
<p><strong>Security Features:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th><th>Attack Prevented</th></tr>
</thead>
<tbody>
<tr><td>NTFS ADS validation</td><td>Blocks alternate data stream syntax</td><td>Hidden data, path escape</td></tr>
<tr><td>Symlink cycle detection</td><td>Bounded depth tracking</td><td>DoS via infinite loops</td></tr>
<tr><td>Path traversal clamping</td><td>Can’t ascend past root</td><td>Directory escape</td></tr>
<tr><td>Null byte rejection</td><td>Early validation</td><td>Null injection</td></tr>
<tr><td>TOCTOU resistance</td><td>Atomic-like resolution</td><td>Race conditions</td></tr>
<tr><td>Windows UNC handling</td><td>Normalizes extended paths</td><td>Path confusion</td></tr>
<tr><td>Linux namespace preservation</td><td>Uses <code>proc-canonicalize</code></td><td>Container escape via <code>/proc/PID/root</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Key Innovation: Anchored Canonicalization</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All paths (including symlink targets) are clamped to anchor
let result = anchored_canonicalize("/workspace", user_input)?;
// If symlink points to /etc/passwd, result becomes /workspace/etc/passwd
<span class="boring">}</span></code></pre>
<p>This is exactly what <code>VRootFsBackend</code> needs for safe path containment.</p>
<h3 id="strict-path-rs"><a class="header" href="#strict-path-rs">strict-path-rs</a></h3>
<p><strong>Repository:</strong> <a href="https://github.com/DK26/strict-path-rs">DK26/strict-path-rs</a></p>
<p><strong>Purpose:</strong> Type-safe path handling that prevents traversal attacks at compile time.</p>
<p><strong>Two Modes:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>StrictPath</code></td><td>Returns <code>Err(PathEscapesBoundary)</code> on escape</td><td>Archive extraction, file uploads</td></tr>
<tr><td><code>VirtualPath</code></td><td>Clamps escape attempts within sandbox</td><td>Multi-tenant, per-user storage</td></tr>
</tbody>
</table>
</div>
<p><strong>Documented Attack Coverage (19+ vulnerabilities):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attack Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Symlink/junction escapes</td><td>Follows and validates canonical paths</td></tr>
<tr><td>Windows 8.3 short names</td><td>Detects <code>PROGRA~1</code> obfuscation</td></tr>
<tr><td>NTFS Alternate Data Streams</td><td>Blocks <code>file.txt:hidden:$DATA</code></td></tr>
<tr><td>Zip Slip (CVE-2018-1000178)</td><td>Validates archive entries before extraction</td></tr>
<tr><td>TOCTOU (CVE-2022-21658)</td><td>Handles time-of-check-time-of-use races</td></tr>
<tr><td>Unicode/encoding bypasses</td><td>Normalizes path representations</td></tr>
<tr><td>Mixed separators</td><td>Handles <code>/</code> and <code>\</code> on Windows</td></tr>
<tr><td>UNC path tricks</td><td>Prevents <code>\\?\C:\..\..\</code> attacks</td></tr>
</tbody>
</table>
</div>
<p><strong>Type-Safe Marker Pattern (mirrors AnyFS’s design!):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserFiles;
struct SystemFiles;

fn process_user(f: &amp;StrictPath&lt;UserFiles&gt;) { /* ... */ }
// Wrong marker type = compile error
<span class="boring">}</span></code></pre>
<h3 id="applicability-to-anyfs"><a class="header" href="#applicability-to-anyfs">Applicability to AnyFS</a></h3>
<p><strong>Important distinction:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Type</th><th>Storage Mechanism</th><th>Path Resolution Provider</th></tr>
</thead>
<tbody>
<tr><td><code>VRootFsBackend</code></td><td>Real filesystem</td><td>OS (backend is <code>SelfResolving</code>)</td></tr>
<tr><td><code>MemoryBackend</code></td><td>HashMap keys</td><td>FileStorage (symlink-aware)</td></tr>
<tr><td><code>SqliteBackend</code></td><td>DB strings</td><td>FileStorage (symlink-aware)</td></tr>
</tbody>
</table>
</div>
<p><strong>For virtual backends (Memory, SQLite, etc.):</strong></p>
<ul>
<li>These third-party crates perform <strong>real filesystem resolution</strong> (follow actual symlinks on disk)</li>
<li>Virtual backends treat paths as keys, so these crates can’t help</li>
<li>AnyFS implements its own path resolution in <code>FileStorage</code> that:
<ol>
<li>Walks path components via <code>metadata()</code> and <code>read_link()</code></li>
<li>Resolves symlinks by reading targets from virtual storage</li>
<li>Handles <code>..</code> correctly after symlink resolution</li>
<li>Detects loops by tracking visited virtual paths</li>
</ol>
</li>
</ul>
<p><strong>For <code>VRootFsBackend</code> only:</strong></p>
<ul>
<li>Since it wraps the real filesystem, <code>strict-path</code> provides safe containment</li>
<li>The backend implements <code>SelfResolving</code>, so FileStorage skips its own resolution</li>
</ul>
<h3 id="security-tests-added-to-conformance-suite"><a class="header" href="#security-tests-added-to-conformance-suite">Security Tests Added to Conformance Suite</a></h3>
<p>Based on these libraries, we’ve added tests for:</p>
<p><strong>Windows-Specific:</strong></p>
<ul>
<li>NTFS Alternate Data Streams (<code>file.txt:hidden</code>)</li>
<li>Windows 8.3 short names (<code>PROGRA~1</code>)</li>
<li>UNC path traversal (<code>\\?\C:\..\..\</code>)</li>
<li>Reserved device names (CON, PRN, NUL)</li>
<li>Junction point escapes</li>
</ul>
<p><strong>Linux-Specific:</strong></p>
<ul>
<li><code>/proc/PID/root</code> magic symlinks</li>
<li><code>/dev/fd/N</code> file descriptor symlinks</li>
</ul>
<p><strong>Unicode:</strong></p>
<ul>
<li>NFC vs NFD normalization</li>
<li>Right-to-Left Override (U+202E)</li>
<li>Homoglyph confusion (Cyrillic vs Latin)</li>
</ul>
<p><strong>TOCTOU:</strong></p>
<ul>
<li>Check-then-use race conditions</li>
<li>Symlink target changes during resolution</li>
</ul>
<hr>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p><strong>What makes AnyFS unique:</strong></p>
<ol>
<li><strong>Middleware composition</strong> - Only Afero has this, and we do it better (Tower-style)</li>
<li><strong>Quota + rate limiting</strong> - No other library has built-in resource control</li>
<li><strong>Type-safe markers</strong> - Compile-time container isolation is unique to us</li>
<li><strong>SQLite backend</strong> - No other abstraction library offers this</li>
</ol>
<p><strong>What we should learn from others:</strong></p>
<ol>
<li><strong>Path traversal via encoding</strong> - Apache Commons VFS vulnerability</li>
<li><strong>Symlink handling complexity</strong> - All libraries struggle with this</li>
<li><strong>Caching strategies</strong> - fsspec’s block-wise caching is sophisticated</li>
<li><strong>Async support</strong> - fsspec shows how to do this well</li>
</ol>
<p><strong>Critical security tests to add:</strong></p>
<ol>
<li>URL-encoded path traversal (<code>%2e%2e</code>)</li>
<li>Symlink escape from sandboxed directories</li>
<li>Symlink loop detection</li>
<li>Deep path exhaustion</li>
</ol>
<hr>
<h2 id="sources-1"><a class="header" href="#sources-1">Sources</a></h2>
<h3 id="external-libraries"><a class="header" href="#external-libraries">External Libraries</a></h3>
<ul>
<li><a href="https://filesystem-spec.readthedocs.io/">fsspec Documentation</a></li>
<li><a href="https://github.com/PyFilesystem/pyfilesystem2">PyFilesystem2 GitHub</a></li>
<li><a href="https://github.com/spf13/afero">Afero GitHub</a></li>
<li><a href="https://commons.apache.org/vfs/">Apache Commons VFS</a></li>
<li><a href="https://github.com/TestableIO/System.IO.Abstractions">System.IO.Abstractions GitHub</a></li>
<li><a href="https://github.com/streamich/memfs">memfs GitHub</a></li>
</ul>
<h3 id="sibling-rust-projects"><a class="header" href="#sibling-rust-projects">Sibling Rust Projects</a></h3>
<ul>
<li><a href="https://github.com/DK26/soft-canonicalize-rs">soft-canonicalize-rs GitHub</a></li>
<li><a href="https://github.com/DK26/strict-path-rs">strict-path-rs GitHub</a></li>
</ul>
<h3 id="vulnerability-references"><a class="header" href="#vulnerability-references">Vulnerability References</a></h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/search/results?query=Apache%20Commons%20VFS">Apache Commons VFS CVEs (NVD search)</a></li>
<li><a href="https://github.com/spf13/afero/issues/282">Afero BasePathFs Issue #282</a></li>
<li><a href="https://github.com/PyFilesystem/pyfilesystem2/issues/171">PyFilesystem2 Symlink Loop Issue #171</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2018-1000178">CVE-2018-1000178 (Zip Slip)</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-21658">CVE-2022-21658 (TOCTOU in Rust std)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchmarking-plan"><a class="header" href="#benchmarking-plan">Benchmarking Plan</a></h1>
<blockquote>
<p><strong>This document specifies the benchmarking strategy for AnyFS when the implementation exists.</strong>
Functionality and security are the primary goals; performance validation is secondary but important.</p>
</blockquote>
<hr>
<h2 id="goals-1"><a class="header" href="#goals-1">Goals</a></h2>
<ol>
<li><strong>Validate design decisions</strong> - Confirm that the Tower-style middleware approach doesn’t introduce unacceptable overhead</li>
<li><strong>Identify optimization opportunities</strong> - Find hot paths that need attention</li>
<li><strong>Establish baselines</strong> - Know where we stand relative to alternatives</li>
<li><strong>Prevent regressions</strong> - Track performance across versions</li>
</ol>
<hr>
<h2 id="benchmark-categories"><a class="header" href="#benchmark-categories">Benchmark Categories</a></h2>
<h3 id="1-backend-benchmarks"><a class="header" href="#1-backend-benchmarks">1. Backend Benchmarks</a></h3>
<p>Compare AnyFS backends against equivalent solutions for their specific use cases.</p>
<h4 id="memorybackend-vs-alternatives"><a class="header" href="#memorybackend-vs-alternatives">MemoryBackend vs Alternatives</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Competitor</th><th>Use Case</th><th>Why Compare</th></tr>
</thead>
<tbody>
<tr><td><code>std::collections::HashMap</code></td><td>Raw key-value baseline</td><td>Theoretical minimum overhead</td></tr>
<tr><td><code>tempfile</code> + <code>std::fs</code></td><td>In-memory temp files</td><td>Common testing approach</td></tr>
<tr><td><code>vfs::MemoryFS</code></td><td>Virtual filesystem</td><td>Direct competitor</td></tr>
<tr><td><code>virtual-fs</code></td><td>In-memory FS</td><td>Another VFS crate</td></tr>
</tbody>
</table>
</div>
<p><strong>Metrics:</strong></p>
<ul>
<li>Sequential read/write throughput (1KB, 64KB, 1MB, 16MB files)</li>
<li>Random access latency (small reads at random offsets)</li>
<li>Directory listing performance (10, 100, 1000, 10000 entries)</li>
<li>Memory overhead per file/directory</li>
</ul>
<h4 id="sqlitebackend-vs-alternatives"><a class="header" href="#sqlitebackend-vs-alternatives">SqliteBackend vs Alternatives</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Competitor</th><th>Use Case</th><th>Why Compare</th></tr>
</thead>
<tbody>
<tr><td><code>rusqlite</code> raw</td><td>Baseline SQLite performance</td><td>Measure our abstraction cost</td></tr>
<tr><td><code>sled</code></td><td>Embedded database</td><td>Alternative storage engine</td></tr>
<tr><td><code>redb</code></td><td>Embedded database</td><td>Modern alternative</td></tr>
<tr><td>File-per-record</td><td>Direct filesystem</td><td>Traditional approach</td></tr>
</tbody>
</table>
</div>
<p><strong>Metrics:</strong></p>
<ul>
<li>Insert throughput (batch vs individual)</li>
<li>Read throughput (sequential vs random)</li>
<li>Transaction overhead</li>
<li>Database size vs raw file size</li>
<li>Startup time (opening existing database)</li>
</ul>
<h4 id="vrootfsbackend-vs-alternatives"><a class="header" href="#vrootfsbackend-vs-alternatives">VRootFsBackend vs Alternatives</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Competitor</th><th>Use Case</th><th>Why Compare</th></tr>
</thead>
<tbody>
<tr><td><code>std::fs</code> direct</td><td>Baseline filesystem</td><td>Measure containment overhead</td></tr>
<tr><td><code>cap-std</code></td><td>Capability-based FS</td><td>Security-focused alternative</td></tr>
<tr><td><code>chroot</code> simulation</td><td>Traditional sandboxing</td><td>System-level approach</td></tr>
</tbody>
</table>
</div>
<p><strong>Metrics:</strong></p>
<ul>
<li>Path resolution overhead</li>
<li>Symlink traversal cost</li>
<li>Escape attempt detection cost</li>
</ul>
<h3 id="2-middleware-overhead-benchmarks"><a class="header" href="#2-middleware-overhead-benchmarks">2. Middleware Overhead Benchmarks</a></h3>
<p>Measure the cost of each middleware layer.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>What to Measure</th></tr>
</thead>
<tbody>
<tr><td><code>Quota&lt;B&gt;</code></td><td>Size tracking overhead per operation</td></tr>
<tr><td><code>PathFilter&lt;B&gt;</code></td><td>Glob matching cost per path</td></tr>
<tr><td><code>ReadOnly&lt;B&gt;</code></td><td>Should be zero (just error return)</td></tr>
<tr><td><code>RateLimit&lt;B&gt;</code></td><td>Fixed-window counter check overhead</td></tr>
<tr><td><code>Tracing&lt;B&gt;</code></td><td>Span creation/logging cost</td></tr>
<tr><td><code>Cache&lt;B&gt;</code></td><td>Cache hit/miss latency difference</td></tr>
</tbody>
</table>
</div>
<p><strong>Key question:</strong> What’s the cost of a 5-layer middleware stack vs direct backend access?</p>
<p><strong>Target:</strong> Middleware overhead should be &lt;5% of I/O time for typical operations.</p>
<h3 id="3-composition-benchmarks"><a class="header" href="#3-composition-benchmarks">3. Composition Benchmarks</a></h3>
<p>Measure real-world stacks, not isolated components.</p>
<h4 id="ai-agent-sandbox-stack"><a class="header" href="#ai-agent-sandbox-stack">AI Agent Sandbox Stack</a></h4>
<pre><code>Quota → PathFilter → RateLimit → Tracing → MemoryBackend
</code></pre>
<p>Compare against:</p>
<ul>
<li>Raw MemoryBackend (baseline)</li>
<li>Manual checks in application code (alternative approach)</li>
</ul>
<h4 id="persistent-database-stack"><a class="header" href="#persistent-database-stack">Persistent Database Stack</a></h4>
<pre><code>Cache → Tracing → SqliteBackend
</code></pre>
<p>Compare against:</p>
<ul>
<li>Raw SqliteBackend (baseline)</li>
<li>Application-level caching (alternative approach)</li>
</ul>
<h3 id="4-trait-implementation-benchmarks"><a class="header" href="#4-trait-implementation-benchmarks">4. Trait Implementation Benchmarks</a></h3>
<p>Validate that strategic boxing doesn’t hurt performance.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Expected Cost</th></tr>
</thead>
<tbody>
<tr><td><code>read()</code> / <code>write()</code></td><td>Zero-cost (monomorphized)</td></tr>
<tr><td><code>open_read()</code> → <code>Box&lt;dyn Read&gt;</code></td><td>~50ns allocation, negligible vs I/O</td></tr>
<tr><td><code>read_dir()</code> → <code>ReadDirIter</code></td><td>One allocation per call</td></tr>
<tr><td><code>FileStorage::boxed()</code></td><td>One-time cost at setup</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="competitor-matrix"><a class="header" href="#competitor-matrix">Competitor Matrix</a></h2>
<h3 id="by-use-case-1"><a class="header" href="#by-use-case-1">By Use Case</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>AnyFS Component</th><th>Primary Competitors</th></tr>
</thead>
<tbody>
<tr><td>Testing/mocking</td><td>MemoryBackend</td><td><code>tempfile</code>, <code>vfs::MemoryFS</code></td></tr>
<tr><td>Embedded database</td><td>SqliteBackend</td><td><code>sled</code>, <code>redb</code>, raw SQLite</td></tr>
<tr><td>Sandboxed host access</td><td>VRootFsBackend</td><td><code>cap-std</code>, <code>chroot</code></td></tr>
<tr><td>Policy enforcement</td><td>Middleware stack</td><td>Manual application code</td></tr>
<tr><td>Union filesystem</td><td>Overlay</td><td><code>overlayfs</code> (kernel), <code>fuse-overlayfs</code></td></tr>
</tbody>
</table>
</div>
<h3 id="crate-comparison"><a class="header" href="#crate-comparison">Crate Comparison</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Strengths</th><th>Weaknesses</th><th>Compare For</th></tr>
</thead>
<tbody>
<tr><td><code>vfs</code></td><td>Simple API</td><td>No middleware, limited features</td><td>API ergonomics</td></tr>
<tr><td><code>virtual-fs</code></td><td>WASM support</td><td>Less composable</td><td>Cross-platform</td></tr>
<tr><td><code>cap-std</code></td><td>Security-focused</td><td>Different abstraction level</td><td>Sandboxing</td></tr>
<tr><td><code>tempfile</code></td><td>Battle-tested</td><td>Not a VFS</td><td>Temp file operations</td></tr>
<tr><td><code>include_dir</code></td><td>Compile-time embedding</td><td>Read-only</td><td>Embedded assets</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="benchmark-infrastructure"><a class="header" href="#benchmark-infrastructure">Benchmark Infrastructure</a></h2>
<h3 id="framework"><a class="header" href="#framework">Framework</a></h3>
<p>Use <code>criterion</code> for statistical rigor:</p>
<ul>
<li>Warm-up iterations</li>
<li>Outlier detection</li>
<li>Comparison between runs</li>
</ul>
<h3 id="test-data-sets"><a class="header" href="#test-data-sets">Test Data Sets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Dataset</th><th>Contents</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Small files</td><td>1000 files × 1KB</td><td>Metadata-heavy workload</td></tr>
<tr><td>Large files</td><td>10 files × 100MB</td><td>Throughput workload</td></tr>
<tr><td>Deep hierarchy</td><td>10 levels × 10 dirs</td><td>Path resolution stress</td></tr>
<tr><td>Wide directory</td><td>1 dir × 10000 files</td><td>Listing performance</td></tr>
<tr><td>Mixed realistic</td><td>Project-like structure</td><td>Real-world simulation</td></tr>
</tbody>
</table>
</div>
<h3 id="reporting"><a class="header" href="#reporting">Reporting</a></h3>
<p>Generate:</p>
<ul>
<li>Throughput charts (ops/sec, MB/sec)</li>
<li>Latency histograms (p50, p95, p99)</li>
<li>Memory usage graphs</li>
<li>Comparison tables vs competitors</li>
</ul>
<hr>
<h2 id="performance-targets"><a class="header" href="#performance-targets">Performance Targets</a></h2>
<p>These are aspirational targets to validate during implementation:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th>Target</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Middleware overhead</td><td>&lt;5% of I/O time</td><td>Composability shouldn’t cost much</td></tr>
<tr><td>MemoryBackend vs HashMap</td><td>&lt;2x slower</td><td>Abstraction cost</td></tr>
<tr><td>SqliteBackend vs raw SQLite</td><td>&lt;1.5x slower</td><td>Thin wrapper</td></tr>
<tr><td>VRootFsBackend vs std::fs</td><td>&lt;1.2x slower</td><td>Path checking cost</td></tr>
<tr><td>5-layer stack</td><td>&lt;10% overhead</td><td>Real-world composition</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="benchmark-workflow"><a class="header" href="#benchmark-workflow">Benchmark Workflow</a></h2>
<h3 id="development-phase"><a class="header" href="#development-phase">Development Phase</a></h3>
<pre><code>cargo bench --bench &lt;component&gt;
</code></pre>
<p>Run focused benchmarks during development to catch regressions.</p>
<h3 id="release-phase"><a class="header" href="#release-phase">Release Phase</a></h3>
<pre><code>cargo bench --all
</code></pre>
<p>Full benchmark suite before releases, with comparison to previous version.</p>
<h3 id="ci-integration"><a class="header" href="#ci-integration">CI Integration</a></h3>
<ul>
<li>Run subset of benchmarks on PR (smoke test)</li>
<li>Full benchmark suite on main branch</li>
<li>Store results for trend analysis</li>
</ul>
<hr>
<h2 id="non-goals-2"><a class="header" href="#non-goals-2">Non-Goals</a></h2>
<ul>
<li><strong>Beating std::fs at raw I/O</strong> - We add abstraction; some overhead is acceptable</li>
<li><strong>Micro-optimizing cold paths</strong> - Focus on hot paths (read, write, metadata)</li>
<li><strong>Benchmark gaming</strong> - Optimize for real use cases, not synthetic benchmarks</li>
</ul>
<hr>
<h2 id="tracking-1"><a class="header" href="#tracking-1">Tracking</a></h2>
<p><strong>GitHub Issue:</strong> Implement benchmark suite</p>
<ul>
<li><strong>Blocked by:</strong> Core AnyFS implementation</li>
<li><strong>Dependencies:</strong> <code>criterion</code>, test data generation</li>
<li><strong>Milestone:</strong> Post-1.0 (after functionality and security are solid)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementation-plan"><a class="header" href="#implementation-plan">Implementation Plan</a></h1>
<p>This plan describes a phased rollout of the AnyFS ecosystem:</p>
<ul>
<li><code>anyfs-backend</code>: Layered traits (<code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>, <code>FsPosix</code>) + <code>Layer</code> + types</li>
<li><code>anyfs</code>: Built-in backends + middleware (feature-gated) + <code>FileStorage&lt;B, R, M&gt;</code> ergonomic wrapper</li>
</ul>
<hr>
<h2 id="implementation-guidelines"><a class="header" href="#implementation-guidelines">Implementation Guidelines</a></h2>
<p>These guidelines apply to ALL implementation work. Derived from analysis of issues in similar projects (<code>vfs</code>, <code>agentfs</code>).</p>
<h3 id="1-no-panic-policy"><a class="header" href="#1-no-panic-policy">1. No Panic Policy</a></h3>
<p><strong>NEVER panic in library code.</strong> Always return <code>Result&lt;T, FsError&gt;</code>.</p>
<ul>
<li>Audit all <code>.unwrap()</code> and <code>.expect()</code> calls - replace with <code>?</code> or proper error handling</li>
<li>Use <code>ok_or_else(|| FsError::...)</code> instead of <code>.unwrap()</code></li>
<li>Edge cases must return errors, not panic</li>
<li>Test in constrained environments (WASM) to catch hidden panics</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD
let entry = self.entries.get(&amp;path).unwrap();

// GOOD
let entry = self.entries.get(&amp;path)
    .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;
<span class="boring">}</span></code></pre>
<h3 id="2-thread-safety-requirements"><a class="header" href="#2-thread-safety-requirements">2. Thread Safety Requirements</a></h3>
<p>All backends must be safe for concurrent access:</p>
<ul>
<li><code>MemoryBackend</code>: Use <code>Arc&lt;RwLock&lt;...&gt;&gt;</code> for internal state</li>
<li><code>SqliteBackend</code>: Use WAL mode, handle <code>SQLITE_BUSY</code></li>
<li><code>VRootFsBackend</code>: File operations are inherently concurrent-safe</li>
</ul>
<p><strong>Required:</strong> Concurrent stress tests in conformance suite.</p>
<h3 id="3-consistent-path-handling"><a class="header" href="#3-consistent-path-handling">3. Consistent Path Handling</a></h3>
<p>FileStorage handles path resolution via pluggable <code>PathResolver</code> trait (see ADR-033):</p>
<ul>
<li>Always absolute paths internally</li>
<li>Always <code>/</code> separator (even on Windows)</li>
<li>Default <code>IterativeResolver</code>: symlink-aware canonicalization (not lexical)</li>
<li>Handle edge cases: <code>//</code>, trailing <code>/</code>, empty string, circular symlinks</li>
<li>Optional resolver: <code>CachingResolver</code> (for read-heavy workloads)</li>
</ul>
<p><strong>Public canonicalization API on FileStorage:</strong></p>
<ul>
<li><code>canonicalize(path)</code> - strict, all components must exist</li>
<li><code>soft_canonicalize(path)</code> - resolves existing, appends non-existent lexically</li>
<li><code>anchored_canonicalize(path, anchor)</code> - sandboxed resolution</li>
</ul>
<p><strong>Standalone utility:</strong></p>
<ul>
<li><code>normalize(path)</code> - lexical cleanup only (collapses <code>//</code>, removes trailing <code>/</code>). Does NOT resolve <code>.</code> or <code>..</code>.</li>
</ul>
<h3 id="4-error-type-design"><a class="header" href="#4-error-type-design">4. Error Type Design</a></h3>
<p><code>FsError</code> must be:</p>
<ul>
<li>Easy to pattern match</li>
<li>Include context (path, operation)</li>
<li>Derive <code>thiserror</code> for good messages</li>
<li>Use <code>#[non_exhaustive]</code> for forward compatibility</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
#[derive(Debug, thiserror::Error)]
pub enum FsError {
    // Path/File Errors
    #[error("not found: {path}")]
    NotFound { path: PathBuf },

    #[error("{operation}: already exists: {path}")]
    AlreadyExists { path: PathBuf, operation: &amp;'static str },

    #[error("not a file: {path}")]
    NotAFile { path: PathBuf },

    #[error("not a directory: {path}")]
    NotADirectory { path: PathBuf },

    #[error("directory not empty: {path}")]
    DirectoryNotEmpty { path: PathBuf },

    // Permission/Access Errors
    #[error("{operation}: permission denied: {path}")]
    PermissionDenied { path: PathBuf, operation: &amp;'static str },

    #[error("access denied: {path} ({reason})")]
    AccessDenied { path: PathBuf, reason: String },

    #[error("read-only filesystem: {operation}")]
    ReadOnly { operation: &amp;'static str },

    #[error("{operation}: feature not enabled: {feature}")]
    FeatureNotEnabled { feature: &amp;'static str, operation: &amp;'static str },

    // Resource Limit Errors (from Quota middleware)
    #[error("quota exceeded: limit {limit}, requested {requested}, usage {usage}")]
    QuotaExceeded { limit: u64, requested: u64, usage: u64 },

    #[error("file size exceeded: {path} ({size} &gt; {limit})")]
    FileSizeExceeded { path: PathBuf, size: u64, limit: u64 },

    #[error("rate limit exceeded: {limit}/s (window: {window_secs}s)")]
    RateLimitExceeded { limit: u32, window_secs: u64 },

    // ... see design-overview.md for complete list
}
<span class="boring">}</span></code></pre>
<p>See <a href="#error-types">design-overview.md</a> for the complete <code>FsError</code> definition.</p>
<h3 id="5-documentation-requirements"><a class="header" href="#5-documentation-requirements">5. Documentation Requirements</a></h3>
<p>Every backend and middleware must document:</p>
<ul>
<li>Thread safety guarantees</li>
<li>Performance characteristics</li>
<li>Which operations are O(1) vs O(n)</li>
<li>Any platform-specific behavior</li>
</ul>
<hr>
<h2 id="phase-1-anyfs-backend-core-contract"><a class="header" href="#phase-1-anyfs-backend-core-contract">Phase 1: <code>anyfs-backend</code> (core contract)</a></h2>
<p><strong>Goal:</strong> Define the stable backend interface using layered traits.</p>
<h3 id="layered-trait-architecture"><a class="header" href="#layered-trait-architecture">Layered Trait Architecture</a></h3>
<pre><code>                    FsPosix
                       │
        ┌──────────────┼──────────────┐
        │              │              │
   FsHandles      FsLock       FsXattr
        │              │              │
        └──────────────┼──────────────┘
                       │
                    FsFuse
                       │
                   FsInode
                       │
                    FsFull
                       │
        ┌──────┬───────┼───────┬──────┐
        │      │       │       │      │
   FsLink  FsPerm  FsSync FsStats │
        │      │       │       │      │
        └──────┴───────┼───────┴──────┘
                       │
                       Fs  ← Most users only need this
                       │
           ┌───────────┼───────────┐
           │           │           │
        FsRead    FsWrite     FsDir
</code></pre>
<h3 id="core-traits-layer-1---required"><a class="header" href="#core-traits-layer-1---required">Core Traits (Layer 1 - Required)</a></h3>
<ul>
<li><strong><code>FsRead</code></strong>: <code>read</code>, <code>read_to_string</code>, <code>read_range</code>, <code>exists</code>, <code>metadata</code>, <code>open_read</code></li>
<li><strong><code>FsWrite</code></strong>: <code>write</code>, <code>append</code>, <code>remove_file</code>, <code>rename</code>, <code>copy</code>, <code>truncate</code>, <code>open_write</code></li>
<li><strong><code>FsDir</code></strong>: <code>read_dir</code>, <code>create_dir</code>, <code>create_dir_all</code>, <code>remove_dir</code>, <code>remove_dir_all</code></li>
</ul>
<h3 id="extended-traits-layer-2---optional-1"><a class="header" href="#extended-traits-layer-2---optional-1">Extended Traits (Layer 2 - Optional)</a></h3>
<ul>
<li><strong><code>FsLink</code></strong>: <code>symlink</code>, <code>hard_link</code>, <code>read_link</code>, <code>symlink_metadata</code></li>
<li><strong><code>FsPermissions</code></strong>: <code>set_permissions</code></li>
<li><strong><code>FsSync</code></strong>: <code>sync</code>, <code>fsync</code></li>
<li><strong><code>FsStats</code></strong>: <code>statfs</code></li>
</ul>
<h3 id="inode-trait-layer-3---for-fuse"><a class="header" href="#inode-trait-layer-3---for-fuse">Inode Trait (Layer 3 - For FUSE)</a></h3>
<ul>
<li><strong><code>FsInode</code></strong>: <code>path_to_inode</code>, <code>inode_to_path</code>, <code>lookup</code>, <code>metadata_by_inode</code>
<ul>
<li><strong>No blanket/default implementation</strong> - must be explicitly implemented</li>
<li>Required for FUSE mounting and proper hardlink support</li>
<li><code>inode_to_path</code> requires backend to maintain path mappings</li>
</ul>
</li>
</ul>
<h3 id="posix-traits-layer-4---full-posix-1"><a class="header" href="#posix-traits-layer-4---full-posix-1">POSIX Traits (Layer 4 - Full POSIX)</a></h3>
<ul>
<li><strong><code>FsHandles</code></strong>: <code>open</code>, <code>read_at</code>, <code>write_at</code>, <code>close</code></li>
<li><strong><code>FsLock</code></strong>: <code>lock</code>, <code>try_lock</code>, <code>unlock</code></li>
<li><strong><code>FsXattr</code></strong>: <code>get_xattr</code>, <code>set_xattr</code>, <code>remove_xattr</code>, <code>list_xattr</code></li>
</ul>
<h3 id="convenience-supertraits-1"><a class="header" href="#convenience-supertraits-1">Convenience Supertraits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Basic filesystem - covers 90% of use cases
pub trait Fs: FsRead + FsWrite + FsDir {}
impl&lt;T: FsRead + FsWrite + FsDir&gt; Fs for T {}

/// Full filesystem with all std::fs features
pub trait FsFull: Fs + FsLink + FsPermissions + FsSync + FsStats {}

/// FUSE-mountable filesystem
pub trait FsFuse: FsFull + FsInode {}

/// Full POSIX filesystem
pub trait FsPosix: FsFuse + FsHandles + FsLock + FsXattr {}
<span class="boring">}</span></code></pre>
<h3 id="other-definitions"><a class="header" href="#other-definitions">Other Definitions</a></h3>
<ul>
<li>Define <code>Layer</code> trait (Tower-style middleware composition)</li>
<li>Define <code>FsExt</code> trait (extension methods for JSON, type checks)</li>
<li>Define <code>FsPath</code> trait (path canonicalization with default impl, requires <code>FsRead + FsLink</code>)</li>
<li>Define core types (<code>Metadata</code>, <code>Permissions</code>, <code>FileType</code>, <code>DirEntry</code>, <code>StatFs</code>)</li>
<li>Define <code>FsError</code> with contextual variants (see guidelines above)</li>
<li>Define <code>ROOT_INODE = 1</code> constant</li>
<li>Define <code>SelfResolving</code> marker trait (opt-in for backends that handle their own path resolution, e.g., VRootFsBackend)</li>
</ul>
<p><strong>Exit criteria:</strong> <code>anyfs-backend</code> stands alone with minimal dependencies (<code>thiserror</code> required; <code>serde</code> optional for JSON in <code>FsExt</code>).</p>
<hr>
<h2 id="phase-2-anyfs-backends--middleware"><a class="header" href="#phase-2-anyfs-backends--middleware">Phase 2: <code>anyfs</code> (backends + middleware)</a></h2>
<p><strong>Goal:</strong> Provide reference backends and core middleware.</p>
<h3 id="path-resolution-filestorages-responsibility"><a class="header" href="#path-resolution-filestorages-responsibility">Path Resolution (FileStorage’s Responsibility)</a></h3>
<p>FileStorage handles path resolution for ALL backends (unless they implement <code>SelfResolving</code>):</p>
<ul>
<li>Walks path component by component using <code>metadata()</code> and <code>read_link()</code></li>
<li>Handles <code>..</code> correctly after symlink resolution (symlink-aware, not lexical)</li>
<li>Follows symlinks for non-<code>SelfResolving</code> backends that implement <code>FsLink</code> (no toggle)</li>
<li>Detects circular symlinks (max depth or visited set)</li>
<li>Returns canonical resolved path to the backend</li>
</ul>
<p><strong>Backends that don’t implement <code>FsLink</code>:</strong> FileStorage cannot resolve symlinks for these backends. Path resolution will traverse directories using <code>metadata()</code> and handle <code>..</code> based on directory structure, but symlinks are treated as regular files. These backends effectively have no symlink support.</p>
<p><strong>Backends receive already-resolved paths</strong> - they just store/retrieve bytes.</p>
<h3 id="backends-feature-gated"><a class="header" href="#backends-feature-gated">Backends (feature-gated)</a></h3>
<p>Each backend implements the traits it supports:</p>
<ul>
<li><code>memory</code> (default): <code>MemoryBackend</code>
<ul>
<li>Implements: <code>Fs</code> + <code>FsLink</code> + <code>FsPermissions</code> + <code>FsSync</code> + <code>FsStats</code> + <code>FsInode</code> = <code>FsFuse</code></li>
<li>FileStorage handles path resolution (symlink-aware)</li>
<li>Inode source: internal node IDs (incrementing counter)</li>
</ul>
</li>
<li><code>sqlite</code> (optional): <code>SqliteBackend</code>
<ul>
<li>Implements: <code>FsFuse</code> (all traits through Layer 3)</li>
<li>FileStorage handles path resolution (symlink-aware)</li>
<li>Inode source: SQLite row IDs (<code>INTEGER PRIMARY KEY</code>)</li>
</ul>
</li>
<li><code>sqlite-cipher</code> (optional): <code>SqliteCipherBackend</code>
<ul>
<li>Implements: <code>FsFuse</code> (same as SqliteBackend)</li>
<li>Full AES-256 encryption via <a href="https://www.zetetic.net/sqlcipher/">SQLCipher</a></li>
<li>Password-protected: <code>.db</code> file is random bytes without password</li>
<li>Uses <code>rusqlite</code> with <code>bundled-sqlcipher</code> feature</li>
<li><code>open(path, password)</code> - derive key from password (PBKDF2)</li>
<li><code>open_with_key(path, key)</code> - use raw 256-bit key</li>
<li><code>change_password(new_password)</code> - re-key database</li>
<li><strong>Mutually exclusive with <code>sqlite</code> feature</strong> (different SQLite builds)</li>
</ul>
</li>
<li><code>stdfs</code> (optional): <code>StdFsBackend</code> - direct <code>std::fs</code> delegation
<ul>
<li>Implements: <code>FsPosix</code> (all traits including Layer 4) + <code>SelfResolving</code></li>
<li>Implements <code>SelfResolving</code> (OS handles resolution)</li>
<li>Inode source: OS inode numbers (<code>std::fs::Metadata::ino()</code>)</li>
<li>No path containment - full filesystem access</li>
<li>Use when you only need middleware layers without sandboxing</li>
</ul>
</li>
<li><code>vrootfs</code> (optional): <code>VRootFsBackend</code> using <code>strict-path</code> for containment
<ul>
<li>Implements: <code>FsPosix</code> (all traits including Layer 4) + <code>SelfResolving</code></li>
<li>Implements <code>SelfResolving</code> (OS handles resolution, <code>strict-path</code> prevents escapes)</li>
<li>Inode source: OS inode numbers (<code>std::fs::Metadata::ino()</code>)</li>
</ul>
</li>
</ul>
<h3 id="middleware-2"><a class="header" href="#middleware-2">Middleware</a></h3>
<ul>
<li><code>Quota&lt;B&gt;</code> + <code>QuotaLayer</code> - Resource limits</li>
<li><code>Restrictions&lt;B&gt;</code> + <code>RestrictionsLayer</code> - Runtime policy (<code>.deny_permissions()</code>)</li>
<li><code>PathFilter&lt;B&gt;</code> + <code>PathFilterLayer</code> - Path-based access control</li>
<li><code>ReadOnly&lt;B&gt;</code> + <code>ReadOnlyLayer</code> - Block writes</li>
<li><code>RateLimit&lt;B&gt;</code> + <code>RateLimitLayer</code> - Operation throttling</li>
<li><code>Tracing&lt;B&gt;</code> + <code>TracingLayer</code> - Instrumentation</li>
<li><code>DryRun&lt;B&gt;</code> + <code>DryRunLayer</code> - Log without executing</li>
<li><code>Cache&lt;B&gt;</code> + <code>CacheLayer</code> - LRU read cache</li>
<li><code>Overlay&lt;B1,B2&gt;</code> + <code>OverlayLayer</code> - Union filesystem</li>
</ul>
<h3 id="filestorageb-r-m-ergonomic-wrapper"><a class="header" href="#filestorageb-r-m-ergonomic-wrapper">FileStorage&lt;B, R, M&gt; (Ergonomic Wrapper)</a></h3>
<ul>
<li><code>FileStorage&lt;B, R, M&gt;</code> - Zero-cost wrapper with <code>std::fs</code>-aligned API
<ul>
<li>Generic backend <code>B</code> (no boxing, static dispatch)</li>
<li>Generic resolver <code>R</code> (default: <code>IterativeResolver</code>)</li>
<li>Optional marker type <code>M</code> for compile-time container differentiation</li>
<li><code>.boxed()</code> method for opt-in type erasure when needed</li>
</ul>
</li>
<li><code>BackendStack</code> builder for fluent middleware composition</li>
<li>Accepts <code>impl AsRef&lt;Path&gt;</code> in <code>FileStorage</code>/<code>FsExt</code> (core traits use <code>&amp;Path</code>)</li>
<li>Delegates all operations to wrapped backend</li>
</ul>
<p><strong>Axum-style design:</strong> Zero-cost by default, type erasure opt-in.</p>
<p><strong>Note:</strong> <code>FileStorage</code> contains NO policy logic. Policy is handled by middleware.</p>
<p><strong>Exit criteria:</strong> Each backend implements the appropriate trait level (<code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>) and passes conformance suite. Each middleware wraps backends implementing the same traits. Applications can use <code>FileStorage</code> as drop-in for <code>std::fs</code> patterns.</p>
<hr>
<h2 id="phase-3-conformance-test-suite"><a class="header" href="#phase-3-conformance-test-suite">Phase 3: Conformance test suite</a></h2>
<p><strong>Goal:</strong> Prevent backend divergence and validate middleware behavior.</p>
<h3 id="backend-conformance-tests"><a class="header" href="#backend-conformance-tests">Backend conformance tests</a></h3>
<p>Conformance tests are organized by trait layer:</p>
<h4 id="layer-1-fs-core---all-backends-must-pass"><a class="header" href="#layer-1-fs-core---all-backends-must-pass">Layer 1: <code>Fs</code> (Core) - All backends MUST pass</a></h4>
<ul>
<li><strong>FsRead</strong>: <code>read</code>/<code>read_to_string</code>/<code>read_range</code>/<code>exists</code>/<code>metadata</code>/<code>open_read</code></li>
<li><strong>FsWrite</strong>: <code>write</code>/<code>append</code>/<code>remove_file</code>/<code>rename</code>/<code>copy</code>/<code>truncate</code>/<code>open_write</code></li>
<li><strong>FsDir</strong>: <code>read_dir</code>/<code>create_dir*</code>/<code>remove_dir*</code></li>
</ul>
<h4 id="layer-2-fsfull-extended---backends-that-support-these-features"><a class="header" href="#layer-2-fsfull-extended---backends-that-support-these-features">Layer 2: <code>FsFull</code> (Extended) - Backends that support these features</a></h4>
<ul>
<li><strong>FsLink</strong>: <code>symlink</code>/<code>hard_link</code>/<code>read_link</code>/<code>symlink_metadata</code></li>
<li><strong>FsPermissions</strong>: <code>set_permissions</code></li>
<li><strong>FsSync</strong>: <code>sync</code>/<code>fsync</code></li>
<li><strong>FsStats</strong>: <code>statfs</code></li>
</ul>
<h4 id="layer-3-fsfuse-inode---backends-that-support-fuse-mounting"><a class="header" href="#layer-3-fsfuse-inode---backends-that-support-fuse-mounting">Layer 3: <code>FsFuse</code> (Inode) - Backends that support FUSE mounting</a></h4>
<ul>
<li><strong>FsInode</strong>: <code>path_to_inode</code>/<code>inode_to_path</code>/<code>lookup</code>/<code>metadata_by_inode</code></li>
</ul>
<h4 id="layer-4-fsposix-full-posix---backends-that-support-full-posix"><a class="header" href="#layer-4-fsposix-full-posix---backends-that-support-full-posix">Layer 4: <code>FsPosix</code> (Full POSIX) - Backends that support full POSIX</a></h4>
<ul>
<li><strong>FsHandles</strong>: <code>open</code>/<code>read_at</code>/<code>write_at</code>/<code>close</code></li>
<li><strong>FsLock</strong>: <code>lock</code>/<code>try_lock</code>/<code>unlock</code></li>
<li><strong>FsXattr</strong>: <code>get_xattr</code>/<code>set_xattr</code>/<code>remove_xattr</code>/<code>list_xattr</code></li>
</ul>
<h4 id="path-resolution-tests-virtual-backends-only"><a class="header" href="#path-resolution-tests-virtual-backends-only">Path Resolution Tests (virtual backends only)</a></h4>
<ul>
<li><code>/foo/../bar</code> resolves correctly when <code>foo</code> is a regular directory</li>
<li><code>/foo/../bar</code> resolves correctly when <code>foo</code> is a symlink (follows symlink, then <code>..</code>)</li>
<li>Symlink chains resolve correctly (A → B → C → target)</li>
<li>Circular symlink detection (A → B → A returns error, not infinite loop)</li>
<li>Max symlink depth enforced (prevent deep chains)</li>
<li>Reading a symlink follows the target (virtual backends)</li>
</ul>
<h4 id="path-edge-cases-learned-from-vfs-issues"><a class="header" href="#path-edge-cases-learned-from-vfs-issues">Path Edge Cases (learned from <code>vfs</code> issues)</a></h4>
<ul>
<li><code>//double//slashes//</code> normalizes correctly</li>
<li>Note: <code>/foo/../bar</code> requires resolution (see above), not simple normalization</li>
<li>Trailing slashes handled consistently</li>
<li>Empty path returns error (not panic)</li>
<li>Root path <code>/</code> works correctly</li>
<li>Very long paths (near OS limits)</li>
<li>Unicode paths</li>
<li>Paths with spaces and special characters</li>
</ul>
<h4 id="thread-safety-tests-learned-from-vfs-72-47"><a class="header" href="#thread-safety-tests-learned-from-vfs-72-47">Thread Safety Tests (learned from <code>vfs</code> #72, #47)</a></h4>
<ul>
<li>Concurrent <code>read</code> from multiple threads</li>
<li>Concurrent <code>write</code> to different files</li>
<li>Concurrent <code>create_dir_all</code> to same path (must not race)</li>
<li>Concurrent <code>read_dir</code> while modifying directory</li>
<li>Stress test: 100 threads, 1000 operations each</li>
</ul>
<h4 id="error-handling-tests-learned-from-vfs-8-23"><a class="header" href="#error-handling-tests-learned-from-vfs-8-23">Error Handling Tests (learned from <code>vfs</code> #8, #23)</a></h4>
<ul>
<li>Missing file returns <code>NotFound</code>, not panic</li>
<li>Missing parent directory returns error, not panic</li>
<li>Invalid UTF-8 in path returns error, not panic</li>
<li>All error variants are matchable</li>
</ul>
<h4 id="platform-tests"><a class="header" href="#platform-tests">Platform Tests</a></h4>
<ul>
<li>Windows path separators (<code>\</code> vs <code>/</code>)</li>
<li>Case sensitivity differences</li>
<li>Symlink behavior differences</li>
</ul>
<h3 id="middleware-tests"><a class="header" href="#middleware-tests">Middleware tests</a></h3>
<ul>
<li><code>Quota</code>: Limit enforcement, usage tracking, streaming writes</li>
<li><code>Restrictions</code>: Permission blocking via <code>.deny_permissions()</code>, error messages</li>
<li><code>PathFilter</code>: Glob pattern matching, deny-by-default</li>
<li><code>RateLimit</code>: Throttling behavior, burst handling</li>
<li><code>ReadOnly</code>: All write operations blocked</li>
<li><code>Tracing</code>: Operations logged correctly</li>
<li>Middleware composition order (inner to outer)</li>
<li>Middleware with streaming I/O (wrappers work correctly)</li>
</ul>
<h3 id="no-panic-tests"><a class="header" href="#no-panic-tests">No-Panic Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn no_panic_on_missing_file() {
    let backend = create_backend();
    let result = backend.read(std::path::Path::new("/nonexistent"));
    assert!(matches!(result, Err(FsError::NotFound { .. })));
}

#[test]
fn no_panic_on_invalid_operation() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"data").unwrap();
    // Try to read directory on a file
    let result = backend.read_dir(std::path::Path::new("/file.txt"));
    assert!(matches!(result, Err(FsError::NotADirectory { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="wasm-compatibility-tests-learned-from-vfs-68"><a class="header" href="#wasm-compatibility-tests-learned-from-vfs-68">WASM Compatibility Tests (learned from <code>vfs</code> #68)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "wasm32")]
#[wasm_bindgen_test]
fn memory_backend_works_in_wasm() {
    let backend = MemoryBackend::new();
    backend.write(std::path::Path::new("/test.txt"), b"hello").unwrap();
    // Should not panic
}
<span class="boring">}</span></code></pre>
<p><strong>Exit criteria:</strong> All backends pass same suite; middleware tests are backend-agnostic; zero panics in any test.</p>
<hr>
<h2 id="phase-4-documentation--examples"><a class="header" href="#phase-4-documentation--examples">Phase 4: Documentation + examples</a></h2>
<ul>
<li>Keep <code>AGENTS.md</code> and <code>src/architecture/design-overview.md</code> authoritative</li>
<li>Provide example per backend</li>
<li>Provide backend implementer guide</li>
<li>Provide middleware implementer guide</li>
<li>Document performance characteristics per backend</li>
<li>Document thread safety guarantees per backend</li>
<li>Document platform-specific behavior</li>
</ul>
<hr>
<h2 id="phase-5-cicd-pipeline"><a class="header" href="#phase-5-cicd-pipeline">Phase 5: CI/CD Pipeline</a></h2>
<p><strong>Goal:</strong> Ensure quality across platforms and prevent regressions.</p>
<h3 id="cross-platform-testing"><a class="header" href="#cross-platform-testing">Cross-Platform Testing</a></h3>
<pre><code class="language-yaml"># .github/workflows/ci.yml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    rust: [stable, beta]
</code></pre>
<p>Required CI checks:</p>
<ul>
<li><code>cargo test</code> on all platforms</li>
<li><code>cargo clippy -- -D warnings</code></li>
<li><code>cargo fmt --check</code></li>
<li><code>cargo doc --no-deps</code></li>
<li>WASM build test: <code>cargo build --target wasm32-unknown-unknown</code></li>
</ul>
<h3 id="additional-ci-jobs"><a class="header" href="#additional-ci-jobs">Additional CI Jobs</a></h3>
<ul>
<li><strong>Miri</strong> (undefined behavior detection): <code>cargo +nightly miri test</code></li>
<li><strong>Address Sanitizer</strong>: Detect memory issues</li>
<li><strong>Thread Sanitizer</strong>: Detect data races</li>
<li><strong>Coverage</strong>: Minimum 80% line coverage</li>
</ul>
<h3 id="release-checklist"><a class="header" href="#release-checklist">Release Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"> All CI checks pass</li>
<li><input disabled="" type="checkbox"> No new <code>clippy</code> warnings</li>
<li><input disabled="" type="checkbox"> CHANGELOG updated</li>
<li><input disabled="" type="checkbox"> Version bumped appropriately</li>
<li><input disabled="" type="checkbox"> Documentation builds without warnings</li>
</ul>
<hr>
<h2 id="phase-6-mounting-support-fuse-winfsp-features"><a class="header" href="#phase-6-mounting-support-fuse-winfsp-features">Phase 6: Mounting Support (<code>fuse</code>, <code>winfsp</code> features)</a></h2>
<p><strong>Goal:</strong> Make mounting AnyFS stacks easy, safe, and enjoyable for programmers. Mounting is part of the <code>anyfs</code> crate behind feature flags.</p>
<h3 id="milestones"><a class="header" href="#milestones">Milestones</a></h3>
<ul>
<li><strong>Phase 0 (design complete):</strong> API shape and roadmap
<ul>
<li><code>MountHandle</code>, <code>MountBuilder</code>, <code>MountOptions</code>, <code>MountError</code></li>
<li>Platform detection hooks (<code>is_available</code>) and error mapping</li>
<li>Examples anchored in the mounting guide</li>
</ul>
</li>
<li><strong>Phase 1:</strong> Linux FUSE MVP (read-only)
<ul>
<li>Lookup/getattr/readdir/read via <code>fuser</code></li>
<li>Read-only mount option; write ops return <code>PermissionDenied</code></li>
</ul>
</li>
<li><strong>Phase 2:</strong> Linux FUSE read/write
<ul>
<li>Create/write/rename/remove/link operations</li>
<li>Capability reporting and metadata mapping</li>
</ul>
</li>
<li><strong>Phase 3:</strong> macOS parity (macFUSE)
<ul>
<li>Adapter compatibility + driver detection</li>
</ul>
</li>
<li><strong>Phase 4:</strong> Windows support (WinFsp, optional Dokan)
<ul>
<li>Windows-specific mapping + driver detection</li>
</ul>
</li>
</ul>
<p><strong>Exit criteria:</strong> Phase 2 delivered with reliable mount/unmount, no panics, and smoke tests; macOS/Windows continue in subsequent milestones.</p>
<p><strong>API sketch (subject to change):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, QuotaLayer, FsFuse, MountHandle};

// RAM drive with 1GB quota
let backend = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(1024 * 1024 * 1024)
        .build());

// Backend must implement FsFuse (includes FsInode)
let mount = MountHandle::mount(backend, "/mnt/ramdisk")?;

// Now it's a real mount point:
// $ df -h /mnt/ramdisk
// $ cp large_file.bin /mnt/ramdisk/  # fast!
// $ gcc -o /mnt/ramdisk/build ...    # compile in RAM
<span class="boring">}</span></code></pre>
<p><strong>Cross-Platform Support (planned):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Provider</th><th>Rust Crate</th><th>Feature Flag</th><th>User Must Install</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>FUSE</td><td><code>fuser</code></td><td><code>fuse</code></td><td><code>fuse3</code> package</td></tr>
<tr><td>macOS</td><td>macFUSE</td><td><code>fuser</code></td><td><code>fuse</code></td><td><a href="https://osxfuse.github.io/">macFUSE</a></td></tr>
<tr><td>Windows</td><td>WinFsp</td><td><code>winfsp</code></td><td><code>winfsp</code></td><td><a href="https://winfsp.dev/">WinFsp</a></td></tr>
</tbody>
</table>
</div>
<p>The <code>anyfs</code> crate provides a unified API across platforms:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MountHandle {
    #[cfg(unix)]
    pub fn mount&lt;B: FsFuse&gt;(backend: B, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, ...&gt; {
        // Uses fuser crate
    }

    #[cfg(windows)]
    pub fn mount&lt;B: FsFuse&gt;(backend: B, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, ...&gt; {
        // Uses winfsp crate
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Creative Use Cases:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Stack</th><th>What You Get</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>RAM drive</td></tr>
<tr><td><code>MemoryBackend</code> + <code>Quota</code></td><td>RAM drive with size limit</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Single-file portable drive</td></tr>
<tr><td><code>Overlay&lt;SqliteBackend, MemoryBackend&gt;</code></td><td>Persistent base + RAM scratch layer</td></tr>
<tr><td><code>Cache&lt;SqliteBackend&gt;</code></td><td>SQLite with RAM read cache</td></tr>
<tr><td><code>Tracing&lt;MemoryBackend&gt;</code></td><td>RAM drive with full audit log</td></tr>
<tr><td><code>ReadOnly&lt;SqliteBackend&gt;</code></td><td>Immutable snapshot mount</td></tr>
<tr><td><code>Encryption&lt;SqliteBackend&gt;</code></td><td>Encrypted portable drive</td></tr>
</tbody>
</table>
</div>
<p><strong>Example: AI Agent Sandbox</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sandboxed workspace mounted as real filesystem
let sandbox = MountHandle::mount(
    MemoryBackend::new()
        .layer(PathFilterLayer::builder()
            .allow("/**")
            .deny("**/..*")             // No hidden files
            .build())
        .layer(QuotaLayer::builder()
            .max_total_size(100 * 1024 * 1024)
            .build()),
    "/mnt/agent-workspace"
)?;

// Agent's tools can now use standard filesystem APIs
// All operations are sandboxed, logged, and quota-limited
<span class="boring">}</span></code></pre>
<p><strong>Architecture:</strong></p>
<pre><code>┌────────────────────────────────────────────────┐
│  /mnt/myfs (FUSE mount point)                  │
├────────────────────────────────────────────────┤
│  anyfs::mount (fuse/winfsp feature)            │
│    - Linux/macOS: fuser                        │
│    - Windows: winfsp                           │
├────────────────────────────────────────────────┤
│  Middleware stack (Quota, PathFilter, etc.)    │
├────────────────────────────────────────────────┤
│  FsFuse (Memory, SQLite, etc.)                 │
│    └─ includes FsInode for efficient lookups   │
│                                                │
│  Optional: FsPosix for locks/xattr             │
└────────────────────────────────────────────────┘
</code></pre>
<p><strong>Requirements:</strong></p>
<ul>
<li>Backend must implement <code>FsFuse</code> (includes <code>FsInode</code> for efficient inode operations)</li>
<li>Backends implementing <code>FsPosix</code> get full lock/xattr support</li>
<li>Platform-specific FUSE provider must be installed</li>
</ul>
<hr>
<h2 id="future-work-post-mvp"><a class="header" href="#future-work-post-mvp">Future work (post-MVP)</a></h2>
<ul>
<li>Async API (<code>AsyncFs</code>, <code>AsyncFsFull</code>, etc.)</li>
<li>Import/export helpers (host path &lt;-&gt; container)</li>
<li>Encryption middleware</li>
<li>Compression middleware</li>
<li><code>no_std</code> support (learned from <code>vfs</code> #38)</li>
<li>Batch operations for performance (learned from <code>agentfs</code> #130)</li>
<li>URL-based backend registry helper (e.g., <code>sqlite://</code>, <code>mem://</code>)</li>
<li>Copy-on-write overlay variant (Afero-style <code>CopyOnWriteFs</code>)</li>
<li>Archive backends (zip/tar) as separate crates</li>
<li>Indexing middleware with pluggable index backends (SQLite, PostgreSQL, MariaDB, etc.)</li>
<li>Companion shell (<code>anyfs-shell</code>) for interactive exploration of backends and middleware</li>
<li><strong>Language bindings</strong> (<code>anyfs-python</code> via PyO3, C bindings) - see design-overview.md for approach</li>
<li><strong>Dynamic middleware plugin system</strong> (<code>MiddlewarePlugin</code> trait for runtime-loaded <code>.so</code>/<code>.dll</code> plugins)</li>
<li><strong>Metrics middleware</strong> with Prometheus exporter (<code>GET /metrics</code> endpoint)</li>
<li><strong>Configurable tracing/logging backends</strong> (structured logs, CEF events, remote sinks)</li>
</ul>
<h3 id="anyfs-shell---local-companion-shell"><a class="header" href="#anyfs-shell---local-companion-shell"><code>anyfs-shell</code> - Local Companion Shell</a></h3>
<p>Minimal interactive shell for exploring AnyFS behavior without writing a full app. This is a companion crate, not part of the core libraries.</p>
<p><strong>Goals:</strong></p>
<ul>
<li>Route all operations through <code>FileStorage</code> to exercise middleware and backend composition.</li>
<li>Provide a familiar, low-noise CLI for navigation and file management.</li>
<li>Keep scope intentionally small (no scripting, pipes, job control).</li>
</ul>
<p><strong>Command set:</strong></p>
<ul>
<li><code>ls [path]</code> - list directory entries (default: current directory).</li>
<li><code>cd &lt;path&gt;</code> - change working directory.</li>
<li><code>pwd</code> - print current directory.</li>
<li><code>cat &lt;path&gt;</code> - print file contents (UTF-8; error on invalid data).</li>
<li><code>cp &lt;src&gt; &lt;dst&gt;</code> - copy files.</li>
<li><code>mv &lt;src&gt; &lt;dst&gt;</code> - rename/move files.</li>
<li><code>rm &lt;path&gt;</code> - remove file.</li>
<li><code>mkdir &lt;path&gt;</code> - create directory.</li>
<li><code>stat &lt;path&gt;</code> - show metadata (type, size, times, permissions if supported).</li>
<li><code>help</code>, <code>exit</code> - basic shell control.</li>
</ul>
<p><strong>Flags (minimal):</strong></p>
<ul>
<li><code>ls -l</code> - long listing with size/type and modified time (when available).</li>
<li><code>mkdir -p</code> - create intermediate directories.</li>
<li><code>rm -r</code> - remove directory tree.</li>
</ul>
<p><strong>Backend selection (initial sketch):</strong></p>
<ul>
<li><code>--backend mem</code> (default), <code>--backend sqlite --db path</code>, <code>--backend stdfs --root path</code>, <code>--backend vrootfs --root path</code>.</li>
<li><code>--config path</code> to load a small TOML file describing backend + middleware stack.</li>
</ul>
<p><strong>Example session:</strong></p>
<pre><code>anyfs:/ &gt; ls
docs  tmp  hello.txt
anyfs:/ &gt; cat hello.txt
Hello!
anyfs:/ &gt; stat docs
type=dir size=0 modified=2025-02-01T12:34:56Z
anyfs:/ &gt; exit
</code></pre>
<h3 id="anyfs-vfs-compat---interop-with-vfs-crate"><a class="header" href="#anyfs-vfs-compat---interop-with-vfs-crate"><code>anyfs-vfs-compat</code> - Interop with <code>vfs</code> crate</a></h3>
<p>Adapter crate for bidirectional compatibility with the <a href="https://github.com/manuel-woelker/rust-vfs"><code>vfs</code></a> crate ecosystem.</p>
<p><strong>Why not adopt their trait?</strong> The <code>vfs::FileSystem</code> trait is too limited:</p>
<ul>
<li>No symlinks, hard links, or permissions</li>
<li>No <code>sync</code>/<code>fsync</code> for durability</li>
<li>No <code>truncate</code>, <code>statfs</code>, or <code>read_range</code></li>
<li>No middleware composition pattern</li>
</ul>
<p><strong>Our layered traits are a superset</strong> - <code>Fs</code> covers everything <code>vfs::FileSystem</code> does, plus our extended traits add more.</p>
<p><strong>Adapters:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wrap a vfs::FileSystem to use as AnyFS backend
// Only implements Fs (Layer 1) - no links, permissions, etc.
pub struct VfsCompat&lt;F: vfs::FileSystem&gt;(F);
impl&lt;F: vfs::FileSystem&gt; FsRead for VfsCompat&lt;F&gt; { ... }
impl&lt;F: vfs::FileSystem&gt; FsWrite for VfsCompat&lt;F&gt; { ... }
impl&lt;F: vfs::FileSystem&gt; FsDir for VfsCompat&lt;F&gt; { ... }
// VfsCompat&lt;F&gt; implements Fs via blanket impl

// Wrap an AnyFS backend to use as vfs::FileSystem
// Any backend implementing Fs works
pub struct AnyFsCompat&lt;B: Fs&gt;(B);
impl&lt;B: Fs&gt; vfs::FileSystem for AnyFsCompat&lt;B&gt; { ... }
<span class="boring">}</span></code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Migrate from <code>vfs</code> to AnyFS incrementally</li>
<li>Use existing <code>vfs</code> backends (EmbeddedFS) in AnyFS</li>
<li>Use AnyFS backends in projects that depend on <code>vfs</code></li>
</ul>
<h3 id="cloud-storage--remote-access"><a class="header" href="#cloud-storage--remote-access">Cloud Storage &amp; Remote Access</a></h3>
<p>The layered trait design enables building cloud storage services - each adapter requires only the traits it needs.</p>
<p><strong>Architecture:</strong></p>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│                          YOUR SERVER                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Quota&lt;Tracing&lt;SqliteBackend&gt;&gt;  (implements FsFuse)          │  │
│  └───────────────────────────────────────────────────────────────┘  │
│         ▲              ▲              ▲              ▲              │
│         │              │              │              │              │
│    ┌────┴────┐   ┌─────┴─────┐  ┌─────┴─────┐  ┌─────┴─────┐       │
│    │ S3 API  │   │ gRPC/REST │  │    NFS    │  │  WebDAV   │       │
│    │  (Fs)   │   │   (Fs)    │  │ (FsFuse) │  │  (FsFull)│       │
│    └────┬────┘   └─────┬─────┘  └─────┬─────┘  └─────┬─────┘       │
└─────────┼──────────────┼──────────────┼──────────────┼─────────────┘
          │              │              │              │
          ▼              ▼              ▼              ▼
    AWS SDK/CLI    Your SDK/app    mount /cloud   mount /webdav
</code></pre>
<p><strong>Future crates for remote access:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Required Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-s3-server</code></td><td><code>Fs</code></td><td>Expose as S3-compatible API (objects = files)</td></tr>
<tr><td><code>anyfs-sftp-server</code></td><td><code>FsFull</code></td><td>SFTP server with permissions/links</td></tr>
<tr><td><code>anyfs-ssh-shell</code></td><td><code>FsFuse</code></td><td>SSH server with FUSE-mounted home directories</td></tr>
<tr><td><code>anyfs-remote</code></td><td><code>Fs</code></td><td><code>RemoteBackend</code> client (implements <code>Fs</code>)</td></tr>
<tr><td><code>anyfs-grpc</code></td><td><code>Fs</code></td><td>gRPC protocol adapter</td></tr>
<tr><td><code>anyfs-webdav</code></td><td><code>FsFull</code></td><td>WebDAV server (needs permissions)</td></tr>
<tr><td><code>anyfs-nfs</code></td><td><code>FsFuse</code></td><td>NFS server (needs inodes)</td></tr>
</tbody>
</table>
</div>
<h4 id="anyfs-s3-server---s3-compatible-object-storage"><a class="header" href="#anyfs-s3-server---s3-compatible-object-storage"><code>anyfs-s3-server</code> - S3-Compatible Object Storage</a></h4>
<p>Expose any <code>Fs</code> backend as an S3-compatible API. Users access your storage with standard AWS SDKs.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, TracingLayer};
use anyfs_s3_server::S3Server;

// Your storage backend with quotas and audit logging
let backend = SqliteBackend::open("storage.db")?
    .layer(TracingLayer::new())
    .layer(QuotaLayer::builder()
        .max_total_size(100 * 1024 * 1024 * 1024)  // 100GB
        .build());

S3Server::new(backend)
    .with_auth(auth_provider)       // Your auth implementation
    .with_bucket("user-files")      // Virtual bucket name
    .bind("0.0.0.0:9000")
    .run()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>Client usage (standard AWS CLI/SDK):</strong></p>
<pre><code class="language-bash"># Upload a file
aws s3 cp document.pdf s3://user-files/ --endpoint-url http://yourserver:9000

# List files
aws s3 ls s3://user-files/ --endpoint-url http://yourserver:9000

# Download a file
aws s3 cp s3://user-files/document.pdf ./local.pdf --endpoint-url http://yourserver:9000
</code></pre>
<h4 id="anyfs-remote---remote-backend-client"><a class="header" href="#anyfs-remote---remote-backend-client"><code>anyfs-remote</code> - Remote Backend Client</a></h4>
<p>An <code>Fs</code> implementation that connects to a remote server. Works with <code>FileStorage</code> or mounting.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_remote::RemoteBackend;
use anyfs::FileStorage;

// Connect to your cloud service
let remote = RemoteBackend::connect("https://api.yourservice.com")
    .with_auth(api_key)
    .await?;

// Use like any other backend
let fs = FileStorage::new(remote);
fs.write("/documents/report.pdf", data)?;
<span class="boring">}</span></code></pre>
<p><strong>Combined with FUSE for transparent mount:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_remote::RemoteBackend;
use anyfs::MountHandle;

// Mount remote storage as local directory
let remote = RemoteBackend::connect("https://yourserver.com")?;
MountHandle::mount(remote, "/mnt/cloud")?;

// Now use standard filesystem tools:
// $ cp file.txt /mnt/cloud/
// $ ls /mnt/cloud/
// $ cat /mnt/cloud/file.txt
<span class="boring">}</span></code></pre>
<h4 id="anyfs-grpc---grpc-protocol"><a class="header" href="#anyfs-grpc---grpc-protocol"><code>anyfs-grpc</code> - gRPC Protocol</a></h4>
<p>Efficient binary protocol for remote <code>Fs</code> access.</p>
<p><strong>Server side:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_grpc::GrpcServer;

let backend = SqliteBackend::open("storage.db")?;
GrpcServer::new(backend)
    .bind("[::1]:50051")
    .serve()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>Client side:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_grpc::GrpcBackend;

let backend = GrpcBackend::connect("http://[::1]:50051").await?;
let fs = FileStorage::new(backend);
<span class="boring">}</span></code></pre>
<h4 id="multi-tenant-cloud-storage-example"><a class="header" href="#multi-tenant-cloud-storage-example">Multi-Tenant Cloud Storage Example</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, PathFilterLayer, TracingLayer};
use anyfs_s3_server::S3Server;

// Per-tenant backend factory
fn create_tenant_storage(tenant_id: &amp;str, quota_bytes: u64) -&gt; impl Fs {
    let db_path = format!("/data/tenants/{}.db", tenant_id);

    SqliteBackend::open(&amp;db_path).unwrap()
        .layer(TracingLayer::new()
            .with_target(&amp;format!("tenant.{}", tenant_id)))
        .layer(PathFilterLayer::builder()
            .allow("/**")
            .deny("../**")  // No path traversal
            .build())
        .layer(QuotaLayer::builder()
            .max_total_size(quota_bytes)
            .build())
}

// Tenant-aware S3 server
S3Server::new_multi_tenant(|request| {
    let tenant_id = extract_tenant(request)?;
    let quota = get_tenant_quota(tenant_id)?;
    Ok(create_tenant_storage(tenant_id, quota))
})
.bind("0.0.0.0:9000")
.run()
.await?;
<span class="boring">}</span></code></pre>
<h4 id="anyfs-sftp-server---sftp-access-with-shell-commands"><a class="header" href="#anyfs-sftp-server---sftp-access-with-shell-commands"><code>anyfs-sftp-server</code> - SFTP Access with Shell Commands</a></h4>
<p>Expose a <code>FsFull</code> backend as an SFTP server. Users connect with standard SSH/SFTP clients and navigate with familiar shell commands.</p>
<p><strong>Architecture:</strong></p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                      YOUR SERVER                                │
│                                                                 │
│  ┌───────────────┐    ┌───────────────────────────────────────┐ │
│  │ SFTP Server   │───▶│ User's isolated FileStorage           │ │
│  │ (anyfs-sftp)  │    │   └─▶ Quota&lt;SqliteBackend&gt;            │ │
│  │  └───────────────┘    │       └─▶ /data/users/alice.db        │ │
│  │         ▲             └───────────────────────────────────────┘ │
│  └─────────┼───────────────────────────────────────────────────────┘
│            │
│            │ sftp://
│            │
│      ┌─────┴─────┐
│      │  Remote   │  $ cd /documents
│      │  User     │  $ ls
│      │  (shell)  │  $ put file.txt
│      └───────────┘
</code></pre>
<p><strong>Server implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, QuotaLayer, TracingLayer};
use anyfs_sftp_server::SftpServer;

// Per-user isolated backend factory
fn get_user_storage(username: &amp;str) -&gt; impl FsFull {
    let db_path = format!("/data/users/{}.db", username);

    SqliteBackend::open(&amp;db_path).unwrap()
        .layer(TracingLayer::new()
            .with_target(&amp;format!("user.{}", username)))
        .layer(QuotaLayer::builder()
            .max_total_size(10 * 1024 * 1024 * 1024)  // 10GB per user
            .build())
}

SftpServer::new(get_user_storage)
    .with_host_key("/etc/ssh/host_key")
    .bind("0.0.0.0:22")
    .run()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>User experience (standard SFTP client):</strong></p>
<pre><code class="language-bash">$ sftp alice@yourserver.com
Connected to yourserver.com.
sftp&gt; pwd
/
sftp&gt; ls
documents/  photos/  backup/
sftp&gt; cd documents
sftp&gt; ls
report.pdf  notes.txt
sftp&gt; put local_file.txt
Uploading local_file.txt to /documents/local_file.txt
sftp&gt; get notes.txt
Downloading /documents/notes.txt
sftp&gt; mkdir projects
sftp&gt; rm old_file.txt
</code></pre>
<p>All operations happen on the user’s isolated SQLite database on your server.</p>
<h4 id="anyfs-ssh-shell---full-shell-access-with-sandboxed-home"><a class="header" href="#anyfs-ssh-shell---full-shell-access-with-sandboxed-home"><code>anyfs-ssh-shell</code> - Full Shell Access with Sandboxed Home</a></h4>
<p>Give users a real SSH shell where their home directory is backed by <code>FsFuse</code>.</p>
<p><strong>Server implementation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{SqliteBackend, Quota, MountHandle};
use anyfs_ssh_shell::SshShellServer;

// On user login, mount their isolated storage as $HOME
fn on_user_login(username: &amp;str) -&gt; Result&lt;(), Error&gt; {
    let db_path = format!("/data/users/{}.db", username);
    let backend = SqliteBackend::open(&amp;db_path)?
        .layer(QuotaLayer::builder()
            .max_total_size(10 * 1024 * 1024 * 1024)
            .build());

    let mount_point = format!("/home/{}", username);
    MountHandle::mount(backend, &amp;mount_point)?;
    Ok(())
}

SshShellServer::new()
    .on_login(on_user_login)
    .bind("0.0.0.0:22")
    .run()
    .await?;
<span class="boring">}</span></code></pre>
<p><strong>User experience (full shell):</strong></p>
<pre><code class="language-bash">$ ssh alice@yourserver.com
Welcome to YourServer!

alice@server:~$ pwd
/home/alice
alice@server:~$ ls -la
total 3
drwxr-xr-x  4 alice alice 4096 Dec 25 10:00 .
drwxr-xr-x  2 alice alice 4096 Dec 25 10:00 documents
drwxr-xr-x  2 alice alice 4096 Dec 25 10:00 photos

alice@server:~$ cat documents/notes.txt
Hello world!

alice@server:~$ echo "new content" &gt; documents/new_file.txt

alice@server:~$ du -sh .
150M    .

# Everything they do is actually stored in /data/users/alice.db on the server!
# They can use vim, gcc, python - all working on their isolated FsFuse backend
</code></pre>
<h4 id="isolated-shell-hosting-use-cases"><a class="header" href="#isolated-shell-hosting-use-cases">Isolated Shell Hosting Use Cases</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Backend Stack</th><th>What Users Get</th></tr>
</thead>
<tbody>
<tr><td>Shared hosting</td><td><code>Quota&lt;SqliteBackend&gt;</code></td><td>Shell + isolated home in SQLite</td></tr>
<tr><td>Dev containers</td><td><code>Overlay&lt;BaseImage, MemoryBackend&gt;</code></td><td>Shared base + ephemeral scratch</td></tr>
<tr><td>Coding education</td><td><code>Quota&lt;MemoryBackend&gt;</code></td><td>Temporary sandboxed environment</td></tr>
<tr><td>CI/CD runners</td><td><code>Tracing&lt;MemoryBackend&gt;</code></td><td>Audited ephemeral workspace</td></tr>
<tr><td>Secure file drop</td><td><code>PathFilter&lt;SqliteBackend&gt;</code></td><td>Write-only inbox directory</td></tr>
</tbody>
</table>
</div>
<h4 id="access-pattern-summary"><a class="header" href="#access-pattern-summary">Access Pattern Summary</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Access Method</th><th>Crate</th><th>Client Requirement</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td>S3 API</td><td><code>anyfs-s3-server</code></td><td>AWS SDK (any language)</td><td>Object storage, web apps</td></tr>
<tr><td>SFTP</td><td><code>anyfs-sftp-server</code></td><td>Any SFTP client</td><td>Shell-like file access</td></tr>
<tr><td>SSH Shell</td><td><code>anyfs-ssh-shell</code> + <code>anyfs</code> (fuse feature)</td><td>SSH client</td><td>Full shell with sandboxed home</td></tr>
<tr><td>gRPC</td><td><code>anyfs-grpc</code></td><td>Generated client</td><td>High-performance apps</td></tr>
<tr><td>REST</td><td>Custom adapter</td><td>HTTP client</td><td>Simple integrations</td></tr>
<tr><td>FUSE mount</td><td><code>anyfs</code> (fuse feature) + <code>anyfs-remote</code></td><td>FUSE installed</td><td>Transparent local access</td></tr>
<tr><td>WebDAV</td><td><code>anyfs-webdav</code></td><td>WebDAV client/OS</td><td>File manager access</td></tr>
<tr><td>NFS</td><td><code>anyfs-nfs</code></td><td>NFS client</td><td>Unix network shares</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="lessons-learned-reference"><a class="header" href="#lessons-learned-reference">Lessons Learned (Reference)</a></h2>
<p>This plan incorporates lessons from issues in similar projects:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Source</th><th>Issue</th><th>Lesson Applied</th></tr>
</thead>
<tbody>
<tr><td>vfs #72</td><td>RwLock panic</td><td>Thread safety tests</td></tr>
<tr><td>vfs #47</td><td><code>create_dir_all</code> race</td><td>Concurrent stress tests</td></tr>
<tr><td>vfs #8, #23</td><td>Panics instead of errors</td><td>No-panic policy</td></tr>
<tr><td>vfs #24, #42</td><td>Path inconsistencies</td><td>Path edge case tests</td></tr>
<tr><td>vfs #33</td><td>Hard to match errors</td><td>Ergonomic <code>FsError</code> design</td></tr>
<tr><td>vfs #68</td><td>WASM panics</td><td>WASM compatibility tests</td></tr>
<tr><td>vfs #66</td><td><code>'static</code> confusion</td><td>Minimal trait bounds</td></tr>
<tr><td>agentfs #130</td><td>Slow file deletion</td><td>Performance documentation</td></tr>
<tr><td>agentfs #129</td><td>Signal handling</td><td>Proper <code>Drop</code> implementations</td></tr>
</tbody>
</table>
</div>
<p>See <a href="#lessons-from-similar-projects">Lessons from Similar Projects</a> for full analysis.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="backend-implementers-guide"><a class="header" href="#backend-implementers-guide">Backend Implementer’s Guide</a></h1>
<p>This guide walks you through implementing a custom AnyFS backend.</p>
<hr>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>AnyFS uses <strong>layered traits</strong> - you implement only what you need:</p>
<pre><code>FsPosix (full POSIX)
   │
FsFuse (FUSE-mountable)
   │
FsFull (std::fs features)
   │
   Fs (basic - 90% of use cases)
   │
FsRead + FsWrite + FsDir (core)
</code></pre>
<p>Key properties:</p>
<ul>
<li>Backends accept <code>&amp;Path</code> for all path parameters</li>
<li><strong>Backends receive already-resolved paths</strong> - FileStorage handles path resolution via pluggable <code>PathResolver</code> (see ADR-033). Default is <code>IterativeResolver</code> for symlink-aware resolution.</li>
<li>Backends handle <strong>storage only</strong> - just store/retrieve bytes at given paths</li>
<li>Policy (limits, feature gates) is handled by middleware, not backends</li>
<li>Implement only the traits your backend supports</li>
<li><strong>Backends must be thread-safe</strong> - all trait methods use <code>&amp;self</code>, so backends must use interior mutability (e.g., <code>RwLock</code>, <code>Mutex</code>) for synchronization</li>
</ul>
<hr>
<h2 id="dependency"><a class="header" href="#dependency">Dependency</a></h2>
<p>Depend only on <code>anyfs-backend</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs-backend = "0.1"
</code></pre>
<hr>
<h2 id="choosing-which-traits-to-implement"><a class="header" href="#choosing-which-traits-to-implement">Choosing Which Traits to Implement</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Your Backend Supports</th><th>Implement</th></tr>
</thead>
<tbody>
<tr><td>Basic file operations</td><td><code>Fs</code> (= <code>FsRead</code> + <code>FsWrite</code> + <code>FsDir</code>)</td></tr>
<tr><td>Links, permissions, sync</td><td>Add <code>FsLink</code>, <code>FsPermissions</code>, <code>FsSync</code>, <code>FsStats</code></td></tr>
<tr><td>Hardlinks, FUSE mounting</td><td>Add <code>FsInode</code> → becomes <code>FsFuse</code></td></tr>
<tr><td>Full POSIX (handles, locks, xattr)</td><td>Add <code>FsHandles</code>, <code>FsLock</code>, <code>FsXattr</code> → becomes <code>FsPosix</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="minimal-backend-just-fs"><a class="header" href="#minimal-backend-just-fs">Minimal Backend: Just <code>Fs</code></a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, DirEntry};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

pub struct MyBackend {
    // Your storage fields
}

// Implement FsRead
impl FsRead for MyBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt; {
        let data = self.read(path)?;
        String::from_utf8(data).map_err(|e| FsError::Backend(e.to_string()))
    }

    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        todo!()
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        todo!()
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        todo!()
    }

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
        let data = self.read(path)?;
        Ok(Box::new(std::io::Cursor::new(data)))
    }
}

// Implement FsWrite
impl FsWrite for MyBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn append(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn truncate(&amp;self, path: &amp;Path, size: u64) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        todo!()
    }
}

// Implement FsDir
impl FsDir for MyBackend {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        todo!()
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        todo!()
    }
}

// MyBackend now implements Fs automatically (blanket impl)!
<span class="boring">}</span></code></pre>
<hr>
<h2 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h2>
<h3 id="step-1-pick-a-data-model"><a class="header" href="#step-1-pick-a-data-model">Step 1: Pick a Data Model</a></h3>
<p>Your backend needs internal storage. Options:</p>
<ul>
<li><strong>HashMap-based</strong>: <code>HashMap&lt;PathBuf, Entry&gt;</code> for simple cases</li>
<li><strong>Tree-based</strong>: Explicit directory tree structure</li>
<li><strong>Database-backed</strong>: SQLite, key-value store, etc.</li>
</ul>
<p>Minimum metadata per entry:</p>
<ul>
<li>File type (file/directory/symlink)</li>
<li>Size (for files)</li>
<li>Content (for files)</li>
<li>Timestamps (optional)</li>
<li>Permissions (optional)</li>
</ul>
<h3 id="step-2-implement-fsread-layer-1"><a class="header" href="#step-2-implement-fsread-layer-1">Step 2: Implement <code>FsRead</code> (Layer 1)</a></h3>
<p>Start with read operations (easiest):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for MyBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt;;
    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt;;
    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt;;
    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Streaming implementation options:</strong></p>
<p>For <code>MemoryBackend</code> or similar, you can use <code>std::io::Cursor</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
    let data = self.read(path)?;
    Ok(Box::new(std::io::Cursor::new(data)))
}
<span class="boring">}</span></code></pre>
<p>For <code>VRootFsBackend</code>, return the actual file handle:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
    let file = std::fs::File::open(self.resolve(path)?)?;
    Ok(Box::new(file))
}
<span class="boring">}</span></code></pre>
<h3 id="step-3-implement-fswrite-layer-1"><a class="header" href="#step-3-implement-fswrite-layer-1">Step 3: Implement <code>FsWrite</code> (Layer 1)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsWrite for MyBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn append(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn copy(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn truncate(&amp;self, path: &amp;Path, size: u64) -&gt; Result&lt;(), FsError&gt;;
    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Note on truncate:</strong></p>
<ul>
<li>If <code>size &lt; current</code>: discard trailing bytes</li>
<li>If <code>size &gt; current</code>: extend with zero bytes</li>
<li>Required for FUSE support and editor save operations</li>
</ul>
<h3 id="step-4-implement-fsdir-layer-1"><a class="header" href="#step-4-implement-fsdir-layer-1">Step 4: Implement <code>FsDir</code> (Layer 1)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsDir for MyBackend {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt;;
    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Congratulations!</strong> After implementing <code>FsRead</code>, <code>FsWrite</code>, and <code>FsDir</code>, your backend implements <code>Fs</code> automatically (blanket impl). This covers 90% of use cases.</p>
<hr>
<h2 id="optional-layer-2-traits"><a class="header" href="#optional-layer-2-traits">Optional: Layer 2 Traits</a></h2>
<p>Add these if your backend supports the features:</p>
<h3 id="fslink---symlinks-and-hardlinks"><a class="header" href="#fslink---symlinks-and-hardlinks"><code>FsLink</code> - Symlinks and Hardlinks</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsLink for MyBackend {
    fn symlink(&amp;self, original: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn hard_link(&amp;self, original: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
    fn read_link(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn symlink_metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<ul>
<li>Symlinks store a target path as a string</li>
<li>Hard links share content with the original (update link count)</li>
</ul>
<h3 id="fspermissions-1"><a class="header" href="#fspermissions-1"><code>FsPermissions</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsPermissions for MyBackend {
    fn set_permissions(&amp;self, path: &amp;Path, perm: Permissions) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fssync---durability"><a class="header" href="#fssync---durability"><code>FsSync</code> - Durability</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsSync for MyBackend {
    fn sync(&amp;self) -&gt; Result&lt;(), FsError&gt;;
    fn fsync(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<ul>
<li><code>sync()</code>: Flush all pending writes to durable storage</li>
<li><code>fsync(path)</code>: Flush pending writes for a specific file</li>
<li><code>MemoryBackend</code> can no-op these (volatile by design)</li>
<li><code>SqliteBackend</code>: <code>PRAGMA wal_checkpoint</code> or connection flush</li>
<li><code>VRootFsBackend</code>: <code>std::fs::File::sync_all()</code></li>
</ul>
<h3 id="fsstats---filesystem-stats"><a class="header" href="#fsstats---filesystem-stats"><code>FsStats</code> - Filesystem Stats</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsStats for MyBackend {
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>Return filesystem capacity information:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StatFs {
    total_bytes: 0,      // 0 = unlimited
    used_bytes: ...,
    available_bytes: ...,
    total_inodes: 0,
    used_inodes: ...,
    available_inodes: ...,
    block_size: 4096,
    max_name_len: 255,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="optional-layer-3---fsinode-for-fuse"><a class="header" href="#optional-layer-3---fsinode-for-fuse">Optional: Layer 3 - <code>FsInode</code> (For FUSE)</a></h2>
<p>Implement <code>FsInode</code> if you need FUSE mounting or proper hardlink support:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsInode for MyBackend {
    fn path_to_inode(&amp;self, path: &amp;Path) -&gt; Result&lt;u64, FsError&gt;;
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt;;
    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt;;
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>No blanket/default implementation</strong> - you must implement this trait explicitly if you need:</p>
<ul>
<li><strong>FUSE mounting</strong>: FUSE operates on inodes, not paths</li>
<li><strong>Hardlink support</strong>: Two paths must share the same inode</li>
</ul>
<p><strong>Level 1: Simple backend (no FsInode)</strong></p>
<p>Don’t implement <code>FsInode</code>. The backend won’t support FUSE mounting or hardlinks.</p>
<p><strong>Level 2: Hardlink support</strong></p>
<p>Override <code>path_to_inode</code> so hardlinked paths return the same inode:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node {
    id: u64,          // Unique node ID (the inode)
    nlink: u64,       // Hard link count
    content: Vec&lt;u8&gt;,
}

struct MemoryBackend {
    next_id: u64,
    nodes: HashMap&lt;u64, Node&gt;,           // inode -&gt; Node
    paths: HashMap&lt;PathBuf, u64&gt;,        // path -&gt; inode
}

impl FsInode for MemoryBackend {
    fn path_to_inode(&amp;self, path: &amp;Path) -&gt; Result&lt;u64, FsError&gt; {
        self.paths.get(path.as_ref())
            .copied()
            .ok_or_else(|| FsError::NotFound { path: path.as_ref().into() })
    }
    // ... implement others
}

impl FsLink for MemoryBackend {
    fn hard_link(&amp;self, original: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let inode = self.path_to_inode(&amp;original)?;
        self.paths.insert(link.as_ref().to_path_buf(), inode);
        self.nodes.get_mut(&amp;inode).unwrap().nlink += 1;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Level 3: Full FUSE efficiency</strong></p>
<p>Override all 4 methods for O(1) inode operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsInode for SqliteBackend {
    fn path_to_inode(&amp;self, path: &amp;Path) -&gt; Result&lt;u64, FsError&gt; {
        self.conn.query_row(
            "SELECT id FROM nodes WHERE path = ?",
            [path.as_ref().to_string_lossy()],
            |row| Ok(row.get::&lt;_, i64&gt;(0)? as u64),
        ).map_err(|_| FsError::NotFound { path: path.as_ref().into() })
    }

    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.conn.query_row(
            "SELECT path FROM nodes WHERE id = ?",
            [inode as i64],
            |row| Ok(PathBuf::from(row.get::&lt;_, String&gt;(0)?)),
        ).map_err(|_| FsError::NotFound { path: format!("inode:{}", inode).into() })
    }

    fn lookup(&amp;self, parent_inode: u64, name: &amp;OsStr) -&gt; Result&lt;u64, FsError&gt; {
        self.conn.query_row(
            "SELECT id FROM nodes WHERE parent_id = ? AND name = ?",
            params![parent_inode as i64, name.to_string_lossy()],
            |row| Ok(row.get::&lt;_, i64&gt;(0)? as u64),
        ).map_err(|_| FsError::NotFound { path: name.into() })
    }

    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt; {
        self.conn.query_row(
            "SELECT type, size, nlink, created, modified FROM nodes WHERE id = ?",
            [inode as i64],
            |row| Ok(Metadata {
                inode,
                nlink: row.get(2)?,
                // ...
            }),
        ).map_err(|_| FsError::NotFound { path: format!("inode:{}", inode).into() })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Summary:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Your Backend</th><th>Implement</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>Simple (no hardlinks)</td><td>Nothing</td><td>Works with defaults</td></tr>
<tr><td>With hardlinks</td><td><code>FsInode::path_to_inode</code></td><td>Hardlinks work correctly</td></tr>
<tr><td>FUSE-optimized</td><td>Full <code>FsInode</code></td><td>Maximum performance</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="optional-layer-4---posix-traits"><a class="header" href="#optional-layer-4---posix-traits">Optional: Layer 4 - POSIX Traits</a></h2>
<p>For full POSIX semantics (file handles, locking, extended attributes):</p>
<h3 id="fshandles---file-handle-operations"><a class="header" href="#fshandles---file-handle-operations"><code>FsHandles</code> - File Handle Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsHandles for MyBackend {
    fn open(&amp;self, path: &amp;Path, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt;;
    fn read_at(&amp;self, handle: Handle, buf: &amp;mut [u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn write_at(&amp;self, handle: Handle, data: &amp;[u8], offset: u64) -&gt; Result&lt;usize, FsError&gt;;
    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fslock---file-locking"><a class="header" href="#fslock---file-locking"><code>FsLock</code> - File Locking</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsLock for MyBackend {
    fn lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;(), FsError&gt;;
    fn try_lock(&amp;self, handle: Handle, lock: LockType) -&gt; Result&lt;bool, FsError&gt;;
    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="fsxattr---extended-attributes"><a class="header" href="#fsxattr---extended-attributes"><code>FsXattr</code> - Extended Attributes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsXattr for MyBackend {
    fn get_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn set_xattr(&amp;self, path: &amp;Path, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;(), FsError&gt;;
    fn list_xattr(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> Most backends don’t need Layer 4. Only implement if you’re wrapping a real filesystem (<code>VRootFsBackend</code>) or building a database that needs full POSIX semantics.</p>
<hr>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>Return appropriate <code>FsError</code> variants:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Situation</th><th>Error</th></tr>
</thead>
<tbody>
<tr><td>Path doesn’t exist</td><td><code>FsError::NotFound { path, operation }</code></td></tr>
<tr><td>Path already exists</td><td><code>FsError::AlreadyExists { path, operation }</code></td></tr>
<tr><td>Expected file, got dir</td><td><code>FsError::NotAFile { path }</code></td></tr>
<tr><td>Expected dir, got file</td><td><code>FsError::NotADirectory { path }</code></td></tr>
<tr><td>Remove non-empty dir</td><td><code>FsError::DirectoryNotEmpty { path }</code></td></tr>
<tr><td>Internal error</td><td><code>FsError::Backend { message }</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="what-backends-do-not-do"><a class="header" href="#what-backends-do-not-do">What Backends Do NOT Do</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Where It Lives</th></tr>
</thead>
<tbody>
<tr><td>Quota enforcement</td><td><code>Quota&lt;B&gt;</code> middleware</td></tr>
<tr><td>Feature gating</td><td><code>Restrictions&lt;B&gt;</code> middleware</td></tr>
<tr><td>Logging</td><td><code>Tracing&lt;B&gt;</code> middleware</td></tr>
<tr><td>Ergonomic API</td><td><code>FileStorage&lt;B, R, M&gt;</code> wrapper</td></tr>
</tbody>
</table>
</div>
<p><strong>Backends focus on storage.</strong> Keep them simple.</p>
<hr>
<h2 id="optional-optimizations"><a class="header" href="#optional-optimizations">Optional Optimizations</a></h2>
<p>Some trait methods have default implementations that work universally but may be suboptimal for specific backends. You can <strong>override these for better performance</strong>.</p>
<h3 id="path-canonicalization-fspath-trait"><a class="header" href="#path-canonicalization-fspath-trait">Path Canonicalization (FsPath Trait)</a></h3>
<p>The <code>FsPath</code> trait provides <code>canonicalize()</code> and <code>soft_canonicalize()</code> with default implementations that call <code>read_link()</code> and <code>symlink_metadata()</code> per path component.</p>
<p><strong>Default behavior:</strong> O(n) calls for a path with n components</p>
<p><strong>When to override:</strong></p>
<ul>
<li>Your backend can resolve paths more efficiently (e.g., SQL query)</li>
<li>Your backend delegates to OS (which has optimized syscalls)</li>
</ul>
<p><strong>SQLite Example - Single Query Resolution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsPath for SqliteBackend {
    fn canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        // Resolve entire path in one recursive CTE query
        self.conn.query_row(
            r#"
            WITH RECURSIVE resolve(current, depth) AS (
                SELECT :path, 0
                UNION ALL
                SELECT 
                    CASE WHEN n.type = 'symlink' 
                         THEN n.target 
                         ELSE resolve.current 
                    END,
                    depth + 1
                FROM resolve
                LEFT JOIN nodes n ON n.path = resolve.current
                WHERE n.type = 'symlink' AND depth &lt; 40
            )
            SELECT current FROM resolve ORDER BY depth DESC LIMIT 1
            "#,
            params![path.to_string_lossy()],
            |row| Ok(PathBuf::from(row.get::&lt;_, String&gt;(0)?))
        ).map_err(|_| FsError::NotFound { 
            path: path.into(), 
            operation: "canonicalize" 
        })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>VRootFsBackend Example - OS Delegation:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsPath for VRootFsBackend {
    fn canonicalize(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        // Delegate to OS, which uses optimized syscalls
        let host_path = self.root.join(path.strip_prefix("/").unwrap_or(path));
        let resolved = std::fs::canonicalize(&amp;host_path)
            .map_err(|e| FsError::NotFound { 
                path: path.into(), 
                operation: "canonicalize" 
            })?;
        
        // Verify containment (security check)
        if !resolved.starts_with(&amp;self.root) {
            return Err(FsError::AccessDenied {
                path: path.into(),
                reason: "path escapes root".into(),
            });
        }
        
        // Convert back to virtual path
        Ok(PathBuf::from("/").join(resolved.strip_prefix(&amp;self.root).unwrap()))
    }
}
<span class="boring">}</span></code></pre>
<h3 id="other-optimization-opportunities"><a class="header" href="#other-optimization-opportunities">Other Optimization Opportunities</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Default</th><th>Optimization Opportunity</th></tr>
</thead>
<tbody>
<tr><td><code>canonicalize()</code></td><td>O(n) per component</td><td>SQL CTE, OS delegation</td></tr>
<tr><td><code>create_dir_all()</code></td><td>Recursive <code>create_dir()</code></td><td>Single SQL INSERT with path hierarchy</td></tr>
<tr><td><code>remove_dir_all()</code></td><td>Recursive traversal</td><td>SQL DELETE with LIKE pattern</td></tr>
<tr><td><code>copy()</code></td><td>read + write</td><td>Database-level copy, reflink</td></tr>
</tbody>
</table>
</div>
<p><strong>General Pattern:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Override any trait method with optimized implementation
impl FsDir for SqliteBackend {
    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        // Instead of calling create_dir() for each level,
        // insert all parent paths in a single transaction
        self.conn.execute_batch(&amp;format!(
            "INSERT OR IGNORE INTO nodes (path, type) VALUES {}",
            generate_ancestor_values(path)
        ))?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>When NOT to optimize:</strong></p>
<ul>
<li><code>MemoryBackend</code>: In-memory operations are already fast; keep it simple</li>
<li>Low-volume operations: Optimize where it matters (hot paths)</li>
<li>Prototype phase: Get correctness first, optimize later</li>
</ul>
<p>See <a href="#adr-032-path-canonicalization-via-fspath-trait">ADR-032</a> for the full design rationale.</p>
<h2 id="testing-your-backend"><a class="header" href="#testing-your-backend">Testing Your Backend</a></h2>
<p>Use the conformance test suite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::MyBackend;
    use anyfs_backend::Fs;

    fn create_backend() -&gt; MyBackend {
        MyBackend::new()
    }

    #[test]
    fn test_write_read() {
        let backend = create_backend();
        backend.write(std::path::Path::new("/test.txt"), b"hello").unwrap();
        let content = backend.read(std::path::Path::new("/test.txt")).unwrap();
        assert_eq!(content, b"hello");
    }

    #[test]
    fn test_create_dir() {
        let backend = create_backend();
        backend.create_dir(std::path::Path::new("/foo")).unwrap();
        assert!(backend.exists(std::path::Path::new("/foo")).unwrap());
    }

    // ... more tests
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="note-on-vrootfsbackend"><a class="header" href="#note-on-vrootfsbackend">Note on VRootFsBackend</a></h2>
<p>If you are implementing a backend that wraps a <strong>real host filesystem directory</strong>, consider using <code>strict-path::VirtualPath</code> and <code>strict-path::VirtualRoot</code> internally for path containment. This ensures paths cannot escape the designated root directory.</p>
<p>This is an implementation choice for filesystem-based backends, not a requirement of the <code>Fs</code> trait.</p>
<hr>
<h2 id="for-middleware-authors-wrapping-streams"><a class="header" href="#for-middleware-authors-wrapping-streams">For Middleware Authors: Wrapping Streams</a></h2>
<p>Middleware that needs to intercept streaming I/O must wrap the returned <code>Box&lt;dyn Read/Write&gt;</code>.</p>
<h3 id="countingwriter-example"><a class="header" href="#countingwriter-example">CountingWriter Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
use std::sync::{Arc, atomic::{AtomicU64, Ordering}};

pub struct CountingWriter&lt;W: Write&gt; {
    inner: W,
    bytes_written: Arc&lt;AtomicU64&gt;,
}

impl&lt;W: Write&gt; CountingWriter&lt;W&gt; {
    pub fn new(inner: W, counter: Arc&lt;AtomicU64&gt;) -&gt; Self {
        Self { inner, bytes_written: counter }
    }
}

impl&lt;W: Write + Send&gt; Write for CountingWriter&lt;W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        let n = self.inner.write(buf)?;
        self.bytes_written.fetch_add(n as u64, Ordering::Relaxed);
        Ok(n)
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        self.inner.flush()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="using-in-quota-middleware"><a class="header" href="#using-in-quota-middleware">Using in Quota Middleware</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: Fs&gt; Fs for Quota&lt;B&gt; {
    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        // Check if we're at quota before opening
        if self.usage.total_bytes &gt;= self.limits.max_total_size {
            return Err(FsError::QuotaExceeded { ... });
        }

        let inner = self.inner.open_write(path)?;
        Ok(Box::new(CountingWriter::new(inner, self.usage.bytes_counter.clone())))
    }
}
<span class="boring">}</span></code></pre>
<h3 id="alternatives-to-wrapping"><a class="header" href="#alternatives-to-wrapping">Alternatives to Wrapping</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Alternative to wrapping</th></tr>
</thead>
<tbody>
<tr><td>PathFilter</td><td>Check path at open time, pass stream through</td></tr>
<tr><td>ReadOnly</td><td>Block <code>open_write</code> entirely</td></tr>
<tr><td>RateLimit</td><td>Count the open call, not stream bytes</td></tr>
<tr><td>Tracing</td><td>Log the open call, pass stream through</td></tr>
<tr><td>DryRun</td><td>Return <code>std::io::sink()</code> instead of real writer</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="creating-custom-middleware"><a class="header" href="#creating-custom-middleware">Creating Custom Middleware</a></h2>
<p>Custom middleware only requires <code>anyfs-backend</code> as a dependency - same as backends.</p>
<h3 id="dependency-1"><a class="header" href="#dependency-1">Dependency</a></h3>
<pre><code class="language-toml">[dependencies]
anyfs-backend = "0.1"
</code></pre>
<h3 id="the-pattern-5-minutes-to-understand"><a class="header" href="#the-pattern-5-minutes-to-understand">The Pattern (5 Minutes to Understand)</a></h3>
<p>Middleware is just a struct that:</p>
<ol>
<li>Wraps another <code>Fs</code></li>
<li>Implements <code>Fs</code> itself</li>
<li>Intercepts some methods, delegates others</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//  ┌─────────────────────────────────────┐
//  │  Your Middleware                    │
//  │  ┌─────────────────────────────────┐│
//  │  │  Inner Backend (any Fs) ││
//  │  └─────────────────────────────────┘│
//  └─────────────────────────────────────┘
//
//  Request → Middleware (intercept/modify) → Inner Backend
//  Response ← Middleware (intercept/modify) ← Inner Backend
<span class="boring">}</span></code></pre>
<h3 id="simplest-possible-middleware-operation-counter"><a class="header" href="#simplest-possible-middleware-operation-counter">Simplest Possible Middleware: Operation Counter</a></h3>
<p>This middleware counts how many operations are performed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, FsError, Metadata, DirEntry, Permissions, StatFs};
use std::sync::atomic::{AtomicU64, Ordering};
use std::path::{Path, PathBuf};

/// Counts all operations performed on the backend.
pub struct Counter&lt;B&gt; {
    inner: B,
    pub count: AtomicU64,
}

impl&lt;B&gt; Counter&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner, count: AtomicU64::new(0) }
    }

    pub fn operations(&amp;self) -&gt; u64 {
        self.count.load(Ordering::Relaxed)
    }
}

// Implement each trait the inner backend supports
impl&lt;B: FsRead&gt; FsRead for Counter&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);  // Count it
        self.inner.read(path)                         // Delegate
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);
        self.inner.exists(path)
    }

    // ... repeat for all FsRead methods
}

impl&lt;B: FsWrite&gt; FsWrite for Counter&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.count.fetch_add(1, Ordering::Relaxed);  // Count it
        self.inner.write(path, data)                  // Delegate
    }

    // ... repeat for all FsWrite methods
}

impl&lt;B: FsDir&gt; FsDir for Counter&lt;B&gt; {
    // ... implement FsDir methods
}

// Counter&lt;B&gt; now implements Fs when B: Fs (blanket impl)
<span class="boring">}</span></code></pre>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = Counter::new(MemoryBackend::new());
backend.write(std::path::Path::new("/file.txt"), b"hello")?;
backend.read(std::path::Path::new("/file.txt"))?;
backend.read(std::path::Path::new("/file.txt"))?;

println!("Operations: {}", backend.operations());  // 3
<span class="boring">}</span></code></pre>
<p>That’s it. That’s the entire pattern.</p>
<h3 id="adding-a-layer-for-layer-syntax"><a class="header" href="#adding-a-layer-for-layer-syntax">Adding a Layer (for .layer() syntax)</a></h3>
<p>To enable the fluent <code>.layer()</code> syntax, add a Layer struct:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::Layer;

pub struct CounterLayer;

impl&lt;B: Fs&gt; Layer&lt;B&gt; for CounterLayer {
    type Backend = Counter&lt;B&gt;;

    fn layer(self, backend: B) -&gt; Counter&lt;B&gt; {
        Counter::new(backend)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Usage with .layer():</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = MemoryBackend::new()
    .layer(CounterLayer);
<span class="boring">}</span></code></pre>
<h3 id="real-example-readonly-middleware"><a class="header" href="#real-example-readonly-middleware">Real Example: ReadOnly Middleware</a></h3>
<p>A practical middleware that blocks all write operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReadOnly&lt;B&gt; {
    inner: B,
}

impl&lt;B&gt; ReadOnly&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner }
    }
}

// FsRead: just delegate
impl&lt;B: FsRead&gt; FsRead for ReadOnly&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        self.inner.exists(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    // ... delegate all FsRead methods
}

// FsDir: delegate reads, block writes
impl&lt;B: FsDir&gt; FsDir for ReadOnly&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir" })
    }

    fn create_dir_all(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir_all" })
    }

    fn remove_dir(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir" })
    }

    fn remove_dir_all(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir_all" })
    }
}

// FsWrite: block all operations
impl&lt;B: FsWrite&gt; FsWrite for ReadOnly&lt;B&gt; {
    fn write(&amp;self, _path: &amp;Path, _data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "write" })
    }

    fn remove_file(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_file" })
    }

    // ... block all FsWrite methods
}
<span class="boring">}</span></code></pre>
<p><strong>Usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = ReadOnly::new(MemoryBackend::new());

backend.read(std::path::Path::new("/file.txt"));       // OK (if file exists)
backend.write(std::path::Path::new("/file.txt"), b""); // Error: ReadOnly
<span class="boring">}</span></code></pre>
<h3 id="middleware-decision-table"><a class="header" href="#middleware-decision-table">Middleware Decision Table</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>What You Want</th><th>Intercept</th><th>Delegate</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Count operations</td><td>All methods (before)</td><td>All methods</td><td><code>Counter</code></td></tr>
<tr><td>Block writes</td><td>Write methods</td><td>Read methods</td><td><code>ReadOnly</code></td></tr>
<tr><td>Transform data</td><td><code>read</code>/<code>write</code></td><td>Everything else</td><td><code>Encryption</code></td></tr>
<tr><td>Check permissions</td><td>All methods (before)</td><td>All methods</td><td><code>PathFilter</code></td></tr>
<tr><td>Log operations</td><td>All methods (before)</td><td>All methods</td><td><code>Tracing</code></td></tr>
<tr><td>Enforce limits</td><td>Write methods (check size)</td><td>Read methods</td><td><code>Quota</code></td></tr>
</tbody>
</table>
</div>
<h3 id="macro-for-boilerplate-optional"><a class="header" href="#macro-for-boilerplate-optional">Macro for Boilerplate (Optional)</a></h3>
<p>If you don’t want to manually delegate all 29 methods, you can use a macro:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! delegate {
    ($self:ident, $method:ident, $($arg:ident),*) =&gt; {
        $self.inner.$method($($arg),*)
    };
}

impl&lt;B: Fs&gt; Fs for MyMiddleware&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Your logic here
        delegate!(self, read, path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        delegate!(self, exists, path)
    }

    // ... etc
}
<span class="boring">}</span></code></pre>
<p>Or provide a <code>delegate_all!</code> macro in <code>anyfs-backend</code> that generates all the passthrough implementations.</p>
<h3 id="complete-example-encryption-middleware"><a class="header" href="#complete-example-encryption-middleware">Complete Example: Encryption Middleware</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, Layer, FsError, Metadata, DirEntry};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

/// Middleware that encrypts/decrypts file contents transparently.
pub struct Encrypted&lt;B&gt; {
    inner: B,
    key: [u8; 32],
}

impl&lt;B&gt; Encrypted&lt;B&gt; {
    pub fn new(inner: B, key: [u8; 32]) -&gt; Self {
        Self { inner, key }
    }

    fn encrypt(&amp;self, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
        // Your encryption logic here
        data.iter().map(|b| b ^ self.key[0]).collect()
    }

    fn decrypt(&amp;self, data: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
        // Your decryption logic here (symmetric for XOR)
        self.encrypt(data)
    }
}

// FsRead: decrypt on read
impl&lt;B: FsRead&gt; FsRead for Encrypted&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let encrypted = self.inner.read(path)?;
        Ok(self.decrypt(&amp;encrypted))
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        self.inner.exists(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    // ... delegate other FsRead methods
}

// FsWrite: encrypt on write
impl&lt;B: FsWrite&gt; FsWrite for Encrypted&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let encrypted = self.encrypt(data);
        self.inner.write(path, &amp;encrypted)
    }

    // ... delegate/encrypt other FsWrite methods
}

// FsDir: just delegate (directories don't need encryption)
impl&lt;B: FsDir&gt; FsDir for Encrypted&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir(path)
    }

    // ... delegate other FsDir methods
}

// Encrypted&lt;B&gt; now implements Fs when B: Fs (blanket impl)

/// Layer for creating Encrypted middleware.
pub struct EncryptedLayer {
    key: [u8; 32],
}

impl EncryptedLayer {
    pub fn new(key: [u8; 32]) -&gt; Self {
        Self { key }
    }
}

impl&lt;B: Fs&gt; Layer&lt;B&gt; for EncryptedLayer {
    type Backend = Encrypted&lt;B&gt;;

    fn layer(self, backend: B) -&gt; Self::Backend {
        Encrypted::new(backend, self.key)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use my_middleware::{EncryptedLayer, Encrypted};

// Direct construction
let fs = Encrypted::new(MemoryBackend::new(), key);

// Or via Layer trait
let fs = MemoryBackend::new()
    .layer(EncryptedLayer::new(key));
<span class="boring">}</span></code></pre>
<h3 id="middleware-checklist-1"><a class="header" href="#middleware-checklist-1">Middleware Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Depends only on <code>anyfs-backend</code></li>
<li><input disabled="" type="checkbox"> Implements the same traits as the inner backend (<code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code>, etc.)</li>
<li><input disabled="" type="checkbox"> Implements <code>Layer&lt;B&gt;</code> for <code>MyMiddlewareLayer</code></li>
<li><input disabled="" type="checkbox"> Delegates unmodified operations to inner backend</li>
<li><input disabled="" type="checkbox"> Handles streaming I/O appropriately (wrap, pass-through, or block)</li>
<li><input disabled="" type="checkbox"> Documents which operations are intercepted vs delegated</li>
</ul>
<hr>
<h2 id="backend-checklist"><a class="header" href="#backend-checklist">Backend Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Depends only on <code>anyfs-backend</code></li>
<li><input disabled="" type="checkbox"> Implements core traits: <code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code> (= <code>Fs</code>)</li>
<li><input disabled="" type="checkbox"> Optional: Implements <code>FsLink</code>, <code>FsPermissions</code>, <code>FsSync</code>, <code>FsStats</code> (= <code>FsFull</code>)</li>
<li><input disabled="" type="checkbox"> Optional: Implements <code>FsInode</code> for FUSE support (= <code>FsFuse</code>)</li>
<li><input disabled="" type="checkbox"> Optional: Implements <code>FsHandles</code>, <code>FsLock</code>, <code>FsXattr</code> for POSIX (= <code>FsPosix</code>)</li>
<li><input disabled="" type="checkbox"> Accepts <code>&amp;Path</code> for all paths</li>
<li><input disabled="" type="checkbox"> Returns correct <code>FsError</code> variants</li>
<li><input disabled="" type="checkbox"> Passes conformance tests for implemented traits</li>
<li><input disabled="" type="checkbox"> No panics (see below)</li>
<li><input disabled="" type="checkbox"> Thread-safe (see below)</li>
<li><input disabled="" type="checkbox"> Documents performance characteristics</li>
</ul>
<hr>
<h2 id="critical-implementation-guidelines"><a class="header" href="#critical-implementation-guidelines">Critical Implementation Guidelines</a></h2>
<p>These guidelines are derived from issues found in similar projects (<code>vfs</code>, <code>agentfs</code>). <strong>All implementations MUST follow these.</strong></p>
<h3 id="1-no-panic-policy-1"><a class="header" href="#1-no-panic-policy-1">1. No Panic Policy</a></h3>
<p><strong>NEVER use <code>.unwrap()</code> or <code>.expect()</code> in library code.</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - will panic on missing file
fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
    let entry = self.entries.get(path.as_ref()).unwrap();  // PANIC!
    Ok(entry.content.clone())
}

// GOOD - returns error
fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
    let path = path.as_ref();
    let entry = self.entries.get(path)
        .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;
    Ok(entry.content.clone())
}
<span class="boring">}</span></code></pre>
<p><strong>Edge cases that must NOT panic:</strong></p>
<ul>
<li>File doesn’t exist</li>
<li>Directory doesn’t exist</li>
<li>Path is empty string</li>
<li>Path is invalid UTF-8 (if using OsStr)</li>
<li>Parent directory missing</li>
<li>Trying to read a directory as a file</li>
<li>Trying to list a file as a directory</li>
<li>Concurrent access conflicts</li>
</ul>
<h3 id="2-thread-safety-required"><a class="header" href="#2-thread-safety-required">2. Thread Safety (Required)</a></h3>
<p><strong>All trait methods use <code>&amp;self</code>, not <code>&amp;mut self</code>.</strong> This means backends MUST use interior mutability for thread-safe concurrent access.</p>
<p><strong>Why <code>&amp;self</code>?</strong></p>
<ul>
<li>Enables concurrent access patterns (multiple readers, concurrent operations)</li>
<li>Matches real filesystem semantics (concurrent access is normal)</li>
<li>More flexible API (can share references without exclusive ownership)</li>
</ul>
<p><strong>Backend implementer responsibility:</strong></p>
<ul>
<li>Use <code>RwLock</code>, <code>Mutex</code>, or similar for internal state</li>
<li>Ensure operations are atomic (a single <code>write()</code> call shouldn’t produce partial results)</li>
<li>Handle lock poisoning gracefully</li>
</ul>
<p><strong>What the synchronization guarantees:</strong></p>
<ul>
<li>Memory safety (no data corruption)</li>
<li>Atomic operations (writes don’t interleave)</li>
</ul>
<p><strong>What it does NOT guarantee:</strong></p>
<ul>
<li>Order of concurrent writes to the same path (last write wins - standard FS behavior)</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, RwLock};
use std::collections::HashMap;
use std::path::PathBuf;

pub struct MemoryBackend {
    entries: Arc&lt;RwLock&lt;HashMap&lt;PathBuf, Entry&gt;&gt;&gt;,
}

impl FsRead for MemoryBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let entries = self.entries.read()
            .map_err(|_| FsError::Backend("lock poisoned".into()))?;
        // ...
    }
}

impl FsWrite for MemoryBackend {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let mut entries = self.entries.write()
            .map_err(|_| FsError::Backend("lock poisoned".into()))?;
        // ...
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Common race conditions to avoid:</strong></p>
<ul>
<li><code>create_dir_all</code> called concurrently for same path</li>
<li><code>read</code> during <code>write</code> to same file</li>
<li><code>read_dir</code> while directory is being modified</li>
<li><code>rename</code> with concurrent access to source or destination</li>
</ul>
<h3 id="3-path-resolution---not-your-job"><a class="header" href="#3-path-resolution---not-your-job">3. Path Resolution - NOT Your Job</a></h3>
<p><strong>Backends do NOT handle path resolution.</strong> FileStorage handles:</p>
<ul>
<li>Resolving <code>..</code> and <code>.</code> components</li>
<li>Following symlinks for non-<code>SelfResolving</code> backends that implement <code>FsLink</code></li>
<li>Normalizing paths (<code>//</code> → <code>/</code>, trailing slashes, etc.)</li>
<li>Walking the virtual directory structure</li>
</ul>
<p>Your backend receives <strong>already-resolved, clean paths</strong>. Just store and retrieve bytes at those paths.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsRead for MyBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Path is already resolved - just use it directly
        let path = path.as_ref();
        self.storage.get(path).ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Exception:</strong> If your backend wraps a real filesystem (like <code>VRootFsBackend</code>), implement <code>SelfResolving</code> to tell FileStorage to skip resolution - the OS handles it.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SelfResolving for VRootFsBackend {}
<span class="boring">}</span></code></pre>
<h3 id="4-error-messages"><a class="header" href="#4-error-messages">4. Error Messages</a></h3>
<p>Include context in errors for debugging:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - no context
Err(FsError::NotFound)

// GOOD - includes path
Err(FsError::NotFound { path: path.to_path_buf() })

// BETTER - includes operation context
Err(FsError::Io {
    path: path.to_path_buf(),
    operation: "read",
    source: io_error,
})
<span class="boring">}</span></code></pre>
<h3 id="5-drop-implementation"><a class="header" href="#5-drop-implementation">5. Drop Implementation</a></h3>
<p>Ensure cleanup happens correctly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for SqliteBackend {
    fn drop(&amp;mut self) {
        // Flush any pending writes
        if let Err(e) = self.sync() {
            eprintln!("Warning: failed to sync on drop: {}", e);
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="6-performance-documentation"><a class="header" href="#6-performance-documentation">6. Performance Documentation</a></h3>
<p>Document the complexity of operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Memory-based virtual filesystem backend.
///
/// # Performance Characteristics
///
/// | Operation | Complexity | Notes |
/// |-----------|------------|-------|
/// | `read` | O(1) | HashMap lookup |
/// | `write` | O(n) | n = data size |
/// | `read_dir` | O(k) | k = entries in directory |
/// | `create_dir_all` | O(d) | d = path depth |
/// | `remove_dir_all` | O(n) | n = total descendants |
///
/// # Thread Safety
///
/// All operations are thread-safe. Uses `RwLock` internally.
/// Multiple concurrent reads are allowed.
/// Writes are exclusive.
pub struct MemoryBackend { ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="testing-requirements"><a class="header" href="#testing-requirements">Testing Requirements</a></h2>
<p>Your backend MUST pass these test categories:</p>
<h3 id="basic-functionality"><a class="header" href="#basic-functionality">Basic Functionality</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_read_write_roundtrip() { ... }

#[test]
fn test_create_dir_and_list() { ... }

#[test]
fn test_remove_file() { ... }
<span class="boring">}</span></code></pre>
<h3 id="edge-cases-no-panics"><a class="header" href="#edge-cases-no-panics">Edge Cases (No Panics)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_read_nonexistent_returns_error() {
    let backend = create_backend();
    assert!(matches!(
        backend.read(std::path::Path::new("/nonexistent")),
        Err(FsError::NotFound { .. })
    ));
}

#[test]
fn test_read_dir_on_file_returns_error() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"data").unwrap();
    assert!(matches!(
        backend.read_dir(std::path::Path::new("/file.txt")),
        Err(FsError::NotADirectory { .. })
    ));
}

#[test]
fn test_empty_path_returns_error() {
    let backend = create_backend();
    assert!(backend.read(std::path::Path::new("")).is_err());
}
<span class="boring">}</span></code></pre>
<h3 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread Safety</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_concurrent_reads() {
    let backend = Arc::new(create_backend_with_data());
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = backend.clone();
        std::thread::spawn(move || {
            for _ in 0..100 {
                backend.read(std::path::Path::new("/test.txt")).unwrap();
            }
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
}

#[test]
fn test_concurrent_create_dir_all() {
    let backend = Arc::new(RwLock::new(create_backend()));
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = backend.clone();
        std::thread::spawn(move || {
            let mut backend = backend.write().unwrap();
            // Should not panic or corrupt state
            let _ = backend.create_dir_all(std::path::Path::new("/a/b/c/d"));
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
<span class="boring">}</span></code></pre>
<h3 id="path-normalization"><a class="header" href="#path-normalization">Path Normalization</a></h3>
<blockquote>
<p><strong>Note:</strong> These tests apply to <code>FileStorage</code> integration tests, NOT direct backend tests.
Backends receive already-resolved paths from <code>FileStorage</code>. The tests below verify
that <code>FileStorage</code> correctly normalizes paths before passing them to backends.</p>
</blockquote>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_filestorage_path_normalization() {
    // Use FileStorage, not raw backend
    let fs = FileStorage::new(create_backend());
    fs.create_dir_all("/foo/bar").unwrap();
    fs.write("/foo/bar/test.txt", b"data").unwrap();

    // FileStorage resolves these before calling backend
    assert_eq!(fs.read("/foo/bar/test.txt").unwrap(), b"data");
    assert_eq!(fs.read("/foo/bar/../bar/test.txt").unwrap(), b"data");
    assert_eq!(fs.read("/foo/./bar/test.txt").unwrap(), b"data");
}

// Direct backend calls should use clean paths only
#[test]
fn test_backend_with_clean_paths() {
    let backend = create_backend();
    backend.create_dir_all(std::path::Path::new("/foo/bar")).unwrap();
    backend.write(std::path::Path::new("/foo/bar/test.txt"), b"data").unwrap();

    // Backends receive clean, resolved paths
    assert_eq!(backend.read(std::path::Path::new("/foo/bar/test.txt")).unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="memorybackend-snapshot--restore"><a class="header" href="#memorybackend-snapshot--restore">MemoryBackend Snapshot &amp; Restore</a></h2>
<p><code>MemoryBackend</code> supports cloning its entire state (snapshot) and serializing to bytes for persistence.</p>
<h3 id="core-concept"><a class="header" href="#core-concept">Core Concept</a></h3>
<p><strong>Snapshot = Clone the storage.</strong> That’s it.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MemoryBackend implements Clone (custom impl, not derive)
pub struct MemoryBackend { ... }

impl Clone for MemoryBackend {
    fn clone(&amp;self) -&gt; Self {
        // Deep copy of Arc&lt;RwLock&lt;...&gt;&gt; contents
        // ...
    }
}

// Snapshot is just .clone()
let snapshot = fs.clone();

// Restore is just assignment
fs = snapshot;
<span class="boring">}</span></code></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MemoryBackend {
    /// Clone the entire filesystem state.
    /// This is a DEEP COPY - modifications to the clone don't affect the original.
    /// Implemented via custom Clone (not #[derive(Clone)]) to ensure deep copy
    /// of Arc&lt;RwLock&lt;...&gt;&gt; contents.
    pub fn clone(&amp;self) -&gt; Self { ... }

    /// Serialize to bytes for persistence/transfer.
    pub fn to_bytes(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;

    /// Deserialize from bytes.
    pub fn from_bytes(data: &amp;[u8]) -&gt; Result&lt;Self, FsError&gt;;

    /// Save to file.
    pub fn save_to(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;

    /// Load from file.
    pub fn load_from(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="usage-1-1"><a class="header" href="#usage-1-1">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = MemoryBackend::new();
fs.write(std::path::Path::new("/data.txt"), b"important")?;

// Snapshot = clone
let checkpoint = fs.clone();

// Do risky work...
fs.write(std::path::Path::new("/data.txt"), b"corrupted")?;

// Rollback = replace with clone
fs = checkpoint;
assert_eq!(fs.read(std::path::Path::new("/data.txt"))?, b"important");
<span class="boring">}</span></code></pre>
<h3 id="persistence"><a class="header" href="#persistence">Persistence</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Save to disk
fs.save_to("state.bin")?;

// Load from disk
let fs = MemoryBackend::load_from("state.bin")?;
<span class="boring">}</span></code></pre>
<h3 id="sqlitebackend-1"><a class="header" href="#sqlitebackend-1">SqliteBackend</a></h3>
<p>SQLite already has persistence - the database file IS the snapshot. For explicit snapshots:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SqliteBackend {
    /// Create an in-memory copy of the database.
    pub fn clone_to_memory(&amp;self) -&gt; Result&lt;Self, FsError&gt;;

    /// Backup to another file.
    pub fn backup_to(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sqlite-operational-guide"><a class="header" href="#sqlite-operational-guide">SQLite Operational Guide</a></h1>
<p><strong>Production-ready SQLite for filesystem backends</strong></p>
<p>This guide covers everything you need to run SQLite-backed storage at scale.</p>
<hr>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>SQLite is an excellent choice for filesystem backends:</p>
<ul>
<li>Single-file deployment (portable, easy backup)</li>
<li>ACID transactions (data integrity)</li>
<li>Rich query capabilities (dashboards, analytics)</li>
<li>Proven at scale (handles terabytes)</li>
</ul>
<p>But it has specific requirements for concurrent access that you must understand.</p>
<hr>
<h2 id="the-golden-rule-single-writer"><a class="header" href="#the-golden-rule-single-writer">The Golden Rule: Single Writer</a></h2>
<p><strong>SQLite supports many readers but only ONE writer at a time.</strong></p>
<p>Even in WAL mode, concurrent writes will block. This isn’t a bug - it’s a design choice that enables SQLite’s reliability.</p>
<h3 id="the-write-queue-pattern"><a class="header" href="#the-write-queue-pattern">The Write Queue Pattern</a></h3>
<p>For filesystem backends, use a single-writer queue:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::mpsc;
use rusqlite::Connection;

pub struct SqliteBackend {
    /// Read-only connection pool (many readers OK)
    read_pool: Pool&lt;Connection&gt;,

    /// Write commands go through this channel
    write_tx: mpsc::UnboundedSender&lt;WriteCmd&gt;,
}

enum WriteCmd {
    Write { path: PathBuf, data: Vec&lt;u8&gt;, reply: oneshot::Sender&lt;Result&lt;(), FsError&gt;&gt; },
    Remove { path: PathBuf, reply: oneshot::Sender&lt;Result&lt;(), FsError&gt;&gt; },
    Rename { from: PathBuf, to: PathBuf, reply: oneshot::Sender&lt;Result&lt;(), FsError&gt;&gt; },
    CreateDir { path: PathBuf, reply: oneshot::Sender&lt;Result&lt;(), FsError&gt;&gt; },
    // ...
}

// Single writer task
async fn writer_loop(conn: Connection, mut rx: mpsc::UnboundedReceiver&lt;WriteCmd&gt;) {
    while let Some(cmd) = rx.recv().await {
        let result = match cmd {
            WriteCmd::Write { path, data, reply } =&gt; {
                let r = execute_write(&amp;conn, &amp;path, &amp;data);
                let _ = reply.send(r);
            }
            // ... handle other commands
        };
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why this works:</strong></p>
<ul>
<li>No <code>SQLITE_BUSY</code> errors (single writer = no contention)</li>
<li>Predictable latency (queue depth = backpressure)</li>
<li>Natural batching opportunity (combine multiple ops per transaction)</li>
<li>Clean audit logging (all writes go through one place)</li>
</ul>
<hr>
<h2 id="wal-mode-required"><a class="header" href="#wal-mode-required">WAL Mode (Required)</a></h2>
<p><strong>Always enable WAL (Write-Ahead Logging) mode for concurrent access.</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_connection(path: &amp;Path) -&gt; Result&lt;Connection, rusqlite::Error&gt; {
    let conn = Connection::open(path)?;

    // Enable WAL mode (persistent - only need to set once per database)
    conn.execute_batch("
        PRAGMA journal_mode = WAL;
        PRAGMA synchronous = NORMAL;
        PRAGMA cache_size = -64000;  -- 64MB cache
        PRAGMA temp_store = MEMORY;
    ")?;

    Ok(conn)
}
<span class="boring">}</span></code></pre>
<h3 id="wal-vs-rollback-journal"><a class="header" href="#wal-vs-rollback-journal">WAL vs Rollback Journal</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>WAL Mode</th><th>Rollback Journal</th></tr>
</thead>
<tbody>
<tr><td>Concurrent reads during write</td><td>✅ Yes</td><td>❌ No (blocked)</td></tr>
<tr><td>Read performance</td><td>Faster</td><td>Slower</td></tr>
<tr><td>Write performance</td><td>Similar</td><td>Similar</td></tr>
<tr><td>File count</td><td>3 files (.db, .wal, .shm)</td><td>1-2 files</td></tr>
<tr><td>Crash recovery</td><td>Automatic</td><td>Automatic</td></tr>
</tbody>
</table>
</div>
<p><strong>Always use WAL for filesystem backends.</strong></p>
<h3 id="wal-checkpointing"><a class="header" href="#wal-checkpointing">WAL Checkpointing</a></h3>
<p>WAL files grow until checkpointed. SQLite auto-checkpoints at 1000 pages, but you can control this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual checkpoint (call periodically or after bulk operations)
conn.execute_batch("PRAGMA wal_checkpoint(TRUNCATE);")?;

// Or configure auto-checkpoint threshold
conn.execute_batch("PRAGMA wal_autocheckpoint = 1000;")?;  // pages
<span class="boring">}</span></code></pre>
<p><strong>Checkpoint modes:</strong></p>
<ul>
<li><code>PASSIVE</code> - Checkpoint without blocking writers (may not complete)</li>
<li><code>FULL</code> - Wait for writers, then checkpoint completely</li>
<li><code>RESTART</code> - Like FULL, but also resets WAL file</li>
<li><code>TRUNCATE</code> - Like RESTART, but truncates WAL to zero bytes</li>
</ul>
<p>For filesystem backends, run <code>TRUNCATE</code> checkpoint:</p>
<ul>
<li>During quiet periods</li>
<li>After bulk imports</li>
<li>Before backups</li>
</ul>
<hr>
<h2 id="busy-handling"><a class="header" href="#busy-handling">Busy Handling</a></h2>
<p>Even with a write queue, reads might briefly block during checkpoints. Handle this gracefully:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn open_connection(path: &amp;Path) -&gt; Result&lt;Connection, rusqlite::Error&gt; {
    let conn = Connection::open(path)?;

    // Wait up to 30 seconds if database is busy
    conn.busy_timeout(Duration::from_secs(30))?;

    // Or use a custom busy handler
    conn.busy_handler(Some(|attempts| {
        if attempts &gt; 100 {
            false  // Give up after 100 retries
        } else {
            std::thread::sleep(Duration::from_millis(10 * attempts as u64));
            true   // Keep trying
        }
    }))?;

    Ok(conn)
}
<span class="boring">}</span></code></pre>
<p><strong>Never let <code>SQLITE_BUSY</code> propagate to users</strong> - it’s a transient condition.</p>
<hr>
<h2 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h2>
<p>For read operations, use a connection pool:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2d2::{Pool, PooledConnection};
use r2d2_sqlite::SqliteConnectionManager;

pub struct SqliteBackend {
    read_pool: Pool&lt;SqliteConnectionManager&gt;,
    write_tx: mpsc::UnboundedSender&lt;WriteCmd&gt;,
}

impl SqliteBackend {
    pub fn open(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, FsError&gt; {
        let manager = SqliteConnectionManager::file(path.as_ref())
            .with_flags(rusqlite::OpenFlags::SQLITE_OPEN_READ_ONLY);

        let read_pool = Pool::builder()
            .max_size(10)  // 10 concurrent readers
            .build(manager)
            .map_err(|e| FsError::Backend(e.to_string()))?;

        // ... set up write queue

        Ok(Self { read_pool, write_tx })
    }
}

impl FsRead for SqliteBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let conn = self.read_pool.get()
            .map_err(|e| FsError::Backend(format!("pool exhausted: {}", e)))?;

        // Use read-only connection
        query_file_content(&amp;conn, path.as_ref())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Pool sizing:</strong></p>
<ul>
<li>Start with <code>max_size = CPU cores * 2</code></li>
<li>Monitor pool exhaustion</li>
<li>Increase if reads queue up</li>
</ul>
<hr>
<h2 id="vacuum-and-maintenance"><a class="header" href="#vacuum-and-maintenance">Vacuum and Maintenance</a></h2>
<p>SQLite doesn’t automatically reclaim space from deleted data. You need <code>VACUUM</code>.</p>
<h3 id="auto-vacuum-recommended"><a class="header" href="#auto-vacuum-recommended">Auto-Vacuum (Recommended)</a></h3>
<p>Enable incremental auto-vacuum for gradual space reclamation:</p>
<pre><code class="language-sql">-- Set once when creating the database
PRAGMA auto_vacuum = INCREMENTAL;

-- Then periodically run (e.g., daily or after large deletes)
PRAGMA incremental_vacuum(1000);  -- Free up to 1000 pages
</code></pre>
<h3 id="manual-vacuum"><a class="header" href="#manual-vacuum">Manual Vacuum</a></h3>
<p>Full vacuum rebuilds the entire database (expensive but thorough):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SqliteBackend {
    /// Compact the database. Call during maintenance windows.
    pub fn vacuum(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        // Vacuum needs exclusive access - pause writes
        let conn = self.get_write_connection()?;

        // This can take a long time for large databases
        conn.execute_batch("VACUUM;")?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>When to vacuum:</strong></p>
<ul>
<li>After deleting &gt;25% of data</li>
<li>After schema migrations</li>
<li>During scheduled maintenance</li>
<li>Never during peak usage</li>
</ul>
<h3 id="integrity-check"><a class="header" href="#integrity-check">Integrity Check</a></h3>
<p>Periodically verify database integrity:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SqliteBackend {
    pub fn check_integrity(&amp;self) -&gt; Result&lt;bool, FsError&gt; {
        let conn = self.read_pool.get()?;

        let result: String = conn.query_row(
            "PRAGMA integrity_check;",
            [],
            |row| row.get(0),
        )?;

        Ok(result == "ok")
    }
}
<span class="boring">}</span></code></pre>
<p>Run integrity checks:</p>
<ul>
<li>After crash recovery</li>
<li>Before backups</li>
<li>Periodically (weekly/monthly)</li>
</ul>
<hr>
<h2 id="schema-migrations"><a class="header" href="#schema-migrations">Schema Migrations</a></h2>
<p>Filesystem schemas evolve. Handle migrations properly:</p>
<h3 id="version-tracking"><a class="header" href="#version-tracking">Version Tracking</a></h3>
<pre><code class="language-sql">-- Store schema version in the database
CREATE TABLE IF NOT EXISTS meta (
    key TEXT PRIMARY KEY,
    value TEXT
);

INSERT OR REPLACE INTO meta (key, value) VALUES ('schema_version', '1');
</code></pre>
<h3 id="migration-pattern"><a class="header" href="#migration-pattern">Migration Pattern</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CURRENT_VERSION: i32 = 3;

impl SqliteBackend {
    fn migrate(&amp;self, conn: &amp;Connection) -&gt; Result&lt;(), FsError&gt; {
        let version: i32 = conn.query_row(
            "SELECT COALESCE((SELECT value FROM meta WHERE key = 'schema_version'), '0')",
            [],
            |row| row.get::&lt;_, String&gt;(0)?.parse().map_err(|_| rusqlite::Error::InvalidQuery),
        ).unwrap_or(0);

        if version &lt; 1 {
            self.migrate_v0_to_v1(conn)?;
        }
        if version &lt; 2 {
            self.migrate_v1_to_v2(conn)?;
        }
        if version &lt; 3 {
            self.migrate_v2_to_v3(conn)?;
        }

        conn.execute(
            "INSERT OR REPLACE INTO meta (key, value) VALUES ('schema_version', ?)",
            [CURRENT_VERSION.to_string()],
        )?;

        Ok(())
    }

    fn migrate_v1_to_v2(&amp;self, conn: &amp;Connection) -&gt; Result&lt;(), FsError&gt; {
        conn.execute_batch("
            -- Add new column
            ALTER TABLE nodes ADD COLUMN checksum TEXT;

            -- Backfill (expensive but necessary)
            -- UPDATE nodes SET checksum = compute_checksum(content) WHERE content IS NOT NULL;
        ")?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Migration rules:</strong></p>
<ul>
<li>Always wrap in transaction</li>
<li>Test migrations on copy of production data</li>
<li>Have rollback plan (backup before migration)</li>
<li>Never delete columns in SQLite (not supported) - add new ones instead</li>
</ul>
<hr>
<h2 id="backup-strategies"><a class="header" href="#backup-strategies">Backup Strategies</a></h2>
<h3 id="online-backup-api-recommended"><a class="header" href="#online-backup-api-recommended">Online Backup API (Recommended)</a></h3>
<p>SQLite’s backup API creates consistent snapshots of a live database:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rusqlite::backup::{Backup, Progress};

impl SqliteBackend {
    /// Create a consistent backup while database is in use.
    pub fn backup(&amp;self, dest_path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        let src = self.get_read_connection()?;
        let mut dest = Connection::open(dest_path.as_ref())?;

        let backup = Backup::new(&amp;src, &amp;mut dest)?;

        // Copy in chunks (allows progress reporting)
        loop {
            let more = backup.step(100)?;  // 100 pages at a time

            if !more {
                break;
            }

            // Optional: report progress
            let progress = backup.progress();
            println!("Backup: {}/{} pages", progress.pagecount - progress.remaining, progress.pagecount);
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>No downtime (backup while serving requests)</li>
<li>Consistent snapshot (point-in-time)</li>
<li>Can copy to any destination (file, memory, network)</li>
</ul>
<h3 id="file-copy-simple-but-risky"><a class="header" href="#file-copy-simple-but-risky">File Copy (Simple but Risky)</a></h3>
<p>Only safe if database is not in use:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DANGER: Only do this if no connections are open!
impl SqliteBackend {
    pub fn backup_cold(&amp;self, dest: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), FsError&gt; {
        // Ensure WAL is checkpointed first
        let conn = self.get_write_connection()?;
        conn.execute_batch("PRAGMA wal_checkpoint(TRUNCATE);")?;
        drop(conn);

        // Now safe to copy
        std::fs::copy(&amp;self.db_path, dest.as_ref())?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="backup-schedule"><a class="header" href="#backup-schedule">Backup Schedule</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Strategy</th></tr>
</thead>
<tbody>
<tr><td>Development</td><td>Manual or none</td></tr>
<tr><td>Small production (&lt;1GB)</td><td>Hourly online backup</td></tr>
<tr><td>Large production (&gt;1GB)</td><td>Daily full + WAL archiving</td></tr>
<tr><td>Critical data</td><td>Continuous WAL shipping to replica</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h2>
<h3 id="essential-pragmas"><a class="header" href="#essential-pragmas">Essential PRAGMAs</a></h3>
<pre><code class="language-sql">-- Performance-critical settings
PRAGMA journal_mode = WAL;           -- Required for concurrent access
PRAGMA synchronous = NORMAL;         -- Good balance of safety/speed
PRAGMA cache_size = -64000;          -- 64MB cache (negative = KB)
PRAGMA temp_store = MEMORY;          -- Temp tables in memory
PRAGMA mmap_size = 268435456;        -- 256MB memory-mapped I/O

-- For read-heavy workloads
PRAGMA read_uncommitted = ON;        -- Allow dirty reads (faster, use carefully)

-- For write-heavy workloads
PRAGMA wal_autocheckpoint = 10000;   -- Checkpoint less frequently
</code></pre>
<h3 id="indexing-strategy"><a class="header" href="#indexing-strategy">Indexing Strategy</a></h3>
<pre><code class="language-sql">-- Essential indexes for filesystem operations
CREATE INDEX idx_nodes_parent ON nodes(parent_inode);
CREATE INDEX idx_nodes_name ON nodes(parent_inode, name);

-- For metadata queries
CREATE INDEX idx_nodes_type ON nodes(node_type);
CREATE INDEX idx_nodes_modified ON nodes(modified_at);

-- For GC queries
CREATE INDEX idx_blobs_orphan ON blobs(refcount) WHERE refcount = 0;

-- Composite indexes for common queries
CREATE INDEX idx_nodes_parent_type ON nodes(parent_inode, node_type);
</code></pre>
<h3 id="query-optimization"><a class="header" href="#query-optimization">Query Optimization</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Multiple queries
fn get_children_with_metadata(parent: i64) -&gt; Vec&lt;Node&gt; {
    let children = query("SELECT * FROM nodes WHERE parent = ?", [parent]);
    for child in children {
        let metadata = query("SELECT * FROM metadata WHERE inode = ?", [child.inode]);
        // ...
    }
}

// GOOD: Single query with JOIN
fn get_children_with_metadata(parent: i64) -&gt; Vec&lt;Node&gt; {
    query("
        SELECT n.*, m.*
        FROM nodes n
        LEFT JOIN metadata m ON n.inode = m.inode
        WHERE n.parent = ?
    ", [parent])
}
<span class="boring">}</span></code></pre>
<h3 id="prepared-statements"><a class="header" href="#prepared-statements">Prepared Statements</a></h3>
<p><strong>Always use prepared statements for repeated queries:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SqliteBackend {
    fn prepare_statements(conn: &amp;Connection) -&gt; Statements {
        Statements {
            read_file: conn.prepare_cached(
                "SELECT content FROM nodes WHERE parent_inode = ? AND name = ?"
            ).unwrap(),

            list_dir: conn.prepare_cached(
                "SELECT name, node_type, size FROM nodes WHERE parent_inode = ?"
            ).unwrap(),

            // ... other common queries
        }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="monitoring-and-diagnostics"><a class="header" href="#monitoring-and-diagnostics">Monitoring and Diagnostics</a></h2>
<h3 id="key-metrics-to-track"><a class="header" href="#key-metrics-to-track">Key Metrics to Track</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SqliteBackend {
    pub fn stats(&amp;self) -&gt; DbStats {
        let conn = self.read_pool.get().unwrap();

        DbStats {
            // Database size
            page_count: pragma_i64(&amp;conn, "page_count"),
            page_size: pragma_i64(&amp;conn, "page_size"),

            // WAL status
            wal_pages: pragma_i64(&amp;conn, "wal_checkpoint"),

            // Cache efficiency
            cache_hit: pragma_i64(&amp;conn, "cache_hit"),
            cache_miss: pragma_i64(&amp;conn, "cache_miss"),

            // Fragmentation
            freelist_count: pragma_i64(&amp;conn, "freelist_count"),
        }
    }
}

fn pragma_i64(conn: &amp;Connection, name: &amp;str) -&gt; i64 {
    conn.query_row(&amp;format!("PRAGMA {}", name), [], |r| r.get(0)).unwrap_or(0)
}
<span class="boring">}</span></code></pre>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SqliteBackend {
    pub fn health_check(&amp;self) -&gt; HealthStatus {
        // 1. Can we connect?
        let conn = match self.read_pool.get() {
            Ok(c) =&gt; c,
            Err(e) =&gt; return HealthStatus::Unhealthy(format!("pool: {}", e)),
        };

        // 2. Is database intact?
        let integrity: String = conn.query_row("PRAGMA integrity_check", [], |r| r.get(0))
            .unwrap_or_else(|_| "error".to_string());

        if integrity != "ok" {
            return HealthStatus::Unhealthy(format!("integrity: {}", integrity));
        }

        // 3. Is WAL file reasonable size?
        let wal_size = std::fs::metadata(format!("{}-wal", self.db_path))
            .map(|m| m.len())
            .unwrap_or(0);

        if wal_size &gt; 100 * 1024 * 1024 {  // &gt; 100MB
            return HealthStatus::Degraded("WAL file large - checkpoint needed".into());
        }

        // 4. Is write queue backed up?
        if self.write_queue_depth() &gt; 1000 {
            return HealthStatus::Degraded("Write queue backlog".into());
        }

        HealthStatus::Healthy
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-opening-too-many-connections"><a class="header" href="#1-opening-too-many-connections">1. Opening Too Many Connections</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: New connection per operation
fn read(&amp;self, path: &amp;Path) -&gt; Vec&lt;u8&gt; {
    let conn = Connection::open(&amp;self.db_path).unwrap();  // DON'T
    // ...
}

// GOOD: Use connection pool
fn read(&amp;self, path: &amp;Path) -&gt; Vec&lt;u8&gt; {
    let conn = self.pool.get().unwrap();  // Reuse connections
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="2-long-running-transactions"><a class="header" href="#2-long-running-transactions">2. Long-Running Transactions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Transaction open while doing slow work
let tx = conn.transaction()?;
for file in files {
    tx.execute("INSERT ...", [&amp;file])?;
    upload_to_s3(&amp;file)?;  // SLOW - blocks other writers!
}
tx.commit()?;

// GOOD: Minimize transaction scope
for file in files {
    upload_to_s3(&amp;file)?;  // Do slow work outside transaction
}
let tx = conn.transaction()?;
for file in files {
    tx.execute("INSERT ...", [&amp;file])?;  // Fast inserts only
}
tx.commit()?;
<span class="boring">}</span></code></pre>
<h3 id="3-ignoring-sqlite_busy"><a class="header" href="#3-ignoring-sqlite_busy">3. Ignoring SQLITE_BUSY</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Crash on busy
conn.execute("INSERT ...", [])?;  // May return SQLITE_BUSY

// GOOD: Retry logic (or use busy_timeout)
loop {
    match conn.execute("INSERT ...", []) {
        Ok(_) =&gt; break,
        Err(rusqlite::Error::SqliteFailure(e, _)) if e.code == ErrorCode::DatabaseBusy =&gt; {
            std::thread::sleep(Duration::from_millis(10));
            continue;
        }
        Err(e) =&gt; return Err(e.into()),
    }
}
<span class="boring">}</span></code></pre>
<h3 id="4-forgetting-to-checkpoint"><a class="header" href="#4-forgetting-to-checkpoint">4. Forgetting to Checkpoint</a></h3>
<pre class="playground"><code class="language-rust">// BAD: WAL grows forever
// (no checkpoint calls)

// GOOD: Periodic checkpoint
impl SqliteBackend {
    pub fn maintenance(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        let conn = self.get_write_connection()?;
        conn.execute_batch("PRAGMA wal_checkpoint(TRUNCATE);")?;
        Ok(())
    }
}</code></pre>
<h3 id="5-not-using-transactions-for-batch-operations"><a class="header" href="#5-not-using-transactions-for-batch-operations">5. Not Using Transactions for Batch Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: 1000 separate transactions
for item in items {
    conn.execute("INSERT ...", [item])?;  // Each is auto-committed
}

// GOOD: Single transaction
let tx = conn.transaction()?;
for item in items {
    tx.execute("INSERT ...", [item])?;
}
tx.commit()?;  // 10-100x faster
<span class="boring">}</span></code></pre>
<hr>
<h2 id="sqlcipher-encryption"><a class="header" href="#sqlcipher-encryption">SQLCipher (Encryption)</a></h2>
<p>For encrypted databases, use SQLCipher:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rusqlite::Connection;

fn open_encrypted(path: &amp;Path, key: &amp;str) -&gt; Result&lt;Connection, rusqlite::Error&gt; {
    let conn = Connection::open(path)?;

    // Set encryption key (must be first operation)
    conn.execute_batch(&amp;format!("PRAGMA key = '{}';", key))?;

    // Verify encryption is working
    conn.execute_batch("SELECT count(*) FROM sqlite_master;")?;

    // Now configure as normal
    conn.execute_batch("
        PRAGMA journal_mode = WAL;
        PRAGMA synchronous = NORMAL;
    ")?;

    Ok(conn)
}
<span class="boring">}</span></code></pre>
<p><strong>Key management:</strong></p>
<ul>
<li>Never hardcode keys</li>
<li>Rotate keys periodically (requires re-encryption)</li>
<li>Use key derivation (PBKDF2) for password-based keys</li>
<li>Store key metadata separately from data</li>
</ul>
<p>See <a href="#security-model-1">Security Model</a> for key rotation patterns.</p>
<hr>
<h2 id="summary-checklist"><a class="header" href="#summary-checklist">Summary Checklist</a></h2>
<p>Before deploying SQLite backend to production:</p>
<ul>
<li><input disabled="" type="checkbox"> WAL mode enabled (<code>PRAGMA journal_mode = WAL</code>)</li>
<li><input disabled="" type="checkbox"> Busy timeout configured (30+ seconds)</li>
<li><input disabled="" type="checkbox"> Single-writer queue implemented</li>
<li><input disabled="" type="checkbox"> Connection pool for readers</li>
<li><input disabled="" type="checkbox"> Auto-vacuum configured</li>
<li><input disabled="" type="checkbox"> Backup strategy in place</li>
<li><input disabled="" type="checkbox"> Monitoring for WAL size, queue depth</li>
<li><input disabled="" type="checkbox"> Integrity checks scheduled</li>
<li><input disabled="" type="checkbox"> Migration path for schema changes</li>
<li><input disabled="" type="checkbox"> Indexes for common queries</li>
</ul>
<hr>
<p><em>“SQLite is not a toy database. It’s a serious database that looks like a toy.”</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-model-1"><a class="header" href="#security-model-1">Security Model</a></h1>
<p><strong>Threat modeling, encryption, and security hardening for AnyFS deployments</strong></p>
<p>This guide covers security considerations for deploying AnyFS-based filesystems, from single-user local use to multi-tenant cloud services.</p>
<hr>
<h2 id="threat-model-1"><a class="header" href="#threat-model-1">Threat Model</a></h2>
<h3 id="actors"><a class="header" href="#actors">Actors</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Actor</th><th>Description</th><th>Trust Level</th></tr>
</thead>
<tbody>
<tr><td><strong>User</strong></td><td>Legitimate filesystem user</td><td>Trusted for their data</td></tr>
<tr><td><strong>Other User</strong></td><td>Another tenant (multi-tenant)</td><td>Untrusted (isolation required)</td></tr>
<tr><td><strong>Operator</strong></td><td>System administrator</td><td>Trusted for ops, not data</td></tr>
<tr><td><strong>Attacker</strong></td><td>External malicious actor</td><td>Untrusted</td></tr>
<tr><td><strong>Compromised Host</strong></td><td>Server with attacker access</td><td>Assume worst case</td></tr>
</tbody>
</table>
</div>
<h3 id="assets-to-protect"><a class="header" href="#assets-to-protect">Assets to Protect</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Asset</th><th>Confidentiality</th><th>Integrity</th><th>Availability</th></tr>
</thead>
<tbody>
<tr><td>File contents</td><td>High</td><td>High</td><td>High</td></tr>
<tr><td>File metadata (names, sizes)</td><td>Medium</td><td>High</td><td>High</td></tr>
<tr><td>Directory structure</td><td>Medium</td><td>High</td><td>Medium</td></tr>
<tr><td>Encryption keys</td><td>Critical</td><td>Critical</td><td>High</td></tr>
<tr><td>Audit logs</td><td>Medium</td><td>Critical</td><td>Medium</td></tr>
<tr><td>User credentials</td><td>Critical</td><td>Critical</td><td>High</td></tr>
</tbody>
</table>
</div>
<h3 id="attack-vectors"><a class="header" href="#attack-vectors">Attack Vectors</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Vector</th><th>Mitigation</th></tr>
</thead>
<tbody>
<tr><td>Network interception</td><td>TLS for all traffic</td></tr>
<tr><td>Unauthorized access</td><td>Authentication + authorization</td></tr>
<tr><td>Data theft (at rest)</td><td>Encryption (SQLCipher)</td></tr>
<tr><td>Data theft (in memory)</td><td>Memory protection, key isolation</td></tr>
<tr><td>Tenant data leakage</td><td>Strict isolation, no cross-tenant dedup</td></tr>
<tr><td>Path traversal</td><td>PathFilter middleware, input validation</td></tr>
<tr><td>Denial of service</td><td>Rate limiting, quotas</td></tr>
<tr><td>Privilege escalation</td><td>Principle of least privilege</td></tr>
<tr><td>Audit tampering</td><td>Append-only logs, signatures</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="encryption-at-rest"><a class="header" href="#encryption-at-rest">Encryption at Rest</a></h2>
<h3 id="sqlcipher-integration"><a class="header" href="#sqlcipher-integration">SQLCipher Integration</a></h3>
<p>For encrypted SQLite backends, use SQLCipher:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rusqlite::Connection;

pub struct EncryptedSqliteBackend {
    conn: Connection,
}

impl EncryptedSqliteBackend {
    /// Open an encrypted database.
    ///
    /// # Security Notes
    /// - Key should be 256 bits of cryptographically random data
    /// - Or use a strong passphrase with proper key derivation
    pub fn open(path: &amp;Path, key: &amp;EncryptionKey) -&gt; Result&lt;Self, FsError&gt; {
        let conn = Connection::open(path)
            .map_err(|e| FsError::Backend(e.to_string()))?;

        // Apply encryption key (MUST be first operation)
        match key {
            EncryptionKey::Raw(bytes) =&gt; {
                // Raw 256-bit key (hex encoded for SQLCipher)
                let hex_key = hex::encode(bytes);
                conn.execute_batch(&amp;format!("PRAGMA key = \"x'{}'\";", hex_key))?;
            }
            EncryptionKey::Passphrase(pass) =&gt; {
                // Passphrase (SQLCipher uses PBKDF2 internally)
                conn.execute_batch(&amp;format!("PRAGMA key = '{}';", escape_sql(pass)))?;
            }
        }

        // Verify encryption is working
        conn.execute_batch("SELECT count(*) FROM sqlite_master;")
            .map_err(|_| FsError::Backend("Invalid encryption key".into()))?;

        // Configure after key is set
        conn.execute_batch("
            PRAGMA journal_mode = WAL;
            PRAGMA synchronous = NORMAL;
        ")?;

        Ok(Self { conn })
    }
}

pub enum EncryptionKey {
    /// Raw 256-bit key (32 bytes)
    Raw([u8; 32]),
    /// Passphrase (key derived via PBKDF2)
    Passphrase(String),
}
<span class="boring">}</span></code></pre>
<h3 id="key-derivation"><a class="header" href="#key-derivation">Key Derivation</a></h3>
<p>For passphrase-based keys, SQLCipher uses PBKDF2 internally. For custom key derivation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use argon2::{Argon2, password_hash::SaltString};
use rand::rngs::OsRng;

/// Derive a 256-bit key from a passphrase.
pub fn derive_key(passphrase: &amp;str, salt: &amp;[u8]) -&gt; [u8; 32] {
    let argon2 = Argon2::default();
    let mut key = [0u8; 32];

    argon2.hash_password_into(
        passphrase.as_bytes(),
        salt,
        &amp;mut key,
    ).expect("key derivation failed");

    key
}

/// Generate a random salt for key derivation.
pub fn generate_salt() -&gt; [u8; 16] {
    let mut salt = [0u8; 16];
    OsRng.fill_bytes(&amp;mut salt);
    salt
}
<span class="boring">}</span></code></pre>
<p><strong>Salt storage:</strong> Store salt separately from encrypted data (e.g., in a key management service or config file).</p>
<hr>
<h2 id="key-management"><a class="header" href="#key-management">Key Management</a></h2>
<h3 id="key-lifecycle"><a class="header" href="#key-lifecycle">Key Lifecycle</a></h3>
<pre><code>┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐
│ Generate│ ──→ │  Store  │ ──→ │   Use   │ ──→ │ Rotate  │
└─────────┘     └─────────┘     └─────────┘     └─────────┘
                                                     │
                                                     ▼
                                               ┌─────────┐
                                               │ Destroy │
                                               └─────────┘
</code></pre>
<h3 id="key-generation"><a class="header" href="#key-generation">Key Generation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::rngs::OsRng;
use rand::RngCore;

/// Generate a cryptographically secure 256-bit key.
pub fn generate_key() -&gt; [u8; 32] {
    let mut key = [0u8; 32];
    OsRng.fill_bytes(&amp;mut key);
    key
}

/// Generate a key ID for tracking.
pub fn generate_key_id() -&gt; String {
    let mut id = [0u8; 16];
    OsRng.fill_bytes(&amp;mut id);
    format!("key_{}", hex::encode(id))
}
<span class="boring">}</span></code></pre>
<h3 id="key-storage"><a class="header" href="#key-storage">Key Storage</a></h3>
<p><strong>Never store keys:</strong></p>
<ul>
<li>In source code</li>
<li>In plain text config files</li>
<li>In the same location as encrypted data</li>
<li>In environment variables (visible in process lists)</li>
</ul>
<p><strong>Recommended storage:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Environment</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td>Development</td><td>File with restricted permissions (0600)</td></tr>
<tr><td>Production (cloud)</td><td>KMS (AWS KMS, GCP KMS, Azure Key Vault)</td></tr>
<tr><td>Production (on-prem)</td><td>HSM or dedicated secrets manager</td></tr>
<tr><td>User devices</td><td>OS keychain (macOS Keychain, Windows Credential Manager)</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Key storage abstraction.
pub trait KeyStore: Send + Sync {
    /// Retrieve a key by ID.
    fn get_key(&amp;self, key_id: &amp;str) -&gt; Result&lt;[u8; 32], KeyError&gt;;

    /// Store a new key, returns key ID.
    fn store_key(&amp;self, key: &amp;[u8; 32]) -&gt; Result&lt;String, KeyError&gt;;

    /// Delete a key (after rotation).
    fn delete_key(&amp;self, key_id: &amp;str) -&gt; Result&lt;(), KeyError&gt;;

    /// List all key IDs.
    fn list_keys(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, KeyError&gt;;
}

/// AWS KMS implementation.
pub struct AwsKmsKeyStore {
    client: aws_sdk_kms::Client,
    master_key_id: String,
}

impl KeyStore for AwsKmsKeyStore {
    fn get_key(&amp;self, key_id: &amp;str) -&gt; Result&lt;[u8; 32], KeyError&gt; {
        // Keys are stored encrypted in DynamoDB/S3
        // Decrypt using KMS
        let encrypted = self.fetch_encrypted_key(key_id)?;

        let decrypted = self.client.decrypt()
            .key_id(&amp;self.master_key_id)
            .ciphertext_blob(Blob::new(encrypted))
            .send()
            .await?;

        let plaintext = decrypted.plaintext().unwrap();
        let mut key = [0u8; 32];
        key.copy_from_slice(&amp;plaintext.as_ref()[..32]);
        Ok(key)
    }

    // ... other methods
}
<span class="boring">}</span></code></pre>
<h3 id="key-rotation"><a class="header" href="#key-rotation">Key Rotation</a></h3>
<p>Regular key rotation limits damage from key compromise:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EncryptedSqliteBackend {
    /// Rotate encryption key.
    ///
    /// This re-encrypts the entire database with a new key.
    /// Can take a long time for large databases.
    pub fn rotate_key(&amp;self, new_key: &amp;EncryptionKey) -&gt; Result&lt;(), FsError&gt; {
        let new_key_sql = match new_key {
            EncryptionKey::Raw(bytes) =&gt; format!("\"x'{}'\"", hex::encode(bytes)),
            EncryptionKey::Passphrase(pass) =&gt; format!("'{}'", escape_sql(pass)),
        };

        // SQLCipher's PRAGMA rekey re-encrypts the database
        self.conn.execute_batch(&amp;format!("PRAGMA rekey = {};", new_key_sql))
            .map_err(|e| FsError::Backend(format!("key rotation failed: {}", e)))?;

        Ok(())
    }
}

/// Key rotation schedule.
pub struct KeyRotationPolicy {
    /// Maximum age of a key before rotation.
    pub max_key_age: Duration,
    /// Maximum amount of data encrypted with one key.
    pub max_data_encrypted: u64,
    /// Whether to auto-rotate.
    pub auto_rotate: bool,
}

impl Default for KeyRotationPolicy {
    fn default() -&gt; Self {
        Self {
            max_key_age: Duration::from_secs(90 * 24 * 60 * 60),  // 90 days
            max_data_encrypted: 1024 * 1024 * 1024 * 100,         // 100 GB
            auto_rotate: true,
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Rotation workflow:</strong></p>
<ol>
<li>Generate new key</li>
<li>Store new key in key store</li>
<li>Re-encrypt database with <code>PRAGMA rekey</code></li>
<li>Update key ID reference</li>
<li>Audit log the rotation</li>
<li>After retention period, delete old key</li>
</ol>
<hr>
<h2 id="multi-tenant-isolation-2"><a class="header" href="#multi-tenant-isolation-2">Multi-Tenant Isolation</a></h2>
<h3 id="isolation-strategies"><a class="header" href="#isolation-strategies">Isolation Strategies</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Isolation Level</th><th>Complexity</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>Separate databases</strong></td><td>Strongest</td><td>Low</td><td>Few large tenants</td></tr>
<tr><td><strong>Separate tables</strong></td><td>Strong</td><td>Medium</td><td>Many small tenants</td></tr>
<tr><td><strong>Row-level</strong></td><td>Moderate</td><td>High</td><td>Shared infrastructure</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> Separate databases (one SQLite file per tenant).</p>
<h3 id="per-tenant-keys"><a class="header" href="#per-tenant-keys">Per-Tenant Keys</a></h3>
<p>Each tenant should have their own encryption key:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MultiTenantBackend {
    key_store: Arc&lt;dyn KeyStore&gt;,
    tenant_backends: RwLock&lt;HashMap&lt;TenantId, Arc&lt;EncryptedSqliteBackend&gt;&gt;&gt;,
}

impl MultiTenantBackend {
    /// Get or create backend for a tenant.
    pub fn get_tenant(&amp;self, tenant_id: &amp;TenantId) -&gt; Result&lt;Arc&lt;EncryptedSqliteBackend&gt;, FsError&gt; {
        // Check cache
        {
            let backends = self.tenant_backends.read().unwrap();
            if let Some(backend) = backends.get(tenant_id) {
                return Ok(backend.clone());
            }
        }

        // Create new backend
        let key = self.key_store.get_key(&amp;tenant_id.key_id())?;
        let path = self.tenant_db_path(tenant_id);
        let backend = Arc::new(EncryptedSqliteBackend::open(&amp;path, &amp;EncryptionKey::Raw(key))?);

        // Cache it
        let mut backends = self.tenant_backends.write().unwrap();
        backends.insert(tenant_id.clone(), backend.clone());

        Ok(backend)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="cross-tenant-dedup-considerations"><a class="header" href="#cross-tenant-dedup-considerations">Cross-Tenant Dedup Considerations</a></h3>
<p><strong>Warning:</strong> Cross-tenant deduplication can leak information.</p>
<pre><code>Tenant A uploads secret.pdf (hash: abc123)
Tenant B uploads same file → instantly deduped → B knows A has that file
</code></pre>
<p><strong>Options:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Dedup Savings</th><th>Privacy</th></tr>
</thead>
<tbody>
<tr><td>No cross-tenant dedup</td><td>None</td><td>Full privacy</td></tr>
<tr><td>Convergent encryption</td><td>Partial</td><td>Leaks file existence</td></tr>
<tr><td>Per-tenant keys before hash</td><td>None</td><td>Full privacy</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> Only deduplicate within a tenant, not across tenants.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern for any hybrid backend (IndexedBackend or custom implementations)
// See hybrid-backend-design.md for the full pattern
impl IndexedBackend {
    fn blob_id_for_tenant(&amp;self, tenant_id: &amp;TenantId, data: &amp;[u8]) -&gt; String {
        // Include tenant ID in hash to prevent cross-tenant dedup
        let mut hasher = Sha256::new();
        hasher.update(tenant_id.as_bytes());
        hasher.update(data);
        hex::encode(hasher.finalize())
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h2>
<h3 id="what-to-log"><a class="header" href="#what-to-log">What to Log</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Event</th><th>Severity</th><th>Data to Capture</th></tr>
</thead>
<tbody>
<tr><td>File read</td><td>Info</td><td>path, user, timestamp, size</td></tr>
<tr><td>File write</td><td>Info</td><td>path, user, timestamp, size, hash</td></tr>
<tr><td>File delete</td><td>Warning</td><td>path, user, timestamp</td></tr>
<tr><td>Permission change</td><td>Warning</td><td>path, user, old/new perms</td></tr>
<tr><td>Login success</td><td>Info</td><td>user, IP, timestamp</td></tr>
<tr><td>Login failure</td><td>Warning</td><td>user, IP, timestamp, reason</td></tr>
<tr><td>Key rotation</td><td>Critical</td><td>key_id, user, timestamp</td></tr>
<tr><td>Admin action</td><td>Critical</td><td>action, user, timestamp</td></tr>
</tbody>
</table>
</div>
<h3 id="audit-log-schema"><a class="header" href="#audit-log-schema">Audit Log Schema</a></h3>
<pre><code class="language-sql">CREATE TABLE audit_log (
    seq         INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp   INTEGER NOT NULL,
    event_type  TEXT NOT NULL,
    severity    TEXT NOT NULL,  -- 'info', 'warning', 'critical'
    actor       TEXT,           -- user ID or 'system'
    actor_ip    TEXT,
    resource    TEXT,           -- path or resource ID
    action      TEXT NOT NULL,
    details     TEXT,           -- JSON
    signature   BLOB            -- HMAC for tamper detection
);

CREATE INDEX idx_audit_timestamp ON audit_log(timestamp);
CREATE INDEX idx_audit_actor ON audit_log(actor);
CREATE INDEX idx_audit_resource ON audit_log(resource);
</code></pre>
<h3 id="tamper-evident-logging"><a class="header" href="#tamper-evident-logging">Tamper-Evident Logging</a></h3>
<p>Sign audit entries to detect tampering:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hmac::{Hmac, Mac};
use sha2::Sha256;

type HmacSha256 = Hmac&lt;Sha256&gt;;

pub struct AuditLogger {
    conn: Connection,
    signing_key: [u8; 32],
    prev_signature: RwLock&lt;Vec&lt;u8&gt;&gt;,  // Chain signatures
}

impl AuditLogger {
    pub fn log(&amp;self, event: AuditEvent) -&gt; Result&lt;(), FsError&gt; {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        let details = serde_json::to_string(&amp;event.details)?;

        // Create signature (includes previous signature for chaining)
        let prev_sig = self.prev_signature.read().unwrap().clone();
        let signature = self.sign_entry(timestamp, &amp;event, &amp;details, &amp;prev_sig);

        self.conn.execute(
            "INSERT INTO audit_log (timestamp, event_type, severity, actor, actor_ip, resource, action, details, signature)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
            params![
                timestamp,
                event.event_type,
                event.severity,
                event.actor,
                event.actor_ip,
                event.resource,
                event.action,
                details,
                &amp;signature[..],
            ],
        )?;

        // Update chain
        *self.prev_signature.write().unwrap() = signature;

        Ok(())
    }

    fn sign_entry(
        &amp;self,
        timestamp: i64,
        event: &amp;AuditEvent,
        details: &amp;str,
        prev_sig: &amp;[u8],
    ) -&gt; Vec&lt;u8&gt; {
        let mut mac = HmacSha256::new_from_slice(&amp;self.signing_key).unwrap();

        mac.update(&amp;timestamp.to_le_bytes());
        mac.update(event.event_type.as_bytes());
        mac.update(event.action.as_bytes());
        mac.update(details.as_bytes());
        mac.update(prev_sig);  // Chain to previous entry

        mac.finalize().into_bytes().to_vec()
    }

    /// Verify audit log integrity.
    pub fn verify_integrity(&amp;self) -&gt; Result&lt;bool, FsError&gt; {
        let mut prev_sig = Vec::new();

        let mut stmt = self.conn.prepare(
            "SELECT timestamp, event_type, severity, actor, actor_ip, resource, action, details, signature
             FROM audit_log ORDER BY seq"
        )?;

        let rows = stmt.query_map([], |row| {
            Ok(AuditRow {
                timestamp: row.get(0)?,
                event_type: row.get(1)?,
                severity: row.get(2)?,
                actor: row.get(3)?,
                actor_ip: row.get(4)?,
                resource: row.get(5)?,
                action: row.get(6)?,
                details: row.get(7)?,
                signature: row.get(8)?,
            })
        })?;

        for row in rows {
            let row = row?;

            let expected_sig = self.sign_entry(
                row.timestamp,
                &amp;row.to_event(),
                &amp;row.details,
                &amp;prev_sig,
            );

            if expected_sig != row.signature {
                return Ok(false);  // Tampered!
            }

            prev_sig = row.signature;
        }

        Ok(true)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="audit-log-retention"><a class="header" href="#audit-log-retention">Audit Log Retention</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AuditLogger {
    /// Rotate old audit logs to cold storage.
    pub fn rotate(&amp;self, max_age: Duration) -&gt; Result&lt;RotationStats, FsError&gt; {
        let cutoff = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64 - max_age.as_secs() as i64;

        // Export old entries to archive
        let old_entries: Vec&lt;AuditRow&gt; = self.conn.prepare(
            "SELECT * FROM audit_log WHERE timestamp &lt; ?"
        )?.query_map([cutoff], |row| /* ... */)?.collect();

        // Write to archive file (compressed, signed)
        self.write_archive(&amp;old_entries)?;

        // Delete from active log
        let deleted = self.conn.execute(
            "DELETE FROM audit_log WHERE timestamp &lt; ?",
            [cutoff],
        )?;

        Ok(RotationStats { archived: old_entries.len(), deleted })
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="access-control"><a class="header" href="#access-control">Access Control</a></h2>
<h3 id="path-based-access-control"><a class="header" href="#path-based-access-control">Path-Based Access Control</a></h3>
<p>Use <code>PathFilterLayer</code> middleware for path-based restrictions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let backend = SqliteBackend::open("data.db")?
    .layer(PathFilterLayer::builder()
        // Allow specific directories
        .allow("/home/{user}/**")
        .allow("/shared/**")
        // Block sensitive paths
        .deny("**/.env")
        .deny("**/.git/**")
        .deny("**/node_modules/**")
        // Block by extension
        .deny("**/*.key")
        .deny("**/*.pem")
        .build());
<span class="boring">}</span></code></pre>
<h3 id="role-based-access-control"><a class="header" href="#role-based-access-control">Role-Based Access Control</a></h3>
<p>Implement RBAC at the application layer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub enum Role {
    Admin,
    ReadWrite,
    ReadOnly,
    Custom(Vec&lt;Permission&gt;),
}

#[derive(Debug, Clone)]
pub enum Permission {
    Read(PathPattern),
    Write(PathPattern),
    Delete(PathPattern),
    Admin,
}

pub struct RbacMiddleware&lt;B&gt; {
    inner: B,
    user_roles: Arc&lt;dyn RoleProvider&gt;,
}

impl&lt;B: FsRead&gt; FsRead for RbacMiddleware&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        let user = current_user()?;
        let role = self.user_roles.get_role(&amp;user)?;

        if !role.can_read(path) {
            return Err(FsError::AccessDenied {
                path: path.to_path_buf(),
                reason: "insufficient permissions".into(),
            });
        }

        self.inner.read(path)
    }
}

impl&lt;B: FsWrite&gt; FsWrite for RbacMiddleware&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        let user = current_user()?;
        let role = self.user_roles.get_role(&amp;user)?;

        if !role.can_write(path) {
            return Err(FsError::AccessDenied {
                path: path.to_path_buf(),
                reason: "write permission denied".into(),
            });
        }

        self.inner.write(path, data)
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="network-security"><a class="header" href="#network-security">Network Security</a></h2>
<h3 id="tls-configuration"><a class="header" href="#tls-configuration">TLS Configuration</a></h3>
<p>Always use TLS for network communication:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tonic::transport::{Server, ServerTlsConfig, Identity, Certificate};

pub async fn serve_with_tls(
    backend: impl Fs,
    addr: &amp;str,
    cert_path: &amp;Path,
    key_path: &amp;Path,
) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let cert = std::fs::read_to_string(cert_path)?;
    let key = std::fs::read_to_string(key_path)?;

    let identity = Identity::from_pem(cert, key);

    let tls_config = ServerTlsConfig::new()
        .identity(identity);

    Server::builder()
        .tls_config(tls_config)?
        .add_service(FsServiceServer::new(FsServer::new(backend)))
        .serve(addr.parse()?)
        .await?;

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="client-certificate-authentication-mtls"><a class="header" href="#client-certificate-authentication-mtls">Client Certificate Authentication (mTLS)</a></h3>
<p>For high-security deployments, require client certificates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tonic::transport::ClientTlsConfig;

pub async fn connect_with_mtls(
    addr: &amp;str,
    ca_cert: &amp;Path,
    client_cert: &amp;Path,
    client_key: &amp;Path,
) -&gt; Result&lt;FsServiceClient&lt;Channel&gt;, Box&lt;dyn Error&gt;&gt; {
    let ca = std::fs::read_to_string(ca_cert)?;
    let cert = std::fs::read_to_string(client_cert)?;
    let key = std::fs::read_to_string(client_key)?;

    let tls_config = ClientTlsConfig::new()
        .ca_certificate(Certificate::from_pem(ca))
        .identity(Identity::from_pem(cert, key));

    let channel = Channel::from_shared(addr.to_string())?
        .tls_config(tls_config)?
        .connect()
        .await?;

    Ok(FsServiceClient::new(channel))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="security-checklist-1"><a class="header" href="#security-checklist-1">Security Checklist</a></h2>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<ul>
<li><input disabled="" type="checkbox"> No secrets in source code</li>
<li><input disabled="" type="checkbox"> No secrets in logs</li>
<li><input disabled="" type="checkbox"> Input validation on all paths</li>
<li><input disabled="" type="checkbox"> Error messages don’t leak sensitive info</li>
</ul>
<h3 id="deployment"><a class="header" href="#deployment">Deployment</a></h3>
<ul>
<li><input disabled="" type="checkbox"> TLS enabled for all network traffic</li>
<li><input disabled="" type="checkbox"> Encryption at rest (SQLCipher)</li>
<li><input disabled="" type="checkbox"> Keys stored in secure key management system</li>
<li><input disabled="" type="checkbox"> Key rotation policy defined and automated</li>
<li><input disabled="" type="checkbox"> Audit logging enabled</li>
<li><input disabled="" type="checkbox"> Rate limiting configured</li>
<li><input disabled="" type="checkbox"> Quotas configured</li>
</ul>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Regular security audits</li>
<li><input disabled="" type="checkbox"> Vulnerability scanning</li>
<li><input disabled="" type="checkbox"> Audit log review</li>
<li><input disabled="" type="checkbox"> Key rotation executed</li>
<li><input disabled="" type="checkbox"> Backup encryption verified</li>
<li><input disabled="" type="checkbox"> Access reviews (who has what permissions)</li>
</ul>
<h3 id="multi-tenant"><a class="header" href="#multi-tenant">Multi-Tenant</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Tenant isolation verified</li>
<li><input disabled="" type="checkbox"> Per-tenant encryption keys</li>
<li><input disabled="" type="checkbox"> No cross-tenant dedup (or risk accepted)</li>
<li><input disabled="" type="checkbox"> Tenant data segregation in backups</li>
</ul>
<hr>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Protection</th></tr>
</thead>
<tbody>
<tr><td><strong>Transport</strong></td><td>TLS, mTLS</td></tr>
<tr><td><strong>Authentication</strong></td><td>Tokens, certificates</td></tr>
<tr><td><strong>Authorization</strong></td><td>RBAC, PathFilter</td></tr>
<tr><td><strong>Data at rest</strong></td><td>SQLCipher encryption</td></tr>
<tr><td><strong>Key management</strong></td><td>KMS, rotation</td></tr>
<tr><td><strong>Audit</strong></td><td>Tamper-evident logging</td></tr>
<tr><td><strong>Isolation</strong></td><td>Per-tenant DBs and keys</td></tr>
</tbody>
</table>
</div>
<p>Security is not optional. Build it in from the start.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h1>
<p><strong>Comprehensive testing strategy for AnyFS</strong></p>
<hr>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>AnyFS uses a layered testing approach:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>What it tests</th><th>Run with</th></tr>
</thead>
<tbody>
<tr><td>Unit tests</td><td>Individual components</td><td><code>cargo test</code></td></tr>
<tr><td>Conformance tests</td><td>Backend trait compliance</td><td><code>cargo test --features conformance</code></td></tr>
<tr><td>Integration tests</td><td>Full stack behavior</td><td><code>cargo test --test integration</code></td></tr>
<tr><td>Stress tests</td><td>Concurrency &amp; limits</td><td><code>cargo test --release -- --ignored</code></td></tr>
<tr><td>Platform tests</td><td>Cross-platform behavior</td><td>CI matrix</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-backend-conformance-tests"><a class="header" href="#1-backend-conformance-tests">1. Backend Conformance Tests</a></h2>
<p>Every backend must pass the same conformance suite. This ensures backends are interchangeable.</p>
<h3 id="running-conformance-tests"><a class="header" href="#running-conformance-tests">Running Conformance Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_test::{run_conformance_suite, ConformanceLevel};

#[test]
fn memory_backend_conformance() {
    run_conformance_suite(
        MemoryBackend::new(),
        ConformanceLevel::Fs,  // or FsFull, FsFuse, FsPosix
    );
}

#[test]
fn sqlite_backend_conformance() {
    let temp = tempfile::tempdir().unwrap();
    let db_path = temp.path().join("test.db");
    run_conformance_suite(
        SqliteBackend::open(&amp;db_path).unwrap(),
        ConformanceLevel::FsFuse,
    );
}
<span class="boring">}</span></code></pre>
<h3 id="conformance-levels"><a class="header" href="#conformance-levels">Conformance Levels</a></h3>
<pre><code>FsPosix  ──▶ FsHandles, FsLock, FsXattr tests
    │
FsFuse   ──▶ FsInode tests (path_to_inode, lookup, etc.)
    │
FsFull   ──▶ FsLink, FsPermissions, FsSync, FsStats tests
    │
Fs       ──▶ FsRead, FsWrite, FsDir tests (REQUIRED for all)
</code></pre>
<h3 id="core-tests-fs-level"><a class="header" href="#core-tests-fs-level">Core Tests (Fs level)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_write_and_read() {
    let backend = create_backend();

    backend.write(std::path::Path::new("/file.txt"), b"hello world").unwrap();
    let content = backend.read(std::path::Path::new("/file.txt")).unwrap();

    assert_eq!(content, b"hello world");
}

#[test]
fn test_read_nonexistent_returns_not_found() {
    let backend = create_backend();

    let result = backend.read(std::path::Path::new("/nonexistent.txt"));

    assert!(matches!(result, Err(FsError::NotFound { .. })));
}

#[test]
fn test_create_dir_and_list() {
    let backend = create_backend();

    backend.create_dir(std::path::Path::new("/mydir")).unwrap();
    backend.write(std::path::Path::new("/mydir/file.txt"), b"data").unwrap();

    let entries = backend.read_dir(std::path::Path::new("/mydir")).unwrap();
    assert_eq!(entries.len(), 1);
    assert_eq!(entries[0].name, "file.txt");
}

#[test]
fn test_create_dir_all() {
    let backend = create_backend();

    backend.create_dir_all(std::path::Path::new("/a/b/c/d")).unwrap();

    assert!(backend.exists(std::path::Path::new("/a/b/c/d")).unwrap());
}

#[test]
fn test_remove_file() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"data").unwrap();

    backend.remove_file(std::path::Path::new("/file.txt")).unwrap();

    assert!(!backend.exists(std::path::Path::new("/file.txt")).unwrap());
}

#[test]
fn test_remove_dir_all() {
    let backend = create_backend();
    backend.create_dir_all(std::path::Path::new("/a/b/c")).unwrap();
    backend.write(std::path::Path::new("/a/b/c/file.txt"), b"data").unwrap();

    backend.remove_dir_all(std::path::Path::new("/a")).unwrap();

    assert!(!backend.exists(std::path::Path::new("/a")).unwrap());
}

#[test]
fn test_rename() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/old.txt"), b"data").unwrap();

    backend.rename(std::path::Path::new("/old.txt"), std::path::Path::new("/new.txt")).unwrap();

    assert!(!backend.exists(std::path::Path::new("/old.txt")).unwrap());
    assert_eq!(backend.read(std::path::Path::new("/new.txt")).unwrap(), b"data");
}

#[test]
fn test_copy() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/original.txt"), b"data").unwrap();

    backend.copy(std::path::Path::new("/original.txt"), std::path::Path::new("/copy.txt")).unwrap();

    assert_eq!(backend.read(std::path::Path::new("/original.txt")).unwrap(), b"data");
    assert_eq!(backend.read(std::path::Path::new("/copy.txt")).unwrap(), b"data");
}

#[test]
fn test_metadata() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"hello").unwrap();

    let meta = backend.metadata(std::path::Path::new("/file.txt")).unwrap();

    assert_eq!(meta.size, 5);
    assert!(meta.file_type.is_file());
}

#[test]
fn test_append() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"hello").unwrap();

    backend.append(std::path::Path::new("/file.txt"), b" world").unwrap();

    assert_eq!(backend.read(std::path::Path::new("/file.txt")).unwrap(), b"hello world");
}

#[test]
fn test_truncate() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"hello world").unwrap();

    backend.truncate(std::path::Path::new("/file.txt"), 5).unwrap();

    assert_eq!(backend.read(std::path::Path::new("/file.txt")).unwrap(), b"hello");
}

#[test]
fn test_read_range() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"hello world").unwrap();

    let partial = backend.read_range(std::path::Path::new("/file.txt"), 6, 5).unwrap();

    assert_eq!(partial, b"world");
}
<span class="boring">}</span></code></pre>
<h3 id="extended-tests-fsfull-level"><a class="header" href="#extended-tests-fsfull-level">Extended Tests (FsFull level)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_symlink() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/target.txt"), b"data").unwrap();

    backend.symlink(std::path::Path::new("/target.txt"), std::path::Path::new("/link.txt")).unwrap();

    // read_link returns the target
    assert_eq!(backend.read_link(std::path::Path::new("/link.txt")).unwrap(), Path::new("/target.txt"));

    // reading the symlink follows it
    assert_eq!(backend.read(std::path::Path::new("/link.txt")).unwrap(), b"data");
}

#[test]
fn test_hard_link() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/original.txt"), b"data").unwrap();

    backend.hard_link(std::path::Path::new("/original.txt"), std::path::Path::new("/hardlink.txt")).unwrap();

    // Both point to same data
    assert_eq!(backend.read(std::path::Path::new("/hardlink.txt")).unwrap(), b"data");

    // Metadata shows nlink &gt; 1
    let meta = backend.metadata(std::path::Path::new("/original.txt")).unwrap();
    assert!(meta.nlink &gt;= 2);
}

#[test]
fn test_symlink_metadata() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/target.txt"), b"data").unwrap();
    backend.symlink(std::path::Path::new("/target.txt"), std::path::Path::new("/link.txt")).unwrap();

    // symlink_metadata returns metadata of the symlink itself
    let meta = backend.symlink_metadata(std::path::Path::new("/link.txt")).unwrap();
    assert!(meta.file_type.is_symlink());
}

#[test]
fn test_set_permissions() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"data").unwrap();

    backend.set_permissions(std::path::Path::new("/file.txt"), Permissions::from_mode(0o644)).unwrap();

    let meta = backend.metadata(std::path::Path::new("/file.txt")).unwrap();
    assert_eq!(meta.permissions.mode() &amp; 0o777, 0o644);
}

#[test]
fn test_sync() {
    let backend = create_backend();
    backend.write(std::path::Path::new("/file.txt"), b"data").unwrap();

    // Should not error
    backend.sync().unwrap();
    backend.fsync(std::path::Path::new("/file.txt")).unwrap();
}

#[test]
fn test_statfs() {
    let backend = create_backend();

    let stats = backend.statfs().unwrap();

    assert!(stats.total_bytes &gt; 0 || stats.total_bytes == 0); // Memory may report 0
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="2-middleware-tests"><a class="header" href="#2-middleware-tests">2. Middleware Tests</a></h2>
<p>Each middleware is tested in isolation and in combination.</p>
<h3 id="quota-tests"><a class="header" href="#quota-tests">Quota Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_quota_blocks_when_exceeded() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/big.txt", &amp;[0u8; 200]);

    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}

#[test]
fn test_quota_allows_within_limit() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(1000).build());
    let fs = FileStorage::new(backend);

    fs.write("/small.txt", &amp;[0u8; 100]).unwrap();

    assert!(fs.exists("/small.txt").unwrap());
}

#[test]
fn test_quota_tracks_deletes() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build());
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", &amp;[0u8; 50]).unwrap();
    fs.remove_file("/file.txt").unwrap();

    // Should be able to write again after delete
    fs.write("/file2.txt", &amp;[0u8; 50]).unwrap();
}

#[test]
fn test_quota_max_file_size() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_file_size(50).build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/big.txt", &amp;[0u8; 100]);

    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}

#[test]
fn test_quota_streaming_write() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build());
    let fs = FileStorage::new(backend);

    let mut writer = fs.open_write("/file.txt").unwrap();
    writer.write_all(&amp;[0u8; 50]).unwrap();
    writer.write_all(&amp;[0u8; 50]).unwrap();
    drop(writer);

    // Next write should fail
    let result = fs.write("/file2.txt", &amp;[0u8; 10]);
    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="restrictions-tests"><a class="header" href="#restrictions-tests">Restrictions Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_restrictions_blocks_permissions() {
    let backend = MemoryBackend::new()
        .layer(RestrictionsLayer::builder().deny_permissions().build());
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", b"data").unwrap();
    let result = fs.set_permissions("/file.txt", Permissions::new(0o644));

    assert!(matches!(result, Err(FsError::FeatureNotEnabled { .. })));
}

#[test]
fn test_restrictions_allows_links() {
    // Restrictions doesn't block FsLink - capability is via trait bounds
    let backend = MemoryBackend::new()
        .layer(RestrictionsLayer::builder().deny_permissions().build());
    let fs = FileStorage::new(backend);

    fs.write("/target.txt", b"data").unwrap();
    fs.symlink("/target.txt", "/link.txt").unwrap();  // Works - MemoryBackend: FsLink
    fs.hard_link("/target.txt", "/hardlink.txt").unwrap();  // Works too
}

#[test]
fn test_restrictions_blocks_permissions() {
    let backend = MemoryBackend::new()
        .layer(RestrictionsLayer::builder().deny_permissions().build());
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", b"data").unwrap();
    let result = fs.set_permissions("/file.txt", Permissions::from_mode(0o777));

    assert!(matches!(result, Err(FsError::OperationDenied { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="pathfilter-tests"><a class="header" href="#pathfilter-tests">PathFilter Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_pathfilter_allows_matching() {
    let backend = MemoryBackend::new()
        .layer(PathFilterLayer::builder().allow("/workspace/**").build());
    let fs = FileStorage::new(backend);

    fs.create_dir_all("/workspace/project").unwrap();
    fs.write("/workspace/project/file.txt", b"data").unwrap();
}

#[test]
fn test_pathfilter_blocks_non_matching() {
    let backend = MemoryBackend::new()
        .layer(PathFilterLayer::builder().allow("/workspace/**").build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/etc/passwd", b"data");

    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_pathfilter_deny_overrides_allow() {
    let backend = MemoryBackend::new()
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/.env")
            .build());
    let fs = FileStorage::new(backend);

    let result = fs.write("/workspace/.env", b"SECRET=xxx");

    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_pathfilter_read_dir_filters() {
    let mut inner = MemoryBackend::new();
    inner.write(std::path::Path::new("/workspace/allowed.txt"), b"data").unwrap();
    inner.write(std::path::Path::new("/workspace/.env"), b"secret").unwrap();

    let backend = inner
        .layer(PathFilterLayer::builder()
            .allow("/workspace/**")
            .deny("**/.env")
            .build());
    let fs = FileStorage::new(backend);

    let entries = fs.read_dir("/workspace").unwrap();

    // .env should be filtered out
    assert_eq!(entries.len(), 1);
    assert_eq!(entries[0].name, "allowed.txt");
}
<span class="boring">}</span></code></pre>
<h3 id="readonly-tests"><a class="header" href="#readonly-tests">ReadOnly Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_readonly_blocks_writes() {
    let mut inner = MemoryBackend::new();
    inner.write(std::path::Path::new("/file.txt"), b"original").unwrap();

    let backend = ReadOnly::new(inner);
    let fs = FileStorage::new(backend);

    let result = fs.write("/file.txt", b"modified");
    assert!(matches!(result, Err(FsError::ReadOnly { .. })));

    let result = fs.remove_file("/file.txt");
    assert!(matches!(result, Err(FsError::ReadOnly { .. })));
}

#[test]
fn test_readonly_allows_reads() {
    let mut inner = MemoryBackend::new();
    inner.write(std::path::Path::new("/file.txt"), b"data").unwrap();

    let backend = ReadOnly::new(inner);
    let fs = FileStorage::new(backend);

    assert_eq!(fs.read("/file.txt").unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<h3 id="middleware-composition-tests"><a class="header" href="#middleware-composition-tests">Middleware Composition Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_middleware_composition_order() {
    // Quota inside, Restrictions outside
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(100).build())
        .layer(RestrictionsLayer::builder().deny_permissions().build());

    let fs = FileStorage::new(backend);

    // Write should hit quota
    let result = fs.write("/big.txt", &amp;[0u8; 200]);
    assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
}

#[test]
fn test_layer_syntax() {
    // All configurable middleware use builder pattern (per ADR-022)
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder().max_total_size(1000).build())
        .layer(RestrictionsLayer::builder().deny_permissions().build())
        .layer(TracingLayer::new());  // TracingLayer has sensible defaults

    let fs = FileStorage::new(backend);
    fs.write("/test.txt", b"data").unwrap();
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="3-filestorage-tests"><a class="header" href="#3-filestorage-tests">3. FileStorage Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_filestorage_type_inference() {
    // Type should be inferred
    let fs = FileStorage::new(MemoryBackend::new());
    // No explicit type needed
}

#[test]
fn test_filestorage_marker_types() {
    struct Sandbox;
    struct Production;

    let sandbox: FileStorage&lt;_, _, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
    let prod: FileStorage&lt;_, _, Production&gt; = FileStorage::new(MemoryBackend::new());

    fn only_sandbox(_fs: &amp;FileStorage&lt;impl Fs, IterativeResolver, Sandbox&gt;) {}

    only_sandbox(&amp;sandbox);  // Compiles
    // only_sandbox(&amp;prod);  // Would not compile
}

#[test]
fn test_filestorage_boxed() {
    let fs1 = FileStorage::new(MemoryBackend::new()).boxed();
    let fs2 = FileStorage::new(SqliteBackend::open(":memory:").unwrap()).boxed();

    // Both can be stored in same collection
    let _filesystems: Vec&lt;FileStorage&lt;Box&lt;dyn Fs&gt;&gt;&gt; = vec![fs1, fs2];
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="4-error-handling-tests"><a class="header" href="#4-error-handling-tests">4. Error Handling Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_error_not_found() {
    let fs = FileStorage::new(MemoryBackend::new());

    match fs.read("/nonexistent") {
        Err(FsError::NotFound { path, operation }) =&gt; {
            assert_eq!(path, Path::new("/nonexistent"));
            assert_eq!(operation, "read");
        }
        _ =&gt; panic!("Expected NotFound error"),
    }
}

#[test]
fn test_error_already_exists() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.create_dir("/mydir").unwrap();

    match fs.create_dir("/mydir") {
        Err(FsError::AlreadyExists { path, .. }) =&gt; {
            assert_eq!(path, Path::new("/mydir"));
        }
        _ =&gt; panic!("Expected AlreadyExists error"),
    }
}

#[test]
fn test_error_not_a_directory() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.write("/file.txt", b"data").unwrap();

    match fs.read_dir("/file.txt") {
        Err(FsError::NotADirectory { path }) =&gt; {
            assert_eq!(path, Path::new("/file.txt"));
        }
        _ =&gt; panic!("Expected NotADirectory error"),
    }
}

#[test]
fn test_error_directory_not_empty() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.create_dir("/mydir").unwrap();
    fs.write("/mydir/file.txt", b"data").unwrap();

    match fs.remove_dir("/mydir") {
        Err(FsError::DirectoryNotEmpty { path }) =&gt; {
            assert_eq!(path, Path::new("/mydir"));
        }
        _ =&gt; panic!("Expected DirectoryNotEmpty error"),
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="5-concurrency-tests"><a class="header" href="#5-concurrency-tests">5. Concurrency Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_concurrent_reads() {
    let backend = MemoryBackend::new();
    backend.write(std::path::Path::new("/file.txt"), b"data").unwrap();
    let backend = Arc::new(RwLock::new(backend));

    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = Arc::clone(&amp;backend);
        thread::spawn(move || {
            let guard = backend.read().unwrap();
            guard.read(std::path::Path::new("/file.txt")).unwrap()
        })
    }).collect();

    for handle in handles {
        assert_eq!(handle.join().unwrap(), b"data");
    }
}

#[test]
fn test_concurrent_create_dir_all() {
    let backend = Arc::new(Mutex::new(MemoryBackend::new()));

    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = Arc::clone(&amp;backend);
        thread::spawn(move || {
            let mut guard = backend.lock().unwrap();
            // Multiple threads creating same path should not race
            guard.create_dir_all(std::path::Path::new("/a/b/c/d")).unwrap();
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }

    assert!(backend.lock().unwrap().exists(std::path::Path::new("/a/b/c/d")).unwrap());
}

#[test]
#[ignore] // Run with: cargo test --release -- --ignored
fn stress_test_concurrent_operations() {
    let backend = Arc::new(Mutex::new(MemoryBackend::new()));

    let handles: Vec&lt;_&gt; = (0..100).map(|i| {
        let backend = Arc::clone(&amp;backend);
        thread::spawn(move || {
            for j in 0..100 {
                let path = format!("/thread_{}/file_{}.txt", i, j);
                let mut guard = backend.lock().unwrap();
                guard.create_dir_all(std::path::Path::new(&amp;format!("/thread_{}", i))).ok();
                guard.write(std::path::Path::new(&amp;path), b"data").unwrap();
                drop(guard);

                let guard = backend.lock().unwrap();
                let _ = guard.read(std::path::Path::new(&amp;path));
            }
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="6-path-edge-case-tests"><a class="header" href="#6-path-edge-case-tests">6. Path Edge Case Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_path_normalization() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/a/b/../c/file.txt", b"data").unwrap();

    // Should be accessible via normalized path
    assert_eq!(fs.read("/a/c/file.txt").unwrap(), b"data");
}

#[test]
fn test_double_slashes() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("//a//b//file.txt", b"data").unwrap();

    assert_eq!(fs.read("/a/b/file.txt").unwrap(), b"data");
}

#[test]
fn test_root_path() {
    let fs = FileStorage::new(MemoryBackend::new());

    // ReadDirIter is an iterator, use collect_all() to check contents
    let entries = fs.read_dir("/").unwrap().collect_all().unwrap();
    assert!(entries.is_empty());
}

#[test]
fn test_empty_path_returns_error() {
    let fs = FileStorage::new(MemoryBackend::new());

    let result = fs.read("");
    assert!(result.is_err());
}

#[test]
fn test_unicode_paths() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/文件/データ.txt", b"data").unwrap();

    assert_eq!(fs.read("/文件/データ.txt").unwrap(), b"data");
}

#[test]
fn test_paths_with_spaces() {
    let fs = FileStorage::new(MemoryBackend::new());

    fs.write("/my folder/my file.txt", b"data").unwrap();

    assert_eq!(fs.read("/my folder/my file.txt").unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="7-no-panic-guarantee-tests"><a class="header" href="#7-no-panic-guarantee-tests">7. No-Panic Guarantee Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn no_panic_missing_file() {
    let fs = FileStorage::new(MemoryBackend::new());
    let _ = fs.read("/missing");  // Should return Err, not panic
}

#[test]
fn no_panic_missing_parent() {
    let fs = FileStorage::new(MemoryBackend::new());
    let _ = fs.write("/missing/parent/file.txt", b"data");  // Should return Err
}

#[test]
fn no_panic_read_dir_on_file() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.write("/file.txt", b"data").unwrap();
    let _ = fs.read_dir("/file.txt");  // Should return Err, not panic
}

#[test]
fn no_panic_remove_nonempty_dir() {
    let fs = FileStorage::new(MemoryBackend::new());
    fs.create_dir("/dir").unwrap();
    fs.write("/dir/file.txt", b"data").unwrap();
    let _ = fs.remove_dir("/dir");  // Should return Err, not panic
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="8-symlink-security-tests"><a class="header" href="#8-symlink-security-tests">8. Symlink Security Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Virtual backend symlink resolution (always follows for FsLink backends)
#[test]
fn test_virtual_backend_symlink_following() {
    let backend = MemoryBackend::new();
    backend.write(std::path::Path::new("/target.txt"), b"secret").unwrap();
    backend.symlink(std::path::Path::new("/target.txt"), std::path::Path::new("/link.txt")).unwrap();

    assert_eq!(backend.read(std::path::Path::new("/link.txt")).unwrap(), b"secret");
}

#[test]
fn test_symlink_chain_resolution() {
    let backend = MemoryBackend::new();
    backend.write(std::path::Path::new("/target.txt"), b"data").unwrap();
    backend.symlink(std::path::Path::new("/target.txt"), std::path::Path::new("/link1.txt")).unwrap();
    backend.symlink(std::path::Path::new("/link1.txt"), std::path::Path::new("/link2.txt")).unwrap();

    // Should follow chain
    assert_eq!(backend.read(std::path::Path::new("/link2.txt")).unwrap(), b"data");
}

#[test]
fn test_symlink_loop_detection() {
    let backend = MemoryBackend::new();
    backend.symlink(std::path::Path::new("/link2.txt"), std::path::Path::new("/link1.txt")).unwrap();
    backend.symlink(std::path::Path::new("/link1.txt"), std::path::Path::new("/link2.txt")).unwrap();

    let result = backend.read(std::path::Path::new("/link1.txt"));
    assert!(matches!(result, Err(FsError::SymlinkLoop { .. })));
}

#[test]
fn test_virtual_symlink_cannot_escape() {
    let backend = MemoryBackend::new();
    // Create a symlink pointing "outside" - but in virtual backend, paths are just keys
    backend.symlink(std::path::Path::new("../../../etc/passwd"), std::path::Path::new("/link.txt")).unwrap();

    // Reading should fail (target doesn't exist), not read real /etc/passwd
    let result = backend.read(std::path::Path::new("/link.txt"));
    assert!(matches!(result, Err(FsError::NotFound { .. })));
}
<span class="boring">}</span></code></pre>
<h3 id="vrootfsbackend-containment-tests"><a class="header" href="#vrootfsbackend-containment-tests">VRootFsBackend Containment Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_vroot_prevents_path_traversal() {
    let temp = tempfile::tempdir().unwrap();
    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    // Attempt to escape via ..
    let result = fs.read("/../../../etc/passwd");
    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_vroot_prevents_symlink_escape() {
    let temp = tempfile::tempdir().unwrap();
    std::fs::write(temp.path().join("file.txt"), b"data").unwrap();

    // Create symlink pointing outside the jail
    #[cfg(unix)]
    std::os::unix::fs::symlink("/etc/passwd", temp.path().join("escape")).unwrap();

    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    // Reading should be blocked by strict-path
    let result = fs.read("/escape");
    assert!(matches!(result, Err(FsError::AccessDenied { .. })));
}

#[test]
fn test_vroot_allows_internal_symlinks() {
    let temp = tempfile::tempdir().unwrap();
    std::fs::write(temp.path().join("target.txt"), b"data").unwrap();

    #[cfg(unix)]
    std::os::unix::fs::symlink("target.txt", temp.path().join("link.txt")).unwrap();

    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    // Internal symlinks should work
    assert_eq!(fs.read("/link.txt").unwrap(), b"data");
}

#[test]
fn test_vroot_canonicalizes_paths() {
    let temp = tempfile::tempdir().unwrap();
    let backend = VRootFsBackend::new(temp.path()).unwrap();
    let fs = FileStorage::new(backend);

    fs.create_dir("/a").unwrap();
    fs.write("/a/file.txt", b"data").unwrap();

    // Access via normalized path
    assert_eq!(fs.read("/a/../a/./file.txt").unwrap(), b"data");
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="9-ratelimit-middleware-tests"><a class="header" href="#9-ratelimit-middleware-tests">9. RateLimit Middleware Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ratelimit_allows_within_limit() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(10).per_second().build());
    let fs = FileStorage::new(backend);

    // Should succeed within limit
    for i in 0..5 {
        fs.write(format!("/file{}.txt", i), b"data").unwrap();
    }
}

#[test]
fn test_ratelimit_blocks_when_exceeded() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(3).per_second().build());
    let fs = FileStorage::new(backend);

    fs.write("/file1.txt", b"data").unwrap();
    fs.write("/file2.txt", b"data").unwrap();
    fs.write("/file3.txt", b"data").unwrap();

    let result = fs.write("/file4.txt", b"data");
    assert!(matches!(result, Err(FsError::RateLimitExceeded { .. })));
}

#[test]
fn test_ratelimit_resets_after_window() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(2).per(Duration::from_millis(100)).build());
    let fs = FileStorage::new(backend);

    fs.write("/file1.txt", b"data").unwrap();
    fs.write("/file2.txt", b"data").unwrap();

    // Wait for window to reset
    std::thread::sleep(Duration::from_millis(150));

    // Should succeed again
    fs.write("/file3.txt", b"data").unwrap();
}

#[test]
fn test_ratelimit_counts_all_operations() {
    let backend = MemoryBackend::new()
        .layer(RateLimitLayer::builder().max_ops(3).per_second().build());
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", b"data").unwrap();  // 1
    let _ = fs.read("/file.txt");              // 2
    let _ = fs.exists("/file.txt");            // 3

    let result = fs.metadata("/file.txt");
    assert!(matches!(result, Err(FsError::RateLimitExceeded { .. })));
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="10-tracing-middleware-tests"><a class="header" href="#10-tracing-middleware-tests">10. Tracing Middleware Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

#[derive(Default)]
struct TestLogger {
    logs: Arc&lt;Mutex&lt;Vec&lt;String&gt;&gt;&gt;,
}

impl TestLogger {
    fn entries(&amp;self) -&gt; Vec&lt;String&gt; {
        self.logs.lock().unwrap().clone()
    }
}

#[test]
fn test_tracing_logs_operations() {
    let logger = TestLogger::default();
    let logs = Arc::clone(&amp;logger.logs);

    let backend = MemoryBackend::new()
        .layer(TracingLayer::new()
            .with_logger(move |op| {
                logs.lock().unwrap().push(op.to_string());
            }));
    let fs = FileStorage::new(backend);

    fs.write("/file.txt", b"data").unwrap();
    fs.read("/file.txt").unwrap();

    let entries = logger.entries();
    assert!(entries.iter().any(|e| e.contains("write")));
    assert!(entries.iter().any(|e| e.contains("read")));
}

#[test]
fn test_tracing_includes_path() {
    let logger = TestLogger::default();
    let logs = Arc::clone(&amp;logger.logs);

    let backend = MemoryBackend::new()
        .layer(TracingLayer::new()
            .with_logger(move |op| {
                logs.lock().unwrap().push(op.to_string());
            }));
    let fs = FileStorage::new(backend);

    fs.write("/important/secret.txt", b"data").unwrap();

    let entries = logger.entries();
    assert!(entries.iter().any(|e| e.contains("/important/secret.txt")));
}

#[test]
fn test_tracing_logs_errors() {
    let logger = TestLogger::default();
    let logs = Arc::clone(&amp;logger.logs);

    let backend = MemoryBackend::new()
        .layer(TracingLayer::new()
            .with_logger(move |op| {
                logs.lock().unwrap().push(op.to_string());
            }));
    let fs = FileStorage::new(backend);

    let _ = fs.read("/nonexistent.txt");

    let entries = logger.entries();
    assert!(entries.iter().any(|e| e.contains("NotFound") || e.contains("error")));
}

#[test]
fn test_tracing_with_span_context() {
    use tracing::{info_span, Instrument};

    let backend = MemoryBackend::new().layer(TracingLayer::new());
    let fs = FileStorage::new(backend);

    async {
        fs.write("/async.txt", b"data").unwrap();
    }
    .instrument(info_span!("test_operation"))
    .now_or_never();
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="11-backend-interchangeability-tests"><a class="header" href="#11-backend-interchangeability-tests">11. Backend Interchangeability Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Ensure all backends can be used interchangeably
fn generic_filesystem_test&lt;B: Fs&gt;(mut backend: B) {
    backend.create_dir(std::path::Path::new("/test")).unwrap();
    backend.write(std::path::Path::new("/test/file.txt"), b"hello").unwrap();
    assert_eq!(backend.read(std::path::Path::new("/test/file.txt")).unwrap(), b"hello");
    backend.remove_dir_all(std::path::Path::new("/test")).unwrap();
    assert!(!backend.exists(std::path::Path::new("/test")).unwrap());
}

#[test]
fn test_memory_backend_interchangeable() {
    generic_filesystem_test(MemoryBackend::new());
}

#[test]
fn test_sqlite_backend_interchangeable() {
    let (backend, _temp) = temp_sqlite_backend();
    generic_filesystem_test(backend);
}

#[test]
fn test_vroot_backend_interchangeable() {
    let temp = tempfile::tempdir().unwrap();
    let backend = VRootFsBackend::new(temp.path()).unwrap();
    generic_filesystem_test(backend);
}

#[test]
fn test_middleware_stack_interchangeable() {
    let backend = MemoryBackend::new()
        .layer(QuotaLayer::builder()
            .max_total_size(1024 * 1024)
            .build())
        .layer(TracingLayer::new());
    generic_filesystem_test(backend);
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="12-property-based-tests"><a class="header" href="#12-property-based-tests">12. Property-Based Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn prop_write_read_roundtrip(data: Vec&lt;u8&gt;) {
        let backend = MemoryBackend::new();
        backend.write(std::path::Path::new("/file.bin"), &amp;data).unwrap();
        let read_data = backend.read(std::path::Path::new("/file.bin")).unwrap();
        prop_assert_eq!(data, read_data);
    }

    #[test]
    fn prop_path_normalization_idempotent(path in "[a-z/]{1,50}") {
        let backend = MemoryBackend::new();
        if let Ok(()) = backend.create_dir_all(std::path::Path::new(&amp;path)) {
            // Creating again should either succeed or return AlreadyExists
            let result = backend.create_dir_all(std::path::Path::new(&amp;path));
            prop_assert!(result.is_ok() || matches!(result, Err(FsError::AlreadyExists { .. })));
        }
    }

    #[test]
    fn prop_quota_never_exceeds_limit(
        file_count in 1..10usize,
        file_sizes in prop::collection::vec(1..100usize, 1..10)
    ) {
        let limit = 500usize;
        let backend = MemoryBackend::new()
            .layer(QuotaLayer::builder().max_total_size(limit as u64).build());
        let fs = FileStorage::new(backend);

        let mut total_written = 0usize;
        for (i, size) in file_sizes.into_iter().take(file_count).enumerate() {
            let data = vec![0u8; size];
            match fs.write(format!("/file{}.txt", i), &amp;data) {
                Ok(()) =&gt; total_written += size,
                Err(FsError::QuotaExceeded { .. }) =&gt; break,
                Err(e) =&gt; panic!("Unexpected error: {:?}", e),
            }
        }
        prop_assert!(total_written &lt;= limit);
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="13-snapshot--restore-tests"><a class="header" href="#13-snapshot--restore-tests">13. Snapshot &amp; Restore Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MemoryBackend implements Clone - that's the snapshot mechanism
#[test]
fn test_clone_creates_independent_copy() {
    let mut original = MemoryBackend::new();
    original.write(std::path::Path::new("/file.txt"), b"original").unwrap();

    // Clone = snapshot
    let mut snapshot = original.clone();

    // Modify original
    original.write(std::path::Path::new("/file.txt"), b"modified").unwrap();
    original.write(std::path::Path::new("/new.txt"), b"new").unwrap();

    // Snapshot is unchanged
    assert_eq!(snapshot.read(std::path::Path::new("/file.txt")).unwrap(), b"original");
    assert!(!snapshot.exists(std::path::Path::new("/new.txt")).unwrap());
}

#[test]
fn test_checkpoint_and_rollback() {
    let fs = MemoryBackend::new();
    fs.write(std::path::Path::new("/important.txt"), b"original").unwrap();

    // Checkpoint = clone
    let checkpoint = fs.clone();

    // Do risky work
    fs.write(std::path::Path::new("/important.txt"), b"corrupted").unwrap();

    // Rollback = replace with checkpoint
    fs = checkpoint;
    assert_eq!(fs.read(std::path::Path::new("/important.txt")).unwrap(), b"original");
}

#[test]
fn test_persistence_roundtrip() {
    let temp = tempfile::tempdir().unwrap();
    let path = temp.path().join("state.bin");

    let fs = MemoryBackend::new();
    fs.write(std::path::Path::new("/data.txt"), b"persisted").unwrap();

    // Save
    fs.save_to(&amp;path).unwrap();

    // Load
    let restored = MemoryBackend::load_from(&amp;path).unwrap();
    assert_eq!(restored.read(std::path::Path::new("/data.txt")).unwrap(), b"persisted");
}

#[test]
fn test_to_bytes_from_bytes() {
    let fs = MemoryBackend::new();
    fs.create_dir_all(std::path::Path::new("/a/b/c")).unwrap();
    fs.write(std::path::Path::new("/a/b/c/file.txt"), b"nested").unwrap();

    let bytes = fs.to_bytes().unwrap();
    let restored = MemoryBackend::from_bytes(&amp;bytes).unwrap();

    assert_eq!(restored.read(std::path::Path::new("/a/b/c/file.txt")).unwrap(), b"nested");
}

#[test]
fn test_from_bytes_invalid_data() {
    let result = MemoryBackend::from_bytes(b"garbage");
    assert!(result.is_err());
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="14-running-tests"><a class="header" href="#14-running-tests">14. Running Tests</a></h2>
<pre><code class="language-bash"># All tests
cargo test

# Specific backend conformance
cargo test memory_backend_conformance
cargo test sqlite_backend_conformance

# Middleware tests
cargo test quota
cargo test restrictions
cargo test pathfilter

# Stress tests (release mode)
cargo test --release -- --ignored

# With coverage
cargo tarpaulin --out Html

# Cross-platform (CI)
cargo test --target x86_64-unknown-linux-gnu
cargo test --target x86_64-pc-windows-msvc
cargo test --target x86_64-apple-darwin

# WASM
cargo test --target wasm32-unknown-unknown
</code></pre>
<hr>
<h2 id="9-test-utilities"><a class="header" href="#9-test-utilities">9. Test Utilities</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-test crate

/// Create a temporary backend for testing
pub fn temp_sqlite_backend() -&gt; (SqliteBackend, tempfile::TempDir) {
    let temp = tempfile::tempdir().unwrap();
    let db_path = temp.path().join("test.db");
    let backend = SqliteBackend::open(&amp;db_path).unwrap();
    (backend, temp)
}

/// Run a test against multiple backends
pub fn test_all_backends&lt;F&gt;(test: F)
where
    F: Fn(&amp;mut dyn Fs),
{
    // Memory
    let backend = MemoryBackend::new();
    test(&amp;mut backend);

    // SQLite
    let (mut backend, _temp) = temp_sqlite_backend();
    test(&amp;mut backend);
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="conformance-test-suite"><a class="header" href="#conformance-test-suite">Conformance Test Suite</a></h1>
<p><strong>Verify your backend or middleware works correctly with AnyFS</strong></p>
<p>This document provides a complete test suite skeleton that any backend or middleware implementer can use to verify their implementation meets the AnyFS trait contracts.</p>
<hr>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>The conformance test suite verifies:</p>
<ol>
<li><strong>Correctness</strong> - Operations behave as specified</li>
<li><strong>Error handling</strong> - Correct errors for edge cases</li>
<li><strong>Thread safety</strong> - Safe concurrent access</li>
<li><strong>Trait contracts</strong> - All trait requirements met</li>
</ol>
<h3 id="test-levels"><a class="header" href="#test-levels">Test Levels</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Traits Tested</th><th>When to Use</th></tr>
</thead>
<tbody>
<tr><td><strong>Core</strong></td><td><code>FsRead</code>, <code>FsWrite</code>, <code>FsDir</code> (= <code>Fs</code>)</td><td>All backends</td></tr>
<tr><td><strong>Full</strong></td><td>+ <code>FsLink</code>, <code>FsPermissions</code>, <code>FsSync</code>, <code>FsStats</code></td><td>Extended backends</td></tr>
<tr><td><strong>Fuse</strong></td><td>+ <code>FsInode</code></td><td>FUSE-mountable backends</td></tr>
<tr><td><strong>Posix</strong></td><td>+ <code>FsHandles</code>, <code>FsLock</code>, <code>FsXattr</code></td><td>Full POSIX backends</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="for-backend-implementers-1"><a class="header" href="#for-backend-implementers-1">For Backend Implementers</a></h3>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
anyfs-test = "0.1"  # Conformance test suite
</code></pre>
<p>Then in your test file:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_test::prelude::*;

// Tell the test suite how to create your backend
fn create_backend() -&gt; MyBackend {
    MyBackend::new()
}

// Run all Fs-level tests
anyfs_test::generate_fs_tests!(create_backend);

// If you implement FsFull traits:
// anyfs_test::generate_fs_full_tests!(create_backend);

// If you implement FsFuse traits:
// anyfs_test::generate_fs_fuse_tests!(create_backend);
<span class="boring">}</span></code></pre>
<h3 id="for-middleware-implementers-1"><a class="header" href="#for-middleware-implementers-1">For Middleware Implementers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_test::prelude::*;
use anyfs::MemoryBackend;

// Wrap MemoryBackend with your middleware
fn create_backend() -&gt; MyMiddleware&lt;MemoryBackend&gt; {
    MyMiddleware::new(MemoryBackend::new())
}

// Run all tests through your middleware
anyfs_test::generate_fs_tests!(create_backend);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="core-test-suite-fs-traits"><a class="header" href="#core-test-suite-fs-traits">Core Test Suite (Fs Traits)</a></h2>
<p>Copy this entire module into your test file and customize <code>create_backend()</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Conformance tests for Fs trait implementations.
//!
//! To use: implement `create_backend()` and include this module.

use anyfs_backend::{Fs, FsRead, FsWrite, FsDir, FsError, FileType, Metadata, ReadDirIter};
use std::path::Path;
use std::sync::Arc;
use std::thread;

/// Create a fresh backend instance for testing.
/// Implement this for your backend.
fn create_backend() -&gt; impl Fs {
    todo!("Return your backend here")
}

// ============================================================================
// FsRead Tests
// ============================================================================

mod fs_read {
    use super::*;

    #[test]
    fn read_existing_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/test.txt"), b"hello world").unwrap();

        let content = fs.read(std::path::Path::new("/test.txt")).unwrap();
        assert_eq!(content, b"hello world");
    }

    #[test]
    fn read_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.read(std::path::Path::new("/nonexistent.txt"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn read_directory_returns_not_a_file() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/mydir")).unwrap();

        let result = fs.read(std::path::Path::new("/mydir"));
        assert!(matches!(result, Err(FsError::NotAFile { .. })));
    }

    #[test]
    fn read_to_string_valid_utf8() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/text.txt"), "hello unicode: 你好".as_bytes()).unwrap();

        let content = fs.read_to_string(std::path::Path::new("/text.txt")).unwrap();
        assert_eq!(content, "hello unicode: 你好");
    }

    #[test]
    fn read_to_string_invalid_utf8_returns_error() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/binary.bin"), &amp;[0xFF, 0xFE, 0x00, 0x01]).unwrap();

        let result = fs.read_to_string(std::path::Path::new("/binary.bin"));
        assert!(result.is_err());
    }

    #[test]
    fn read_range_full_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/data.bin"), b"0123456789").unwrap();

        let content = fs.read_range(std::path::Path::new("/data.bin"), 0, 10).unwrap();
        assert_eq!(content, b"0123456789");
    }

    #[test]
    fn read_range_partial() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/data.bin"), b"0123456789").unwrap();

        let content = fs.read_range(std::path::Path::new("/data.bin"), 3, 4).unwrap();
        assert_eq!(content, b"3456");
    }

    #[test]
    fn read_range_past_end_returns_available() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/data.bin"), b"0123456789").unwrap();

        let content = fs.read_range(std::path::Path::new("/data.bin"), 8, 100).unwrap();
        assert_eq!(content, b"89");
    }

    #[test]
    fn read_range_offset_past_end_returns_empty() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/data.bin"), b"0123456789").unwrap();

        let content = fs.read_range(std::path::Path::new("/data.bin"), 100, 10).unwrap();
        assert!(content.is_empty());
    }

    #[test]
    fn exists_for_existing_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/exists.txt"), b"data").unwrap();

        assert!(fs.exists(std::path::Path::new("/exists.txt")).unwrap());
    }

    #[test]
    fn exists_for_nonexistent_file() {
        let fs = create_backend();

        assert!(!fs.exists(std::path::Path::new("/nonexistent.txt")).unwrap());
    }

    #[test]
    fn exists_for_directory() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/mydir")).unwrap();

        assert!(fs.exists(std::path::Path::new("/mydir")).unwrap());
    }

    #[test]
    fn metadata_for_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"hello").unwrap();

        let meta = fs.metadata(std::path::Path::new("/file.txt")).unwrap();
        assert_eq!(meta.file_type, FileType::File);
        assert_eq!(meta.size, 5);
    }

    #[test]
    fn metadata_for_directory() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/mydir")).unwrap();

        let meta = fs.metadata(std::path::Path::new("/mydir")).unwrap();
        assert_eq!(meta.file_type, FileType::Directory);
    }

    #[test]
    fn metadata_for_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.metadata(std::path::Path::new("/nonexistent"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn open_read_and_consume() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/stream.txt"), b"streaming content").unwrap();

        let mut reader = fs.open_read(std::path::Path::new("/stream.txt")).unwrap();
        let mut buf = Vec::new();
        std::io::Read::read_to_end(&amp;mut reader, &amp;mut buf).unwrap();

        assert_eq!(buf, b"streaming content");
    }
}

// ============================================================================
// FsWrite Tests
// ============================================================================

mod fs_write {
    use super::*;

    #[test]
    fn write_creates_new_file() {
        let fs = create_backend();

        fs.write(std::path::Path::new("/new.txt"), b"new content").unwrap();

        assert!(fs.exists(std::path::Path::new("/new.txt")).unwrap());
        assert_eq!(fs.read(std::path::Path::new("/new.txt")).unwrap(), b"new content");
    }

    #[test]
    fn write_overwrites_existing_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"original").unwrap();

        fs.write(std::path::Path::new("/file.txt"), b"replaced").unwrap();

        assert_eq!(fs.read(std::path::Path::new("/file.txt")).unwrap(), b"replaced");
    }

    #[test]
    fn write_to_nonexistent_parent_returns_not_found() {
        let fs = create_backend();

        let result = fs.write(std::path::Path::new("/nonexistent/file.txt"), b"data");
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn write_empty_file() {
        let fs = create_backend();

        fs.write(std::path::Path::new("/empty.txt"), b"").unwrap();

        assert!(fs.exists(std::path::Path::new("/empty.txt")).unwrap());
        assert_eq!(fs.read(std::path::Path::new("/empty.txt")).unwrap(), b"");
    }

    #[test]
    fn write_binary_data() {
        let fs = create_backend();
        let binary: Vec&lt;u8&gt; = (0..=255).collect();

        fs.write(std::path::Path::new("/binary.bin"), &amp;binary).unwrap();

        assert_eq!(fs.read(std::path::Path::new("/binary.bin")).unwrap(), binary);
    }

    #[test]
    fn append_to_existing_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/log.txt"), b"line1\n").unwrap();

        fs.append(std::path::Path::new("/log.txt"), b"line2\n").unwrap();

        assert_eq!(fs.read(std::path::Path::new("/log.txt")).unwrap(), b"line1\nline2\n");
    }

    #[test]
    fn append_to_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.append(std::path::Path::new("/nonexistent.txt"), b"data");
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn remove_file_existing() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/delete-me.txt"), b"bye").unwrap();

        fs.remove_file(std::path::Path::new("/delete-me.txt")).unwrap();

        assert!(!fs.exists(std::path::Path::new("/delete-me.txt")).unwrap());
    }

    #[test]
    fn remove_file_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.remove_file(std::path::Path::new("/nonexistent.txt"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn remove_file_on_directory_returns_not_a_file() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/mydir")).unwrap();

        let result = fs.remove_file(std::path::Path::new("/mydir"));
        assert!(matches!(result, Err(FsError::NotAFile { .. })));
    }

    #[test]
    fn rename_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/old.txt"), b"content").unwrap();

        fs.rename(std::path::Path::new("/old.txt"), std::path::Path::new("/new.txt")).unwrap();

        assert!(!fs.exists(std::path::Path::new("/old.txt")).unwrap());
        assert!(fs.exists(std::path::Path::new("/new.txt")).unwrap());
        assert_eq!(fs.read(std::path::Path::new("/new.txt")).unwrap(), b"content");
    }

    #[test]
    fn rename_overwrites_destination() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/src.txt"), b"source").unwrap();
        fs.write(std::path::Path::new("/dst.txt"), b"destination").unwrap();

        fs.rename(std::path::Path::new("/src.txt"), std::path::Path::new("/dst.txt")).unwrap();

        assert!(!fs.exists(std::path::Path::new("/src.txt")).unwrap());
        assert_eq!(fs.read(std::path::Path::new("/dst.txt")).unwrap(), b"source");
    }

    #[test]
    fn rename_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.rename(std::path::Path::new("/nonexistent.txt"), std::path::Path::new("/new.txt"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn copy_file() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/original.txt"), b"data").unwrap();

        fs.copy(std::path::Path::new("/original.txt"), std::path::Path::new("/copy.txt")).unwrap();

        assert!(fs.exists(std::path::Path::new("/original.txt")).unwrap());
        assert!(fs.exists(std::path::Path::new("/copy.txt")).unwrap());
        assert_eq!(fs.read(std::path::Path::new("/copy.txt")).unwrap(), b"data");
    }

    #[test]
    fn copy_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.copy(std::path::Path::new("/nonexistent.txt"), std::path::Path::new("/copy.txt"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn truncate_shrink() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"0123456789").unwrap();

        fs.truncate(std::path::Path::new("/file.txt"), 5).unwrap();

        assert_eq!(fs.read(std::path::Path::new("/file.txt")).unwrap(), b"01234");
    }

    #[test]
    fn truncate_expand() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"abc").unwrap();

        fs.truncate(std::path::Path::new("/file.txt"), 6).unwrap();

        let content = fs.read(std::path::Path::new("/file.txt")).unwrap();
        assert_eq!(content.len(), 6);
        assert_eq!(&amp;content[..3], b"abc");
        // Expanded bytes should be zero
        assert!(content[3..].iter().all(|&amp;b| b == 0));
    }

    #[test]
    fn truncate_to_zero() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"content").unwrap();

        fs.truncate(std::path::Path::new("/file.txt"), 0).unwrap();

        assert_eq!(fs.read(std::path::Path::new("/file.txt")).unwrap(), b"");
    }

    #[test]
    fn open_write_and_close() {
        let fs = create_backend();

        {
            let mut writer = fs.open_write(std::path::Path::new("/stream.txt")).unwrap();
            std::io::Write::write_all(&amp;mut writer, b"streamed").unwrap();
        }

        // Content should be visible after writer is dropped
        assert_eq!(fs.read(std::path::Path::new("/stream.txt")).unwrap(), b"streamed");
    }
}

// ============================================================================
// FsDir Tests
// ============================================================================

mod fs_dir {
    use super::*;

    #[test]
    fn create_dir_single() {
        let fs = create_backend();

        fs.create_dir(std::path::Path::new("/newdir")).unwrap();

        assert!(fs.exists(std::path::Path::new("/newdir")).unwrap());
        let meta = fs.metadata(std::path::Path::new("/newdir")).unwrap();
        assert_eq!(meta.file_type, FileType::Directory);
    }

    #[test]
    fn create_dir_already_exists_returns_error() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/existing")).unwrap();

        let result = fs.create_dir(std::path::Path::new("/existing"));
        assert!(matches!(result, Err(FsError::AlreadyExists { .. })));
    }

    #[test]
    fn create_dir_parent_not_exists_returns_not_found() {
        let fs = create_backend();

        let result = fs.create_dir(std::path::Path::new("/nonexistent/child"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn create_dir_all_nested() {
        let fs = create_backend();

        fs.create_dir_all(std::path::Path::new("/a/b/c/d")).unwrap();

        assert!(fs.exists(std::path::Path::new("/a")).unwrap());
        assert!(fs.exists(std::path::Path::new("/a/b")).unwrap());
        assert!(fs.exists(std::path::Path::new("/a/b/c")).unwrap());
        assert!(fs.exists(std::path::Path::new("/a/b/c/d")).unwrap());
    }

    #[test]
    fn create_dir_all_partially_exists() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/exists")).unwrap();

        fs.create_dir_all(std::path::Path::new("/exists/new/nested")).unwrap();

        assert!(fs.exists(std::path::Path::new("/exists/new/nested")).unwrap());
    }

    #[test]
    fn create_dir_all_already_exists_is_ok() {
        let fs = create_backend();
        fs.create_dir_all(std::path::Path::new("/a/b/c")).unwrap();

        // Should not error
        fs.create_dir_all(std::path::Path::new("/a/b/c")).unwrap();
    }

    #[test]
    fn read_dir_empty() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/empty")).unwrap();

        let entries: Vec&lt;_&gt; = fs.read_dir(std::path::Path::new("/empty")).unwrap()
            .filter_map(|e| e.ok())
            .collect();

        assert!(entries.is_empty());
    }

    #[test]
    fn read_dir_with_files() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/parent")).unwrap();
        fs.write(std::path::Path::new("/parent/file1.txt"), b"1").unwrap();
        fs.write(std::path::Path::new("/parent/file2.txt"), b"2").unwrap();
        fs.create_dir(std::path::Path::new("/parent/subdir")).unwrap();

        let mut entries: Vec&lt;_&gt; = fs.read_dir(std::path::Path::new("/parent")).unwrap()
            .filter_map(|e| e.ok())
            .collect();
        entries.sort_by(|a, b| a.name.cmp(&amp;b.name));

        assert_eq!(entries.len(), 3);
        assert_eq!(entries[0].name, "file1.txt");
        assert_eq!(entries[0].file_type, FileType::File);
        assert_eq!(entries[1].name, "file2.txt");
        assert_eq!(entries[2].name, "subdir");
        assert_eq!(entries[2].file_type, FileType::Directory);
    }

    #[test]
    fn read_dir_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.read_dir(std::path::Path::new("/nonexistent"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn read_dir_on_file_returns_not_a_directory() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

        let result = fs.read_dir(std::path::Path::new("/file.txt"));
        assert!(matches!(result, Err(FsError::NotADirectory { .. })));
    }

    #[test]
    fn remove_dir_empty() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/todelete")).unwrap();

        fs.remove_dir(std::path::Path::new("/todelete")).unwrap();

        assert!(!fs.exists(std::path::Path::new("/todelete")).unwrap());
    }

    #[test]
    fn remove_dir_not_empty_returns_error() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/notempty")).unwrap();
        fs.write(std::path::Path::new("/notempty/file.txt"), b"data").unwrap();

        let result = fs.remove_dir(std::path::Path::new("/notempty"));
        assert!(matches!(result, Err(FsError::DirectoryNotEmpty { .. })));
    }

    #[test]
    fn remove_dir_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.remove_dir(std::path::Path::new("/nonexistent"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn remove_dir_on_file_returns_not_a_directory() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

        let result = fs.remove_dir(std::path::Path::new("/file.txt"));
        assert!(matches!(result, Err(FsError::NotADirectory { .. })));
    }

    #[test]
    fn remove_dir_all_recursive() {
        let fs = create_backend();
        fs.create_dir_all(std::path::Path::new("/root/a/b")).unwrap();
        fs.write(std::path::Path::new("/root/file.txt"), b"data").unwrap();
        fs.write(std::path::Path::new("/root/a/nested.txt"), b"nested").unwrap();

        fs.remove_dir_all(std::path::Path::new("/root")).unwrap();

        assert!(!fs.exists(std::path::Path::new("/root")).unwrap());
        assert!(!fs.exists(std::path::Path::new("/root/a")).unwrap());
        assert!(!fs.exists(std::path::Path::new("/root/file.txt")).unwrap());
    }

    #[test]
    fn remove_dir_all_nonexistent_returns_not_found() {
        let fs = create_backend();

        let result = fs.remove_dir_all(std::path::Path::new("/nonexistent"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }
}

// ============================================================================
// Edge Case Tests
// ============================================================================

mod edge_cases {
    use super::*;

    #[test]
    fn root_directory_exists() {
        let fs = create_backend();

        assert!(fs.exists(std::path::Path::new("/")).unwrap());
        let meta = fs.metadata(std::path::Path::new("/")).unwrap();
        assert_eq!(meta.file_type, FileType::Directory);
    }

    #[test]
    fn read_dir_root() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

        let entries: Vec&lt;_&gt; = fs.read_dir(std::path::Path::new("/")).unwrap()
            .filter_map(|e| e.ok())
            .collect();

        assert!(!entries.is_empty());
    }

    #[test]
    fn cannot_remove_root() {
        let fs = create_backend();

        let result = fs.remove_dir(std::path::Path::new("/"));
        assert!(result.is_err());
    }

    #[test]
    fn cannot_remove_root_all() {
        let fs = create_backend();

        let result = fs.remove_dir_all(std::path::Path::new("/"));
        assert!(result.is_err());
    }

    #[test]
    fn file_at_root_level() {
        let fs = create_backend();

        fs.write(std::path::Path::new("/rootfile.txt"), b"at root").unwrap();

        assert!(fs.exists(std::path::Path::new("/rootfile.txt")).unwrap());
        assert_eq!(fs.read(std::path::Path::new("/rootfile.txt")).unwrap(), b"at root");
    }

    #[test]
    fn deeply_nested_path() {
        let fs = create_backend();
        let deep_path = "/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p";

        fs.create_dir_all(std::path::Path::new(deep_path)).unwrap();
        fs.write(std::path::Path::new(&amp;format!("{}/file.txt", deep_path)), b"deep").unwrap();

        assert_eq!(
            fs.read(std::path::Path::new(&amp;format!("{}/file.txt", deep_path))).unwrap(),
            b"deep"
        );
    }

    #[test]
    fn unicode_filename() {
        let fs = create_backend();

        fs.write(std::path::Path::new("/文件.txt"), b"chinese").unwrap();
        fs.write(std::path::Path::new("/файл.txt"), b"russian").unwrap();
        fs.write(std::path::Path::new("/αρχείο.txt"), b"greek").unwrap();

        assert_eq!(fs.read(std::path::Path::new("/文件.txt")).unwrap(), b"chinese");
        assert_eq!(fs.read(std::path::Path::new("/файл.txt")).unwrap(), b"russian");
        assert_eq!(fs.read(std::path::Path::new("/αρχείο.txt")).unwrap(), b"greek");
    }

    #[test]
    fn filename_with_spaces() {
        let fs = create_backend();

        fs.write(std::path::Path::new("/file with spaces.txt"), b"spaced").unwrap();

        assert!(fs.exists(std::path::Path::new("/file with spaces.txt")).unwrap());
        assert_eq!(fs.read(std::path::Path::new("/file with spaces.txt")).unwrap(), b"spaced");
    }

    #[test]
    fn filename_with_special_chars() {
        let fs = create_backend();

        fs.write(std::path::Path::new("/file-name_123.test.txt"), b"special").unwrap();

        assert!(fs.exists(std::path::Path::new("/file-name_123.test.txt")).unwrap());
    }

    #[test]
    fn large_file() {
        let fs = create_backend();
        let large_data: Vec&lt;u8&gt; = (0..1_000_000).map(|i| (i % 256) as u8).collect();

        fs.write(std::path::Path::new("/large.bin"), &amp;large_data).unwrap();

        assert_eq!(fs.read(std::path::Path::new("/large.bin")).unwrap(), large_data);
    }

    #[test]
    fn many_files_in_directory() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/many")).unwrap();

        for i in 0..100 {
            fs.write(std::path::Path::new(&amp;format!("/many/file_{:03}.txt", i)), format!("{}", i).as_bytes()).unwrap();
        }

        let entries: Vec&lt;_&gt; = fs.read_dir(std::path::Path::new("/many")).unwrap()
            .filter_map(|e| e.ok())
            .collect();

        assert_eq!(entries.len(), 100);
    }

    #[test]
    fn overwrite_larger_with_smaller() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"this is a longer content").unwrap();

        fs.write(std::path::Path::new("/file.txt"), b"short").unwrap();

        assert_eq!(fs.read(std::path::Path::new("/file.txt")).unwrap(), b"short");
    }

    #[test]
    fn overwrite_smaller_with_larger() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"short").unwrap();

        fs.write(std::path::Path::new("/file.txt"), b"this is a longer content").unwrap();

        assert_eq!(fs.read(std::path::Path::new("/file.txt")).unwrap(), b"this is a longer content");
    }
}

// ============================================================================
// Security Tests (Learned from Prior Art Vulnerabilities)
// ============================================================================

mod security {
    use super::*;

    // ------------------------------------------------------------------------
    // Path Traversal Tests (Apache Commons VFS CVE-inspired)
    // ------------------------------------------------------------------------

    #[test]
    fn reject_dotdot_traversal() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();
        fs.write(std::path::Path::new("/secret.txt"), b"secret").unwrap();

        // Direct .. traversal must be blocked or normalized
        let result = fs.read(std::path::Path::new("/sandbox/../secret.txt"));
        // Either blocks the operation or normalizes to /secret.txt (acceptable)
        // But must NOT escape sandbox context in sandboxed backends
    }

    #[test]
    fn reject_url_encoded_dotdot() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();

        // URL-encoded path traversal: %2e = '.', %2f = '/'
        // This caused CVE in Apache Commons VFS
        let result = fs.read(std::path::Path::new("/sandbox/%2e%2e/etc/passwd"));
        assert!(result.is_err(), "URL-encoded path traversal must be rejected");

        // Double-encoded traversal
        let result = fs.read(std::path::Path::new("/sandbox/%252e%252e/etc/passwd"));
        assert!(result.is_err(), "Double URL-encoded traversal must be rejected");
    }

    #[test]
    fn reject_backslash_traversal() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();

        // Windows-style path traversal
        let result = fs.read(std::path::Path::new("/sandbox\\..\\secret.txt"));
        assert!(result.is_err(), "Backslash traversal must be rejected");
    }

    #[test]
    fn reject_mixed_slash_traversal() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();

        // Mixed forward/backward slashes
        let result = fs.read(std::path::Path::new("/sandbox/..\\..\\secret.txt"));
        assert!(result.is_err(), "Mixed slash traversal must be rejected");

        let result = fs.read(std::path::Path::new("/sandbox\\../secret.txt"));
        assert!(result.is_err(), "Mixed slash traversal must be rejected");
    }

    #[test]
    fn reject_null_byte_injection() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/safe.txt"), b"safe").unwrap();
        fs.write(std::path::Path::new("/safe.txt.bak"), b"backup").unwrap();

        // Null byte injection: /safe.txt\0.bak -&gt; /safe.txt
        let result = fs.read(std::path::Path::new("/safe.txt\0.bak"));
        // Should either reject or not truncate at null
        if let Ok(content) = result {
            // If it succeeds, it should read the full path, not truncated
            assert_ne!(content, b"safe", "Null byte must not truncate path");
        }
    }

    // ------------------------------------------------------------------------
    // Symlink Security Tests (Afero-inspired)
    // ------------------------------------------------------------------------

    #[test]
    fn symlink_cannot_escape_sandbox() {
        // This test is for sandboxed backends (e.g., VRootFs)
        // Regular backends may allow this, which is fine
        let fs = create_backend();

        // Attempt to create symlink pointing outside virtual root
        let result = fs.symlink(std::path::Path::new("/etc/passwd"), std::path::Path::new("/escape_link"));

        // Sandboxed backends MUST reject this
        // Non-sandboxed backends may allow it
        // The key is: reading through the symlink must not expose
        // content outside the sandbox
    }

    #[test]
    fn symlink_to_absolute_path_outside() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();
        fs.write(std::path::Path::new("/sandbox/safe.txt"), b"safe").unwrap();

        // Symlink pointing to absolute path outside sandbox
        // In sandboxed context, this must either:
        // 1. Reject symlink creation, or
        // 2. Resolve relative to sandbox root
        let result = fs.symlink(std::path::Path::new("/../../../etc/passwd"), std::path::Path::new("/sandbox/link"));
        // Behavior depends on backend type
    }

    #[test]
    fn relative_symlink_traversal() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();
        fs.create_dir(std::path::Path::new("/sandbox/subdir")).unwrap();
        fs.write(std::path::Path::new("/secret.txt"), b"secret outside sandbox").unwrap();

        // Relative symlink that traverses up and out
        let _ = fs.symlink(std::path::Path::new("../../secret.txt"), std::path::Path::new("/sandbox/subdir/link"));

        // If symlink was created, reading through it in a sandboxed
        // context must not expose /secret.txt
    }

    // ------------------------------------------------------------------------
    // Symlink Loop Detection Tests (PyFilesystem2-inspired)
    // ------------------------------------------------------------------------

    #[test]
    fn detect_direct_symlink_loop() {
        let fs = create_backend();

        // Self-referential symlink
        let _ = fs.symlink(std::path::Path::new("/loop"), std::path::Path::new("/loop"));

        // Reading must detect the loop
        let result = fs.read(std::path::Path::new("/loop"));
        assert!(matches!(result, Err(FsError::TooManySymlinks { .. }))
            || matches!(result, Err(FsError::NotFound { .. }))
            || result.is_err(),
            "Direct symlink loop must be detected");
    }

    #[test]
    fn detect_indirect_symlink_loop() {
        let fs = create_backend();

        // Two symlinks pointing to each other: a -&gt; b, b -&gt; a
        let _ = fs.symlink(std::path::Path::new("/b"), std::path::Path::new("/a"));
        let _ = fs.symlink(std::path::Path::new("/a"), std::path::Path::new("/b"));

        // Reading either must detect the loop
        let result = fs.read(std::path::Path::new("/a"));
        assert!(matches!(result, Err(FsError::TooManySymlinks { .. }))
            || result.is_err(),
            "Indirect symlink loop must be detected");
    }

    #[test]
    fn detect_deep_symlink_chain() {
        let fs = create_backend();

        // Create a long chain of symlinks
        // link_0 -&gt; link_1 -&gt; link_2 -&gt; ... -&gt; link_N
        for i in 0..100 {
            let _ = fs.symlink(
                std::path::Path::new(&amp;format!("/link_{}", i + 1)),
                std::path::Path::new(&amp;format!("/link_{}", i))
            );
        }
        fs.write(std::path::Path::new("/link_100"), b"target").unwrap();

        // Following the chain should either succeed or fail with TooManySymlinks
        // Must NOT cause stack overflow or infinite loop
        let result = fs.read(std::path::Path::new("/link_0"));
        // Either succeeds (if backend allows deep chains) or returns error
        // Key is: it must terminate
    }

    #[test]
    fn symlink_loop_with_directories() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/dir1")).unwrap();
        fs.create_dir(std::path::Path::new("/dir2")).unwrap();

        // Create directory symlink loop
        let _ = fs.symlink(std::path::Path::new("/dir2"), std::path::Path::new("/dir1/link_to_dir2"));
        let _ = fs.symlink(std::path::Path::new("/dir1"), std::path::Path::new("/dir2/link_to_dir1"));

        // Attempting to read a file through the loop
        let result = fs.read(std::path::Path::new("/dir1/link_to_dir2/link_to_dir1/link_to_dir2/file.txt"));
        assert!(result.is_err(), "Directory symlink loop must be detected");
    }

    // ------------------------------------------------------------------------
    // Resource Exhaustion Tests
    // ------------------------------------------------------------------------

    #[test]
    fn reject_excessive_symlink_depth() {
        let fs = create_backend();

        // FUSE typically limits to 40 symlink follows
        // We should have a reasonable limit (e.g., 40-256)
        const MAX_EXPECTED_DEPTH: u32 = 256;

        // Create chain that exceeds expected limit
        for i in 0..MAX_EXPECTED_DEPTH + 10 {
            let _ = fs.symlink(
                std::path::Path::new(&amp;format!("/excessive_{}", i + 1)),
                std::path::Path::new(&amp;format!("/excessive_{}", i))
            );
        }

        // Create actual target
        fs.write(std::path::Path::new(&amp;format!("/excessive_{}", MAX_EXPECTED_DEPTH + 10)), b"data").unwrap();

        // Should reject or limit, not follow indefinitely
        let result = fs.read(std::path::Path::new("/excessive_0"));
        // Either succeeds (backend allows this depth) or errors
        // Key: must not hang or OOM
    }

    // ------------------------------------------------------------------------
    // Path Normalization Tests (FileStorage Integration)
    // ------------------------------------------------------------------------
    //
    // NOTE: Path normalization (`.`, `..`, `//`) is handled by FileStorage,
    // NOT by backends. Backends receive already-resolved, clean paths.
    // These tests verify FileStorage + backend work together correctly.
    //
    // See testing-guide.md for the full FileStorage path normalization suite.
    // Backend conformance tests should only use clean paths like "/parent/file.txt".

    #[test]
    fn path_normalization_removes_dots() {
        // Test through FileStorage, not raw backend
        let fs = anyfs::FileStorage::new(create_backend());
        fs.create_dir("/parent").unwrap();
        fs.write("/parent/file.txt", b"content").unwrap();

        // FileStorage normalizes paths before passing to backend
        assert_eq!(fs.read("/parent/./file.txt").unwrap(), b"content");
        assert_eq!(fs.read("/parent/subdir/../file.txt").unwrap(), b"content");
    }

    #[test]
    fn path_normalization_removes_double_slashes() {
        // Test through FileStorage, not raw backend
        let fs = anyfs::FileStorage::new(create_backend());
        fs.write("/file.txt", b"content").unwrap();

        // FileStorage normalizes double slashes
        assert_eq!(fs.read("//file.txt").unwrap(), b"content");
        assert_eq!(fs.read("/parent//file.txt").is_err(), true); // Parent doesn't exist
    }

    #[test]
    fn trailing_slash_handling() {
        // Test through FileStorage, not raw backend
        let fs = anyfs::FileStorage::new(create_backend());
        fs.create_dir("/mydir").unwrap();
        fs.write("/mydir/file.txt", b"content").unwrap();

        // Directory with trailing slash - FileStorage normalizes
        assert!(fs.exists("/mydir/").unwrap());

        // File with trailing slash - implementation-defined behavior
        // FileStorage may normalize or reject
    }

    // ------------------------------------------------------------------------
    // Windows-Specific Security Tests (from soft-canonicalize/strict-path)
    // ------------------------------------------------------------------------

    #[test]
    #[cfg(windows)]
    fn reject_ntfs_alternate_data_streams() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/file.txt"), b"main content").unwrap();

        // NTFS ADS: file.txt:hidden_stream
        // Attacker may try to hide data or escape paths via ADS
        let result = fs.read(std::path::Path::new("/file.txt:hidden"));
        assert!(result.is_err(), "NTFS ADS must be rejected");

        let result = fs.read(std::path::Path::new("/file.txt:$DATA"));
        assert!(result.is_err(), "NTFS ADS with $DATA must be rejected");

        let result = fs.read(std::path::Path::new("/file.txt::$DATA"));
        assert!(result.is_err(), "NTFS default stream syntax must be rejected");

        // ADS in directory path (traversal attempt)
        let result = fs.read(std::path::Path::new("/dir:ads/../secret.txt"));
        assert!(result.is_err(), "ADS in directory path must be rejected");
    }

    #[test]
    #[cfg(windows)]
    fn reject_windows_8_3_short_names() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/Program Files")).unwrap();
        fs.write(std::path::Path::new("/Program Files/secret.txt"), b"secret").unwrap();

        // 8.3 short names can be used to obfuscate paths
        // PROGRA~1 is the typical short name for "Program Files"
        // Virtual filesystems should either:
        // 1. Not support 8.3 names at all (reject)
        // 2. Resolve them consistently to the same canonical path

        // Test that we don't accidentally create different files
        let result1 = fs.exists(std::path::Path::new("/Program Files/secret.txt"));
        let result2 = fs.exists(std::path::Path::new("/PROGRA~1/secret.txt"));

        // Either both exist (resolved) or short name doesn't exist (rejected)
        // Key: they must NOT be different files
        if result1.unwrap_or(false) &amp;&amp; result2.unwrap_or(false) {
            // If both exist, they must have same content
            let content1 = fs.read(std::path::Path::new("/Program Files/secret.txt")).unwrap();
            let content2 = fs.read(std::path::Path::new("/PROGRA~1/secret.txt")).unwrap();
            assert_eq!(content1, content2, "8.3 names must resolve to same file");
        }
    }

    #[test]
    #[cfg(windows)]
    fn reject_windows_unc_traversal() {
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();

        // Extended-length path prefix traversal
        let result = fs.read(std::path::Path::new("\\\\?\\C:\\..\\..\\etc\\passwd"));
        assert!(result.is_err(), "UNC extended path traversal must be rejected");

        // Device namespace
        let result = fs.read(std::path::Path::new("\\\\.\\C:\\secret.txt"));
        assert!(result.is_err(), "Device namespace paths must be rejected");

        // UNC server path
        let result = fs.read(std::path::Path::new("\\\\server\\share\\..\\..\\secret.txt"));
        assert!(result.is_err(), "UNC server paths must be rejected");
    }

    #[test]
    #[cfg(windows)]
    fn reject_windows_reserved_names() {
        let fs = create_backend();

        // Windows reserved device names (CON, PRN, AUX, NUL, COM1-9, LPT1-9)
        // These can cause hangs or unexpected behavior
        let reserved_names = ["CON", "PRN", "AUX", "NUL", "COM1", "LPT1"];

        for name in reserved_names {
            let result = fs.write(std::path::Path::new(&amp;format!("/{}", name)), b"data");
            // Should either reject or handle safely (not hang)

            let result = fs.write(std::path::Path::new(&amp;format!("/{}.txt", name)), b"data");
            // CON.txt is also problematic on Windows
        }
    }

    #[test]
    #[cfg(windows)]
    fn reject_windows_junction_escape() {
        // Junction points are Windows' equivalent of directory symlinks
        // They can be used for sandbox escape similar to symlinks
        let fs = create_backend();
        fs.create_dir(std::path::Path::new("/sandbox")).unwrap();

        // If backend supports junctions, they must be contained like symlinks
        // The test setup would require actual junction creation capability
        // This documents the requirement even if not all backends support it
    }

    // ------------------------------------------------------------------------
    // Linux-Specific Security Tests (from soft-canonicalize/strict-path)
    // ------------------------------------------------------------------------

    #[test]
    #[cfg(target_os = "linux")]
    fn reject_proc_magic_symlinks() {
        // /proc/PID/root and similar "magic" symlinks can escape namespaces
        // Virtual filesystems wrapping real FS must not follow these
        let fs = create_backend();

        // These paths are only relevant for backends that wrap real filesystem
        // In-memory backends naturally don't have this issue

        // /proc/self/root points to the filesystem root, even in containers
        // Following it would escape chroot/container boundaries
        let result = fs.read(std::path::Path::new("/proc/self/root/etc/passwd"));
        // Either NotFound (good - path doesn't exist in VFS)
        // or handled safely (doesn't escape actual container)
    }

    #[test]
    #[cfg(target_os = "linux")]
    fn reject_dev_fd_symlinks() {
        let fs = create_backend();

        // /dev/fd/N symlinks to open file descriptors
        // Could be used to access files outside sandbox
        let result = fs.read(std::path::Path::new("/dev/fd/0"));
        // Should fail or be isolated from real /dev/fd
    }

    // ------------------------------------------------------------------------
    // Unicode Security Tests (from strict-path)
    // ------------------------------------------------------------------------

    #[test]
    fn unicode_normalization_consistency() {
        let fs = create_backend();

        // NFC vs NFD normalization: é can be:
        // - U+00E9 (precomposed, NFC)
        // - U+0065 U+0301 (decomposed, NFD: e + combining acute)
        let nfc = "/caf\u{00E9}.txt";  // precomposed
        let nfd = "/cafe\u{0301}.txt"; // decomposed

        fs.write(nfc, b"coffee").unwrap();

        // If backend normalizes, both should access same file
        // If backend doesn't normalize, second should not exist
        // Key: must NOT create two different files that look identical
        let result_nfc = fs.exists(nfc);
        let result_nfd = fs.exists(nfd);

        // Document the backend's behavior
        // Either both true (normalized) or only NFC true (strict)
    }

    #[test]
    fn reject_unicode_direction_override() {
        let fs = create_backend();

        // Right-to-Left Override (U+202E) can make paths appear different
        // "secret\u{202E}txt.exe" displays as "secretexe.txt" in some contexts
        let malicious_path = "/secret\u{202E}txt.exe";

        let result = fs.write(malicious_path, b"data");
        // Should either reject or sanitize bidirectional control characters
    }

    #[test]
    fn reject_unicode_homoglyphs() {
        let fs = create_backend();

        // Cyrillic 'а' (U+0430) looks like Latin 'a' (U+0061)
        let latin_path = "/data/file.txt";
        let cyrillic_path = "/d\u{0430}ta/file.txt"; // Cyrillic 'а'

        fs.create_dir(std::path::Path::new("/data")).unwrap();
        fs.write(latin_path, b"real content").unwrap();

        // These must NOT silently access the same file
        // Either cyrillic path is NotFound, or it's a different file
        let result = fs.read(cyrillic_path);
        if let Ok(content) = result {
            // If cyrillic path exists, it must be a distinct file
            // (not accidentally matching the latin path)
        }
    }

    #[test]
    fn reject_null_in_unicode() {
        let fs = create_backend();

        // Null can be encoded in various ways
        // UTF-8 null is just 0x00, but check overlong encodings aren't decoded
        let path_with_null = "/file\u{0000}name.txt";

        let result = fs.write(path_with_null, b"data");
        assert!(result.is_err(), "Embedded null must be rejected");
    }

    // ------------------------------------------------------------------------
    // TOCTOU Race Condition Tests (from soft-canonicalize/strict-path)
    // ------------------------------------------------------------------------

    #[test]
    fn toctou_check_then_use() {
        let fs = Arc::new(create_backend());
        fs.create_dir(std::path::Path::new("/uploads")).unwrap();

        // Simulate TOCTOU: check if path is safe, then use it
        // An attacker might change the filesystem between check and use

        let fs_checker = fs.clone();
        let fs_writer = fs.clone();

        // This test documents the requirement for atomic operations
        // or proper locking in security-critical paths

        // Thread 1: Check then write
        let checker = thread::spawn(move || {
            for i in 0..100 {
                let path = format!("/uploads/file_{}.txt", i);
                // Check
                if !fs_checker.exists(std::path::Path::new(&amp;path)).unwrap_or(true) {
                    // Use (potential race window here)
                    let _ = fs_checker.write(std::path::Path::new(&amp;path), b"data");
                }
            }
        });

        // Thread 2: Rapid file creation/deletion
        let writer = thread::spawn(move || {
            for i in 0..100 {
                let path = format!("/uploads/file_{}.txt", i);
                let _ = fs_writer.write(std::path::Path::new(&amp;path), b"attacker");
                let _ = fs_writer.remove_file(std::path::Path::new(&amp;path));
            }
        });

        checker.join().unwrap();
        writer.join().unwrap();

        // Test passes if no panic/crash occurs
        // Real protection requires atomic create-if-not-exists operations
    }

    #[test]
    fn symlink_toctou_during_resolution() {
        let fs = Arc::new(create_backend());
        fs.create_dir(std::path::Path::new("/safe")).unwrap();
        fs.write(std::path::Path::new("/safe/target.txt"), b"safe content").unwrap();
        fs.write(std::path::Path::new("/unsafe.txt"), b"unsafe content").unwrap();

        // Attacker rapidly changes symlink target during path resolution
        let fs_attacker = fs.clone();
        let fs_reader = fs.clone();

        let attacker = thread::spawn(move || {
            for _ in 0..100 {
                // Create symlink to safe target
                let _ = fs_attacker.remove_file(std::path::Path::new("/safe/link.txt"));
                let _ = fs_attacker.symlink(std::path::Path::new("/safe/target.txt"), std::path::Path::new("/safe/link.txt"));

                // Quickly change to unsafe target
                let _ = fs_attacker.remove_file(std::path::Path::new("/safe/link.txt"));
                let _ = fs_attacker.symlink(std::path::Path::new("/unsafe.txt"), std::path::Path::new("/safe/link.txt"));
            }
        });

        let reader = thread::spawn(move || {
            for _ in 0..100 {
                // Try to read through symlink
                // Must not accidentally read /unsafe.txt if sandboxed
                let _ = fs_reader.read(std::path::Path::new("/safe/link.txt"));
            }
        });

        attacker.join().unwrap();
        reader.join().unwrap();

        // For sandboxed backends: must never return content from /unsafe.txt
        // This test verifies the implementation doesn't have TOCTOU in symlink resolution
    }
}

// ============================================================================
// Thread Safety Tests
// ============================================================================

mod thread_safety {
    use super::*;

    #[test]
    fn concurrent_reads() {
        let fs = Arc::new(create_backend());
        fs.write(std::path::Path::new("/shared.txt"), b"shared content").unwrap();

        let handles: Vec&lt;_&gt; = (0..10)
            .map(|_| {
                let fs = fs.clone();
                thread::spawn(move || {
                    for _ in 0..100 {
                        let content = fs.read(std::path::Path::new("/shared.txt")).unwrap();
                        assert_eq!(content, b"shared content");
                    }
                })
            })
            .collect();

        for handle in handles {
            handle.join().unwrap();
        }
    }

    #[test]
    fn concurrent_writes_different_files() {
        let fs = Arc::new(create_backend());

        let handles: Vec&lt;_&gt; = (0..10)
            .map(|i| {
                let fs = fs.clone();
                thread::spawn(move || {
                    let path = format!("/file_{}.txt", i);
                    for j in 0..100 {
                        fs.write(std::path::Path::new(&amp;path), format!("{}:{}", i, j).as_bytes()).unwrap();
                    }
                })
            })
            .collect();

        for handle in handles {
            handle.join().unwrap();
        }

        // Verify all files exist
        for i in 0..10 {
            assert!(fs.exists(std::path::Path::new(&amp;format!("/file_{}.txt", i))).unwrap());
        }
    }

    #[test]
    fn concurrent_create_dir_all_same_path() {
        let fs = Arc::new(create_backend());

        let handles: Vec&lt;_&gt; = (0..10)
            .map(|_| {
                let fs = fs.clone();
                thread::spawn(move || {
                    // All threads try to create the same path
                    let _ = fs.create_dir_all(std::path::Path::new("/a/b/c/d"));
                })
            })
            .collect();

        for handle in handles {
            handle.join().unwrap();
        }

        // Path should exist regardless of race
        assert!(fs.exists(std::path::Path::new("/a/b/c/d")).unwrap());
    }

    #[test]
    fn read_during_write() {
        let fs = Arc::new(create_backend());
        fs.write(std::path::Path::new("/changing.txt"), b"initial").unwrap();

        let fs_writer = fs.clone();
        let writer = thread::spawn(move || {
            for i in 0..100 {
                fs_writer.write(std::path::Path::new("/changing.txt"), format!("version {}", i).as_bytes()).unwrap();
            }
        });

        let fs_reader = fs.clone();
        let reader = thread::spawn(move || {
            for _ in 0..100 {
                // Should not panic or return garbage
                let result = fs_reader.read(std::path::Path::new("/changing.txt"));
                assert!(result.is_ok());
            }
        });

        writer.join().unwrap();
        reader.join().unwrap();
    }

    #[test]
    fn metadata_consistency() {
        let fs = Arc::new(create_backend());
        fs.write(std::path::Path::new("/meta.txt"), b"content").unwrap();

        let handles: Vec&lt;_&gt; = (0..10)
            .map(|_| {
                let fs = fs.clone();
                thread::spawn(move || {
                    for _ in 0..100 {
                        let meta = fs.metadata(std::path::Path::new("/meta.txt")).unwrap();
                        // Size should be consistent
                        assert!(meta.size &gt; 0);
                    }
                })
            })
            .collect();

        for handle in handles {
            handle.join().unwrap();
        }
    }
}

// ============================================================================
// No Panic Tests (Edge Cases That Must Not Crash)
// ============================================================================

mod no_panic {
    use super::*;

    #[test]
    fn empty_path_does_not_panic() {
        let fs = create_backend();

        // These should return errors, not panic
        let _ = fs.read(std::path::Path::new(""));
        let _ = fs.write(std::path::Path::new(""), b"data");
        let _ = fs.metadata(std::path::Path::new(""));
        let _ = fs.exists(std::path::Path::new(""));
        let _ = fs.read_dir(std::path::Path::new(""));
    }

    #[test]
    fn path_with_null_does_not_panic() {
        let fs = create_backend();

        // Paths with null bytes should error or be handled gracefully
        let _ = fs.read(std::path::Path::new("/file\0name.txt"));
        let _ = fs.write(std::path::Path::new("/file\0name.txt"), b"data");
    }

    #[test]
    fn very_long_path_does_not_panic() {
        let fs = create_backend();
        let long_name = "a".repeat(10000);
        let long_path = format!("/{}", long_name);

        // Should error gracefully, not panic
        let _ = fs.write(std::path::Path::new(&amp;long_path), b"data");
        let _ = fs.read(std::path::Path::new(&amp;long_path));
    }

    #[test]
    fn very_long_filename_does_not_panic() {
        let fs = create_backend();
        let long_name = format!("/{}.txt", "x".repeat(1000));

        let _ = fs.write(std::path::Path::new(&amp;long_name), b"data");
    }

    #[test]
    fn read_after_remove_does_not_panic() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/temp.txt"), b"data").unwrap();
        fs.remove_file(std::path::Path::new("/temp.txt")).unwrap();

        // Should return NotFound, not panic
        let result = fs.read(std::path::Path::new("/temp.txt"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }

    #[test]
    fn double_remove_does_not_panic() {
        let fs = create_backend();
        fs.write(std::path::Path::new("/temp.txt"), b"data").unwrap();
        fs.remove_file(std::path::Path::new("/temp.txt")).unwrap();

        // Second remove should error, not panic
        let result = fs.remove_file(std::path::Path::new("/temp.txt"));
        assert!(matches!(result, Err(FsError::NotFound { .. })));
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="extended-test-suite-fsfull-traits"><a class="header" href="#extended-test-suite-fsfull-traits">Extended Test Suite (FsFull Traits)</a></h2>
<p>For backends implementing <code>FsFull</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod fs_full {
    use super::*;
    use anyfs_backend::{FsLink, FsPermissions, FsSync, FsStats, Permissions};

    // Only run these if the backend implements FsFull traits
    fn create_full_backend() -&gt; impl Fs + FsLink + FsPermissions + FsSync + FsStats {
        todo!("Return your FsFull backend")
    }

    // ========================================================================
    // FsLink Tests
    // ========================================================================

    mod fs_link {
        use super::*;

        #[test]
        fn create_symlink() {
            let fs = create_full_backend();
            fs.write(std::path::Path::new("/target.txt"), b"target content").unwrap();

            fs.symlink(std::path::Path::new("/target.txt"), std::path::Path::new("/link.txt")).unwrap();

            assert!(fs.exists(std::path::Path::new("/link.txt")).unwrap());
            let meta = fs.symlink_metadata(std::path::Path::new("/link.txt")).unwrap();
            assert_eq!(meta.file_type, FileType::Symlink);
        }

        #[test]
        fn read_symlink() {
            let fs = create_full_backend();
            fs.write(std::path::Path::new("/target.txt"), b"content").unwrap();
            fs.symlink(std::path::Path::new("/target.txt"), std::path::Path::new("/link.txt")).unwrap();

            let target = fs.read_link(std::path::Path::new("/link.txt")).unwrap();
            assert_eq!(target.to_string_lossy(), "/target.txt");
        }

        #[test]
        fn hard_link() {
            let fs = create_full_backend();
            fs.write(std::path::Path::new("/original.txt"), b"shared content").unwrap();

            fs.hard_link(std::path::Path::new("/original.txt"), std::path::Path::new("/hardlink.txt")).unwrap();

            // Both paths should have the same content
            assert_eq!(fs.read(std::path::Path::new("/original.txt")).unwrap(), b"shared content");
            assert_eq!(fs.read(std::path::Path::new("/hardlink.txt")).unwrap(), b"shared content");

            // Modifying one should affect the other
            fs.write(std::path::Path::new("/hardlink.txt"), b"modified").unwrap();
            assert_eq!(fs.read(std::path::Path::new("/original.txt")).unwrap(), b"modified");
        }

        #[test]
        fn symlink_metadata_vs_metadata() {
            let fs = create_full_backend();
            fs.write(std::path::Path::new("/target.txt"), b"content").unwrap();
            fs.symlink(std::path::Path::new("/target.txt"), std::path::Path::new("/link.txt")).unwrap();

            // symlink_metadata returns the symlink's metadata
            let sym_meta = fs.symlink_metadata(std::path::Path::new("/link.txt")).unwrap();
            assert_eq!(sym_meta.file_type, FileType::Symlink);

            // metadata (if it follows symlinks) returns target's metadata
            // Note: behavior depends on implementation
        }
    }

    // ========================================================================
    // FsPermissions Tests
    // ========================================================================

    mod fs_permissions {
        use super::*;

        #[test]
        fn set_permissions() {
            let fs = create_full_backend();
            fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

            fs.set_permissions(std::path::Path::new("/file.txt"), Permissions::from_mode(0o755)).unwrap();

            let meta = fs.metadata(std::path::Path::new("/file.txt")).unwrap();
            assert_eq!(meta.permissions, Some(0o755));
        }

        #[test]
        fn set_permissions_nonexistent_returns_not_found() {
            let fs = create_full_backend();

            let result = fs.set_permissions(std::path::Path::new("/nonexistent"), Permissions::from_mode(0o644));
            assert!(matches!(result, Err(FsError::NotFound { .. })));
        }
    }

    // ========================================================================
    // FsSync Tests
    // ========================================================================

    mod fs_sync {
        use super::*;

        #[test]
        fn sync_does_not_error() {
            let fs = create_full_backend();
            fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

            // sync() should complete without error
            fs.sync().unwrap();
        }

        #[test]
        fn fsync_specific_file() {
            let fs = create_full_backend();
            fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

            fs.fsync(std::path::Path::new("/file.txt")).unwrap();
        }

        #[test]
        fn fsync_nonexistent_returns_not_found() {
            let fs = create_full_backend();

            let result = fs.fsync(std::path::Path::new("/nonexistent.txt"));
            assert!(matches!(result, Err(FsError::NotFound { .. })));
        }
    }

    // ========================================================================
    // FsStats Tests
    // ========================================================================

    mod fs_stats {
        use super::*;

        #[test]
        fn statfs_returns_valid_stats() {
            let fs = create_full_backend();

            let stats = fs.statfs().unwrap();

            // Basic sanity checks
            assert!(stats.block_size &gt; 0);
            // available should not exceed total (if total is reported)
            if stats.total_bytes &gt; 0 {
                assert!(stats.available_bytes &lt;= stats.total_bytes);
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="fuse-test-suite-fsfuse-traits"><a class="header" href="#fuse-test-suite-fsfuse-traits">FUSE Test Suite (FsFuse Traits)</a></h2>
<p>For backends implementing <code>FsFuse</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod fs_fuse {
    use super::*;
    use anyfs_backend::FsInode;

    fn create_fuse_backend() -&gt; impl Fs + FsInode {
        todo!("Return your FsFuse backend")
    }

    #[test]
    fn path_to_inode_consistency() {
        let fs = create_fuse_backend();
        fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

        let inode1 = fs.path_to_inode(std::path::Path::new("/file.txt")).unwrap();
        let inode2 = fs.path_to_inode(std::path::Path::new("/file.txt")).unwrap();

        // Same path should always return same inode
        assert_eq!(inode1, inode2);
    }

    #[test]
    fn inode_to_path_roundtrip() {
        let fs = create_fuse_backend();
        fs.write(std::path::Path::new("/file.txt"), b"data").unwrap();

        let inode = fs.path_to_inode(std::path::Path::new("/file.txt")).unwrap();
        let path = fs.inode_to_path(inode).unwrap();

        assert_eq!(path.to_string_lossy(), "/file.txt");
    }

    #[test]
    fn lookup_child() {
        let fs = create_fuse_backend();
        fs.create_dir(std::path::Path::new("/parent")).unwrap();
        fs.write(std::path::Path::new("/parent/child.txt"), b"data").unwrap();

        let parent_inode = fs.path_to_inode(std::path::Path::new("/parent")).unwrap();
        let child_inode = fs.lookup(parent_inode, std::ffi::OsStr::new("child.txt")).unwrap();

        let expected_inode = fs.path_to_inode(std::path::Path::new("/parent/child.txt")).unwrap();
        assert_eq!(child_inode, expected_inode);
    }

    #[test]
    fn metadata_by_inode() {
        let fs = create_fuse_backend();
        fs.write(std::path::Path::new("/file.txt"), b"content").unwrap();

        let inode = fs.path_to_inode(std::path::Path::new("/file.txt")).unwrap();
        let meta = fs.metadata_by_inode(inode).unwrap();

        assert_eq!(meta.file_type, FileType::File);
        assert_eq!(meta.size, 7);
    }

    #[test]
    fn root_inode_is_one() {
        let fs = create_fuse_backend();

        let root_inode = fs.path_to_inode(std::path::Path::new("/")).unwrap();

        // By FUSE convention, root inode is 1
        assert_eq!(root_inode, 1);
    }

    #[test]
    fn different_files_different_inodes() {
        let fs = create_fuse_backend();
        fs.write(std::path::Path::new("/file1.txt"), b"data1").unwrap();
        fs.write(std::path::Path::new("/file2.txt"), b"data2").unwrap();

        let inode1 = fs.path_to_inode(std::path::Path::new("/file1.txt")).unwrap();
        let inode2 = fs.path_to_inode(std::path::Path::new("/file2.txt")).unwrap();

        assert_ne!(inode1, inode2);
    }

    #[test]
    fn hard_links_same_inode() {
        let fs = create_fuse_backend();
        fs.write(std::path::Path::new("/original.txt"), b"data").unwrap();
        fs.hard_link(std::path::Path::new("/original.txt"), std::path::Path::new("/link.txt")).unwrap();

        let inode1 = fs.path_to_inode(std::path::Path::new("/original.txt")).unwrap();
        let inode2 = fs.path_to_inode(std::path::Path::new("/link.txt")).unwrap();

        // Hard links must share the same inode
        assert_eq!(inode1, inode2);
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="middleware-test-suite"><a class="header" href="#middleware-test-suite">Middleware Test Suite</a></h2>
<p>For middleware implementers, verify the middleware doesn’t break the underlying backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod middleware_tests {
    use super::*;
    use anyfs::MemoryBackend;

    /// Your middleware wrapping a known-good backend.
    fn create_middleware() -&gt; MyMiddleware&lt;MemoryBackend&gt; {
        MyMiddleware::new(MemoryBackend::new())
    }

    // Run all standard Fs tests through the middleware
    // This ensures the middleware doesn't break basic functionality

    #[test]
    fn passthrough_read_write() {
        let fs = create_middleware();

        fs.write(std::path::Path::new("/test.txt"), b"data").unwrap();
        assert_eq!(fs.read(std::path::Path::new("/test.txt")).unwrap(), b"data");
    }

    #[test]
    fn passthrough_directories() {
        let fs = create_middleware();

        fs.create_dir_all(std::path::Path::new("/a/b/c")).unwrap();
        assert!(fs.exists(std::path::Path::new("/a/b/c")).unwrap());
    }

    // Add middleware-specific tests here
    // e.g., for a Quota middleware:

    #[test]
    fn quota_blocks_oversized_write() {
        let fs = QuotaMiddleware::new(MemoryBackend::new())
            .with_max_file_size(100);

        let result = fs.write(std::path::Path::new("/big.txt"), &amp;vec![0u8; 200]);
        assert!(matches!(result, Err(FsError::QuotaExceeded { .. })));
    }

    #[test]
    fn quota_allows_within_limit() {
        let fs = QuotaMiddleware::new(MemoryBackend::new())
            .with_max_file_size(100);

        fs.write(std::path::Path::new("/small.txt"), &amp;vec![0u8; 50]).unwrap();
        assert!(fs.exists(std::path::Path::new("/small.txt")).unwrap());
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="running-the-tests"><a class="header" href="#running-the-tests">Running the Tests</a></h2>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><code class="language-bash"># Run all conformance tests
cargo test --test conformance

# Run specific test module
cargo test --test conformance fs_read

# Run with output
cargo test --test conformance -- --nocapture

# Run thread safety tests with more threads
RUST_TEST_THREADS=1 cargo test --test conformance thread_safety
</code></pre>
<h3 id="ci-integration-1"><a class="header" href="#ci-integration-1">CI Integration</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml
name: Conformance Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run conformance tests
        run: cargo test --test conformance
      - name: Run thread safety tests
        run: cargo test --test conformance thread_safety -- --test-threads=1
</code></pre>
<hr>
<h2 id="test-checklist"><a class="header" href="#test-checklist">Test Checklist</a></h2>
<p>Before releasing your backend or middleware:</p>
<h3 id="core-tests-required"><a class="header" href="#core-tests-required">Core Tests (Required)</a></h3>
<ul>
<li><input disabled="" type="checkbox"> All <code>fs_read</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>fs_write</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>fs_dir</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>edge_cases</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>security</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>thread_safety</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>no_panic</code> tests pass</li>
</ul>
<h3 id="extended-tests-if-implementing-fsfull"><a class="header" href="#extended-tests-if-implementing-fsfull">Extended Tests (If Implementing FsFull)</a></h3>
<ul>
<li><input disabled="" type="checkbox"> All <code>fs_link</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>fs_permissions</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>fs_sync</code> tests pass</li>
<li><input disabled="" type="checkbox"> All <code>fs_stats</code> tests pass</li>
</ul>
<h3 id="fuse-tests-if-implementing-fsfuse"><a class="header" href="#fuse-tests-if-implementing-fsfuse">FUSE Tests (If Implementing FsFuse)</a></h3>
<ul>
<li><input disabled="" type="checkbox"> All <code>fs_fuse</code> tests pass</li>
<li><input disabled="" type="checkbox"> Root inode is 1</li>
<li><input disabled="" type="checkbox"> Hard links share inodes</li>
</ul>
<h3 id="middleware-tests-1"><a class="header" href="#middleware-tests-1">Middleware Tests</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Basic passthrough works</li>
<li><input disabled="" type="checkbox"> Middleware-specific behavior tested</li>
<li><input disabled="" type="checkbox"> Error cases handled correctly</li>
</ul>
<hr>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>This conformance test suite provides:</p>
<ol>
<li><strong>Complete coverage</strong> of all <code>Fs</code> trait operations</li>
<li><strong>Edge case testing</strong> for robustness</li>
<li><strong>Security tests</strong> learned from vulnerabilities in prior art (Apache Commons VFS, Afero, PyFilesystem2)</li>
<li><strong>Thread safety verification</strong> for concurrent access</li>
<li><strong>No-panic guarantees</strong> for invalid inputs</li>
<li><strong>Extended tests</strong> for <code>FsFull</code> and <code>FsFuse</code> traits</li>
<li><strong>Middleware testing patterns</strong></li>
</ol>
<h3 id="security-tests-cover"><a class="header" href="#security-tests-cover">Security Tests Cover:</a></h3>
<ul>
<li><strong>Path traversal attacks</strong>: URL-encoded <code>%2e%2e</code>, backslash traversal, null byte injection</li>
<li><strong>Symlink escape</strong>: Preventing sandbox escape via symlinks</li>
<li><strong>Symlink loops</strong>: Direct loops, indirect loops, deep chains</li>
<li><strong>Resource exhaustion</strong>: Limits on symlink depth</li>
<li><strong>Path canonicalization</strong>: Dot removal, double slash normalization</li>
<li><strong>Windows-specific</strong> (from <code>soft-canonicalize</code>/<code>strict-path</code>):
<ul>
<li>NTFS Alternate Data Streams</li>
<li>Windows 8.3 short names</li>
<li>UNC path traversal</li>
<li>Reserved device names</li>
<li>Junction point escapes</li>
</ul>
</li>
<li><strong>Linux-specific</strong>: Magic symlinks (<code>/proc/PID/root</code>), <code>/dev/fd</code> escapes</li>
<li><strong>Unicode</strong>: NFC/NFD normalization, RTL override, homoglyphs</li>
<li><strong>TOCTOU</strong>: Race conditions in check-then-use and symlink resolution</li>
</ul>
<p>Copy the relevant test modules, implement <code>create_backend()</code>, and run the tests. If they all pass, your backend/middleware is AnyFS-compatible.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="middleware-implementation-guide"><a class="header" href="#middleware-implementation-guide">Middleware Implementation Guide</a></h1>
<p>This document provides implementation sketches for all AnyFS middleware, verifying that each is implementable within our framework.</p>
<p><strong>Verdict: All 9 middleware are implementable.</strong> Some have interesting challenges documented below.</p>
<hr>
<h2 id="implementation-pattern"><a class="header" href="#implementation-pattern">Implementation Pattern</a></h2>
<p>All middleware follow the same pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MiddlewareName&lt;B&gt; {
    inner: B,
    state: MiddlewareState,  // Interior mutability if needed
}

impl&lt;B: Fs&gt; FsRead for MiddlewareName&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // 1. Pre-check (validate, log, check limits)
        // 2. Delegate to inner.read(path)
        // 3. Post-process (update state, transform result)
    }
}

// Implement FsWrite, FsDir similarly...
// Blanket impl for Fs is automatic
<span class="boring">}</span></code></pre>
<hr>
<h2 id="1-readonly"><a class="header" href="#1-readonly">1. ReadOnly<b></b></a></h2>
<p><strong>Complexity:</strong> Trivial
<strong>State:</strong> None
<strong>Dependencies:</strong> None</p>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReadOnly&lt;B&gt; {
    inner: B,
}

impl&lt;B&gt; ReadOnly&lt;B&gt; {
    pub fn new(inner: B) -&gt; Self {
        Self { inner }
    }
}

impl&lt;B: FsRead&gt; FsRead for ReadOnly&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read(path)  // Pass through
    }

    fn read_to_string(&amp;self, path: &amp;Path) -&gt; Result&lt;String, FsError&gt; {
        self.inner.read_to_string(path)  // Pass through
    }

    fn read_range(&amp;self, path: &amp;Path, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read_range(path, offset, len)  // Pass through
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        self.inner.exists(path)  // Pass through
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)  // Pass through
    }

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
        self.inner.open_read(path)  // Pass through
    }
}

impl&lt;B: FsWrite&gt; FsWrite for ReadOnly&lt;B&gt; {
    fn write(&amp;self, _path: &amp;Path, _data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "write" })
    }

    fn append(&amp;self, _path: &amp;Path, _data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "append" })
    }

    fn remove_file(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_file" })
    }

    fn rename(&amp;self, _from: &amp;Path, _to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "rename" })
    }

    fn copy(&amp;self, _from: &amp;Path, _to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "copy" })
    }

    fn truncate(&amp;self, _path: &amp;Path, _size: u64) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "truncate" })
    }

    fn open_write(&amp;self, _path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        Err(FsError::ReadOnly { operation: "open_write" })
    }
}

impl&lt;B: FsDir&gt; FsDir for ReadOnly&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)  // Pass through (reading)
    }

    fn create_dir(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir" })
    }

    fn create_dir_all(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "create_dir_all" })
    }

    fn remove_dir(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir" })
    }

    fn remove_dir_all(&amp;self, _path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::ReadOnly { operation: "remove_dir_all" })
    }
}
<span class="boring">}</span></code></pre>
<h3 id="verdict--trivially-implementable"><a class="header" href="#verdict--trivially-implementable">Verdict: ✅ Trivially Implementable</a></h3>
<p>No challenges. Pure delegation for reads, error return for writes.</p>
<hr>
<h2 id="2-restrictions"><a class="header" href="#2-restrictions">2. Restrictions<b></b></a></h2>
<p><strong>Complexity:</strong> Simple
<strong>State:</strong> Configuration flags only
<strong>Dependencies:</strong> None</p>
<blockquote>
<p><strong>Note:</strong> Symlink/hard-link capability is determined by trait bounds (<code>B: FsLink</code>), not middleware.
Restrictions only controls permission-related operations.</p>
</blockquote>
<h3 id="implementation-1-1"><a class="header" href="#implementation-1-1">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Restrictions&lt;B&gt; {
    inner: B,
    deny_permissions: bool,
}

pub struct RestrictionsBuilder {
    deny_permissions: bool,
}

impl RestrictionsBuilder {
    pub fn deny_permissions(mut self) -&gt; Self {
        self.deny_permissions = true;
        self
    }

    pub fn build&lt;B&gt;(self, inner: B) -&gt; Restrictions&lt;B&gt; {
        Restrictions {
            inner,
            deny_permissions: self.deny_permissions,
        }
    }
}

// FsRead, FsDir, FsLink: pure delegation (Restrictions doesn't block these)

impl&lt;B: FsLink&gt; FsLink for Restrictions&lt;B&gt; {
    fn symlink(&amp;self, target: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.symlink(target, link)  // Pure delegation
    }

    fn hard_link(&amp;self, original: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.hard_link(original, link)  // Pure delegation
    }

    fn read_link(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        self.inner.read_link(path)
    }

    fn symlink_metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.symlink_metadata(path)
    }
}

impl&lt;B: FsPermissions&gt; FsPermissions for Restrictions&lt;B&gt; {
    fn set_permissions(&amp;self, path: &amp;Path, perm: Permissions) -&gt; Result&lt;(), FsError&gt; {
        if self.deny_permissions {
            return Err(FsError::FeatureNotEnabled {
                feature: "permissions",
                operation: "set_permissions",
            });
        }
        self.inner.set_permissions(path, perm)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="verdict--trivially-implementable-1"><a class="header" href="#verdict--trivially-implementable-1">Verdict: ✅ Trivially Implementable</a></h3>
<p>Simple flag check on <code>set_permissions()</code>. Link operations delegate to inner backend.</p>
<hr>
<h2 id="3-tracing"><a class="header" href="#3-tracing">3. Tracing<b></b></a></h2>
<p><strong>Complexity:</strong> Simple
<strong>State:</strong> Configuration only
<strong>Dependencies:</strong> <code>tracing</code> crate</p>
<h3 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{instrument, info, debug, Level};

pub struct Tracing&lt;B&gt; {
    inner: B,
    target: &amp;'static str,
    level: Level,
}

impl&lt;B: FsRead&gt; FsRead for Tracing&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        let span = tracing::span!(Level::DEBUG, "fs::read", ?path);
        let _guard = span.enter();

        let result = self.inner.read(path);

        match &amp;result {
            Ok(data) =&gt; debug!(bytes = data.len(), "read succeeded"),
            Err(e) =&gt; debug!(?e, "read failed"),
        }

        result
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        let path = path.as_ref();
        let span = tracing::span!(Level::DEBUG, "fs::exists", ?path);
        let _guard = span.enter();

        let result = self.inner.exists(path);
        debug!(?result, "exists check");
        result
    }

    // ... similar for all other methods
}

// FsWrite and FsDir follow the same pattern
<span class="boring">}</span></code></pre>
<h3 id="verdict--trivially-implementable-2"><a class="header" href="#verdict--trivially-implementable-2">Verdict: ✅ Trivially Implementable</a></h3>
<p>Pure instrumentation wrapper. No state mutation, no complex logic.</p>
<hr>
<h2 id="4-ratelimit"><a class="header" href="#4-ratelimit">4. RateLimit<b></b></a></h2>
<p><strong>Complexity:</strong> Moderate
<strong>State:</strong> Counter + timestamp (requires interior mutability)
<strong>Dependencies:</strong> None (uses <code>std::time</code>)
<strong>Algorithm:</strong> Fixed-window counter (simpler than token bucket, sufficient for most use cases)</p>
<h3 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU64, AtomicU32, Ordering};
use std::time::{Duration, Instant};
use std::sync::RwLock;

pub struct RateLimit&lt;B&gt; {
    inner: B,
    max_ops: u32,
    window: Duration,
    state: RwLock&lt;RateLimitState&gt;,
}

struct RateLimitState {
    window_start: Instant,
    count: u32,
}

impl&lt;B&gt; RateLimit&lt;B&gt; {
    fn check_rate_limit(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        let mut state = self.state.write().unwrap();

        let now = Instant::now();
        if now.duration_since(state.window_start) &gt;= self.window {
            // Window expired, reset
            state.window_start = now;
            state.count = 1;
            return Ok(());
        }

        if state.count &gt;= self.max_ops {
            return Err(FsError::RateLimitExceeded {
                limit: self.max_ops,
                window_secs: self.window.as_secs(),
            });
        }

        state.count += 1;
        Ok(())
    }
}

impl&lt;B: FsRead&gt; FsRead for RateLimit&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.check_rate_limit()?;
        self.inner.read(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        self.check_rate_limit()?;
        self.inner.exists(path)
    }

    // ... all methods call check_rate_limit() first
}
<span class="boring">}</span></code></pre>
<h3 id="considerations"><a class="header" href="#considerations">Considerations</a></h3>
<ul>
<li><strong>Fixed window vs sliding window:</strong> Fixed window is simpler and sufficient for most use cases.</li>
<li><strong>Thread safety:</strong> Uses <code>RwLock</code> for state. Could optimize with atomics for lock-free path.</li>
<li><strong>What counts as an operation?</strong> Each method call counts as 1 operation.</li>
</ul>
<h3 id="verdict--implementable"><a class="header" href="#verdict--implementable">Verdict: ✅ Implementable</a></h3>
<p>Straightforward with interior mutability.</p>
<hr>
<h2 id="5-dryrun"><a class="header" href="#5-dryrun">5. DryRun<b></b></a></h2>
<p><strong>Complexity:</strong> Moderate
<strong>State:</strong> Operation log
<strong>Dependencies:</strong> None</p>
<h3 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::RwLock;

pub struct DryRun&lt;B&gt; {
    inner: B,
    operations: RwLock&lt;Vec&lt;String&gt;&gt;,
}

impl&lt;B&gt; DryRun&lt;B&gt; {
    pub fn operations(&amp;self) -&gt; Vec&lt;String&gt; {
        self.operations.read().unwrap().clone()
    }

    fn log(&amp;self, op: String) {
        self.operations.write().unwrap().push(op);
    }
}

impl&lt;B: FsRead&gt; FsRead for DryRun&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Reads execute normally - we need real state to test against
        self.inner.read(path)
    }

    // All read operations pass through unchanged
}

impl&lt;B: FsWrite&gt; FsWrite for DryRun&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.log(format!("write {} ({} bytes)", path.display(), data.len()));
        Ok(())  // Don't actually write
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.log(format!("remove_file {}", path.display()));
        Ok(())  // Don't actually remove
    }

    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        let path = path.as_ref();
        self.log(format!("open_write {}", path.display()));
        // Return a sink that discards all writes
        Ok(Box::new(std::io::sink()))
    }

    // ... similar for all write operations
}

impl&lt;B: FsDir&gt; FsDir for DryRun&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)  // Pass through
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        self.log(format!("create_dir {}", path.display()));
        Ok(())
    }

    // ... similar for all directory mutations
}
<span class="boring">}</span></code></pre>
<h3 id="semantics-clarification"><a class="header" href="#semantics-clarification">Semantics Clarification</a></h3>
<p><strong>DryRun is NOT an isolation layer.</strong> It’s for answering “what would this code do?”</p>
<ul>
<li>Reads see the <strong>real</strong> backend state (unchanged from before DryRun was applied)</li>
<li>Writes are <strong>logged but not executed</strong></li>
<li>After a dry write, reads won’t see the change (because it wasn’t written)</li>
</ul>
<p>This is intentional. For isolation, use <code>MemoryBackend::clone()</code> for snapshots.</p>
<h3 id="verdict--implementable-1"><a class="header" href="#verdict--implementable-1">Verdict: ✅ Implementable</a></h3>
<p>The semantics are clear once documented. Uses <code>std::io::sink()</code> for discarding streamed writes.</p>
<hr>
<h2 id="6-pathfilter"><a class="header" href="#6-pathfilter">6. PathFilter<b></b></a></h2>
<p><strong>Complexity:</strong> Moderate
<strong>State:</strong> Compiled glob patterns
<strong>Dependencies:</strong> <code>globset</code> crate</p>
<h3 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use globset::{Glob, GlobSet, GlobSetBuilder};

pub struct PathFilter&lt;B&gt; {
    inner: B,
    rules: Vec&lt;PathRule&gt;,
    compiled: GlobSet,  // For efficient matching
}

enum PathRule {
    Allow(String),
    Deny(String),
}

impl&lt;B&gt; PathFilter&lt;B&gt; {
    fn check_access(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path_str = path.to_string_lossy();

        for rule in &amp;self.rules {
            match rule {
                PathRule::Allow(pattern) =&gt; {
                    if glob_matches(pattern, &amp;path_str) {
                        return Ok(());
                    }
                }
                PathRule::Deny(pattern) =&gt; {
                    if glob_matches(pattern, &amp;path_str) {
                        return Err(FsError::AccessDenied {
                            path: path.to_path_buf(),
                            reason: format!("path matches deny pattern: {}", pattern),
                        });
                    }
                }
            }
        }

        // Default: deny if no rules matched
        Err(FsError::AccessDenied {
            path: path.to_path_buf(),
            reason: "no matching allow rule".to_string(),
        })
    }
}

impl&lt;B: FsRead&gt; FsRead for PathFilter&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();
        self.check_access(path)?;
        self.inner.read(path)
    }

    // ... all methods check access first
}

impl&lt;B: FsDir&gt; FsDir for PathFilter&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        let path = path.as_ref();
        self.check_access(path)?;

        let inner_iter = self.inner.read_dir(path)?;

        // Filter the iterator to exclude denied entries
        Ok(ReadDirIter::new(FilteredDirIter {
            inner: inner_iter,
            filter: self.clone(),  // Need access to rules
        }))
    }
}

// Custom iterator that filters denied entries
struct FilteredDirIter&lt;B&gt; {
    inner: ReadDirIter,
    rules: Vec&lt;PathRule&gt;,
}

impl Iterator for FilteredDirIter {
    type Item = Result&lt;DirEntry, FsError&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.inner.next()? {
                Ok(entry) =&gt; {
                    if self.is_allowed(&amp;entry.path) {
                        return Some(Ok(entry));
                    }
                    // Skip denied entries (don't reveal their existence)
                }
                Err(e) =&gt; return Some(Err(e)),
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="considerations-1"><a class="header" href="#considerations-1">Considerations</a></h3>
<ul>
<li><strong>Rule evaluation order:</strong> First match wins, consistent with firewall rules.</li>
<li><strong>Default policy:</strong> Deny if no rules match (secure by default).</li>
<li><strong>Directory listing:</strong> Filters out denied entries so their existence isn’t revealed.</li>
<li><strong>Parent directory access:</strong> If you allow <code>/workspace/**</code>, accessing <code>/workspace</code> itself needs to be allowed.</li>
</ul>
<h3 id="implementation-detail-readdiriter-filtering"><a class="header" href="#implementation-detail-readdiriter-filtering">Implementation Detail: ReadDirIter Filtering</a></h3>
<p>Our <code>ReadDirIter</code> type needs to support wrapping. Options:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Option 1: ReadDirIter is a trait object
pub struct ReadDirIter(Box&lt;dyn Iterator&lt;Item = Result&lt;DirEntry, FsError&gt;&gt; + Send&gt;);

// Option 2: ReadDirIter has a filter method
impl ReadDirIter {
    pub fn filter&lt;F&gt;(self, predicate: F) -&gt; ReadDirIter
    where
        F: Fn(&amp;DirEntry) -&gt; bool + Send + 'static
    { ... }
}
<span class="boring">}</span></code></pre>
<p><strong>Recommendation:</strong> Option 1 (trait object) is more flexible and aligns with <code>open_read</code>/<code>open_write</code> returning <code>Box&lt;dyn ...&gt;</code>.</p>
<h3 id="verdict--implementable-2"><a class="header" href="#verdict--implementable-2">Verdict: ✅ Implementable</a></h3>
<p>Requires <code>ReadDirIter</code> to be a trait object wrapper (already the case) so we can filter entries.</p>
<hr>
<h2 id="7-cache"><a class="header" href="#7-cache">7. Cache<b></b></a></h2>
<p><strong>Complexity:</strong> Moderate
<strong>State:</strong> LRU cache with entries
<strong>Dependencies:</strong> <code>lru</code> crate (or custom implementation)</p>
<h3 id="implementation-6"><a class="header" href="#implementation-6">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use lru::LruCache;
use std::sync::RwLock;
use std::time::{Duration, Instant};

pub struct Cache&lt;B&gt; {
    inner: B,
    cache: RwLock&lt;LruCache&lt;PathBuf, CacheEntry&gt;&gt;,
    max_entry_size: usize,
    ttl: Duration,
}

struct CacheEntry {
    data: Vec&lt;u8&gt;,
    metadata: Metadata,
    inserted_at: Instant,
}

impl&lt;B: FsRead&gt; FsRead for Cache&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();

        // Check cache
        {
            let cache = self.cache.read().unwrap();
            if let Some(entry) = cache.peek(path) {
                if entry.inserted_at.elapsed() &lt; self.ttl {
                    return Ok(entry.data.clone());
                }
            }
        }

        // Cache miss - fetch from backend
        let data = self.inner.read(path)?;

        // Store in cache if not too large
        if data.len() &lt;= self.max_entry_size {
            let metadata = self.inner.metadata(path)?;
            let mut cache = self.cache.write().unwrap();
            cache.put(path.to_path_buf(), CacheEntry {
                data: data.clone(),
                metadata,
                inserted_at: Instant::now(),
            });
        }

        Ok(data)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = path.as_ref();

        // Check cache for metadata
        {
            let cache = self.cache.read().unwrap();
            if let Some(entry) = cache.peek(path) {
                if entry.inserted_at.elapsed() &lt; self.ttl {
                    return Ok(entry.metadata.clone());
                }
            }
        }

        // Fetch from backend
        self.inner.metadata(path)
    }

    fn open_read(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, FsError&gt; {
        // DO NOT CACHE - streams are for large files
        self.inner.open_read(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        // Could cache this too, or derive from metadata cache
        let path = path.as_ref();
        {
            let cache = self.cache.read().unwrap();
            if let Some(entry) = cache.peek(path) {
                if entry.inserted_at.elapsed() &lt; self.ttl {
                    return Ok(true);  // If in cache, it exists
                }
            }
        }
        self.inner.exists(path)
    }
}

impl&lt;B: FsWrite&gt; FsWrite for Cache&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        let result = self.inner.write(path, data)?;

        // Invalidate cache entry
        let mut cache = self.cache.write().unwrap();
        cache.pop(path);

        Ok(result)
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        let result = self.inner.remove_file(path)?;

        // Invalidate cache entry
        let mut cache = self.cache.write().unwrap();
        cache.pop(path);

        Ok(result)
    }

    // ... all mutations invalidate cache
}
<span class="boring">}</span></code></pre>
<h3 id="what-gets-cached"><a class="header" href="#what-gets-cached">What Gets Cached</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Cached?</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>read()</code></td><td>Yes</td><td>Small files benefit from caching</td></tr>
<tr><td><code>read_to_string()</code></td><td>Yes</td><td>Same as read</td></tr>
<tr><td><code>read_range()</code></td><td>Maybe</td><td>Could cache full file, serve ranges from cache</td></tr>
<tr><td><code>metadata()</code></td><td>Yes</td><td>Frequently accessed</td></tr>
<tr><td><code>exists()</code></td><td>Derived</td><td>Can derive from metadata cache</td></tr>
<tr><td><code>open_read()</code></td><td><strong>No</strong></td><td>Streams are for large files that shouldn’t be cached</td></tr>
<tr><td><code>read_dir()</code></td><td>Maybe</td><td>Directory listings change frequently</td></tr>
</tbody>
</table>
</div>
<h3 id="verdict--implementable-3"><a class="header" href="#verdict--implementable-3">Verdict: ✅ Implementable</a></h3>
<p>Standard LRU cache pattern. Key decision: don’t cache <code>open_read()</code> streams.</p>
<hr>
<h2 id="8-quota"><a class="header" href="#8-quota">8. Quota<b></b></a></h2>
<p><strong>Complexity:</strong> High
<strong>State:</strong> Usage counters (requires accurate tracking)
<strong>Dependencies:</strong> None</p>
<h3 id="the-challenge"><a class="header" href="#the-challenge">The Challenge</a></h3>
<p>Quota must track:</p>
<ul>
<li>Total bytes used</li>
<li>Total file count</li>
<li>Total directory count</li>
<li>Per-directory entry count (optional)</li>
<li>Maximum path depth (optional)</li>
</ul>
<p>The tricky part: <strong>streaming writes via <code>open_write()</code></strong>. We must track bytes as they’re written, not just when the operation completes.</p>
<h3 id="implementation-7"><a class="header" href="#implementation-7">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, RwLock};
use std::io::Write;

pub struct Quota&lt;B&gt; {
    inner: B,
    config: QuotaConfig,
    usage: Arc&lt;RwLock&lt;QuotaUsage&gt;&gt;,
}

struct QuotaConfig {
    max_total_size: Option&lt;u64&gt;,
    max_file_size: Option&lt;u64&gt;,
    max_node_count: Option&lt;u64&gt;,
    max_dir_entries: Option&lt;u64&gt;,  // Max entries per directory
    max_path_depth: Option&lt;usize&gt;,
}

/// Current usage statistics.
#[derive(Debug, Clone, Default)]
pub struct Usage {
    pub total_size: u64,
    pub file_count: u64,
    pub dir_count: u64,
}

/// Configured limits.
#[derive(Debug, Clone)]
pub struct Limits {
    pub max_total_size: Option&lt;u64&gt;,
    pub max_file_size: Option&lt;u64&gt;,
    pub max_node_count: Option&lt;u64&gt;,
    pub max_dir_entries: Option&lt;u64&gt;,
    pub max_path_depth: Option&lt;usize&gt;,
}

/// Remaining capacity.
#[derive(Debug, Clone)]
pub struct Remaining {
    pub bytes: Option&lt;u64&gt;,
    pub nodes: Option&lt;u64&gt;,
    pub can_write: bool,
}

struct QuotaUsage {
    total_size: u64,
    file_count: u64,
    dir_count: u64,
}

impl&lt;B&gt; Quota&lt;B&gt; {
    /// Get current usage statistics.
    pub fn usage(&amp;self) -&gt; Usage {
        let u = self.usage.read().unwrap();
        Usage {
            total_size: u.total_size,
            file_count: u.file_count,
            dir_count: u.dir_count,
        }
    }

    /// Get configured limits.
    pub fn limits(&amp;self) -&gt; Limits {
        Limits {
            max_total_size: self.config.max_total_size,
            max_file_size: self.config.max_file_size,
            max_node_count: self.config.max_node_count,
            max_dir_entries: self.config.max_dir_entries,
            max_path_depth: self.config.max_path_depth,
        }
    }

    /// Get remaining capacity.
    pub fn remaining(&amp;self) -&gt; Remaining {
        let u = self.usage.read().unwrap();
        let bytes = self.config.max_total_size.map(|max| max.saturating_sub(u.total_size));
        let nodes = self.config.max_node_count.map(|max| max.saturating_sub(u.file_count + u.dir_count));
        Remaining {
            bytes,
            nodes,
            can_write: bytes.map(|b| b &gt; 0).unwrap_or(true),
        }
    }
}
```impl&lt;B: Fs&gt; Quota&lt;B&gt; {
    pub fn new(inner: B, config: QuotaConfig) -&gt; Result&lt;Self, FsError&gt; {
        // IMPORTANT: Scan backend to initialize usage counters
        let usage = Self::scan_usage(&amp;inner)?;

        Ok(Self {
            inner,
            config,
            usage: Arc::new(RwLock::new(usage)),
        })
    }

    fn scan_usage(backend: &amp;B) -&gt; Result&lt;QuotaUsage, FsError&gt; {
        let mut usage = QuotaUsage::default();
        Self::scan_dir(backend, Path::new("/"), &amp;mut usage)?;
        Ok(usage)
    }

    fn scan_dir(backend: &amp;B, path: &amp;Path, usage: &amp;mut QuotaUsage) -&gt; Result&lt;(), FsError&gt; {
        for entry in backend.read_dir(path)? {
            let entry = entry?;
            let meta = backend.metadata(&amp;entry.path)?;

            if meta.is_file {
                usage.file_count += 1;
                usage.total_size += meta.size;
            } else if meta.is_dir {
                usage.dir_count += 1;
                Self::scan_dir(backend, &amp;entry.path, usage)?;
            }
        }
        Ok(())
    }

    fn check_size_limit(&amp;self, additional_bytes: u64) -&gt; Result&lt;(), FsError&gt; {
        let usage = self.usage.read().unwrap();

        if let Some(max) = self.config.max_total_size {
            if usage.total_size + additional_bytes &gt; max {
                return Err(FsError::QuotaExceeded {
                    limit: max,
                    requested: additional_bytes,
                    usage: usage.total_size,
                });
            }
        }

        Ok(())
    }

    fn check_node_limit(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        if let Some(max) = self.config.max_node_count {
            let usage = self.usage.read().unwrap();
            if usage.file_count + usage.dir_count &gt;= max {
                return Err(FsError::QuotaExceeded {
                    limit: max,
                    requested: 1,
                    usage: usage.file_count + usage.dir_count,
                });
            }
        }
        Ok(())
    }

    fn check_dir_entries(&amp;self, parent: &amp;Path) -&gt; Result&lt;(), FsError&gt;
    where B: FsDir {
        if let Some(max) = self.config.max_dir_entries {
            // Count entries in parent directory
            let count = self.inner.read_dir(parent)?
                .filter(|e| e.is_ok())
                .count() as u64;
            if count &gt;= max {
                return Err(FsError::QuotaExceeded {
                    limit: max,
                    requested: 1,
                    usage: count,
                });
            }
        }
        Ok(())
    }

    fn check_path_depth(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        if let Some(max) = self.config.max_path_depth {
            let depth = path.components().count();
            if depth &gt; max {
                return Err(FsError::QuotaExceeded {
                    limit: max as u64,
                    requested: depth as u64,
                    usage: depth as u64,
                });
            }
        }
        Ok(())
    }
}

impl&lt;B: FsWrite + FsRead + FsDir&gt; FsWrite for Quota&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();
        let new_size = data.len() as u64;

        // Check path depth limit
        self.check_path_depth(path)?;

        // Check per-file limit
        if let Some(max) = self.config.max_file_size {
            if new_size &gt; max {
                return Err(FsError::FileSizeExceeded {
                    path: path.to_path_buf(),
                    size: new_size,
                    limit: max,
                });
            }
        }

        // Get old size (if file exists)
        let old_size = self.inner.metadata(path)
            .map(|m| m.size)
            .unwrap_or(0);

        // If creating a new file, check node count and dir entries
        let is_new_file = old_size == 0;
        if is_new_file {
            self.check_node_limit()?;
            if let Some(parent) = path.parent() {
                self.check_dir_entries(parent)?;
            }
        }

        let size_delta = new_size as i64 - old_size as i64;

        if size_delta &gt; 0 {
            self.check_size_limit(size_delta as u64)?;
        }

        // Perform write
        self.inner.write(path, data)?;

        // Update usage
        let mut usage = self.usage.write().unwrap();
        usage.total_size = (usage.total_size as i64 + size_delta) as u64;
        if is_new_file {
            usage.file_count += 1;
        }

        Ok(())
    }

    fn open_write(&amp;self, path: &amp;Path) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, FsError&gt; {
        let path = path.as_ref().to_path_buf();

        // Get the underlying writer
        let inner_writer = self.inner.open_write(&amp;path)?;

        // Wrap in a counting writer
        Ok(Box::new(QuotaWriter {
            inner: inner_writer,
            path,
            bytes_written: 0,
            usage: Arc::clone(&amp;self.usage),
            max_file_size: self.config.max_file_size,
            max_total_size: self.config.max_total_size,
        }))
    }
}

/// Wrapper that counts bytes and enforces quota on streaming writes
struct QuotaWriter {
    inner: Box&lt;dyn Write + Send&gt;,
    path: PathBuf,
    bytes_written: u64,
    usage: Arc&lt;RwLock&lt;QuotaUsage&gt;&gt;,
    max_file_size: Option&lt;u64&gt;,
    max_total_size: Option&lt;u64&gt;,
}

impl Write for QuotaWriter {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; std::io::Result&lt;usize&gt; {
        let additional = buf.len() as u64;

        // Check per-file limit
        if let Some(max) = self.max_file_size {
            if self.bytes_written + additional &gt; max {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    "file size limit exceeded"
                ));
            }
        }

        // Check total size limit
        if let Some(max) = self.max_total_size {
            let usage = self.usage.read().unwrap();
            if usage.total_size + additional &gt; max {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    "quota exceeded"
                ));
            }
        }

        // Write to inner
        let written = self.inner.write(buf)?;

        // Update counters
        self.bytes_written += written as u64;
        let mut usage = self.usage.write().unwrap();
        usage.total_size += written as u64;

        Ok(written)
    }

    fn flush(&amp;mut self) -&gt; std::io::Result&lt;()&gt; {
        self.inner.flush()
    }
}

impl Drop for QuotaWriter {
    fn drop(&amp;mut self) {
        // If we need to track "committed" vs "in-progress" writes,
        // this is where we'd finalize the accounting
    }
}

impl&lt;B: FsDir + FsRead&gt; FsDir for Quota&lt;B&gt; {
    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        // Check path depth
        self.check_path_depth(path)?;

        // Check node count
        self.check_node_limit()?;

        // Check parent directory entries
        if let Some(parent) = path.parent() {
            self.check_dir_entries(parent)?;
        }

        // Create directory
        self.inner.create_dir(path)?;

        // Update usage
        let mut usage = self.usage.write().unwrap();
        usage.dir_count += 1;

        Ok(())
    }

    // create_dir_all, remove_dir, etc. delegate similarly
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="challenges-and-solutions"><a class="header" href="#challenges-and-solutions">Challenges and Solutions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Challenge</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td>Initial usage unknown</td><td>Scan backend on construction</td></tr>
<tr><td>Streaming writes</td><td><code>QuotaWriter</code> wrapper counts bytes</td></tr>
<tr><td>Concurrent writes</td><td><code>RwLock</code> on usage counters</td></tr>
<tr><td>File replacement</td><td>Calculate delta (new_size - old_size)</td></tr>
<tr><td>New file detection</td><td>Check <code>exists()</code> before write</td></tr>
<tr><td>Accurate accounting</td><td>Update counters after successful operations</td></tr>
<tr><td>Node count limit</td><td>Check before creating files/directories</td></tr>
<tr><td>Dir entries limit</td><td>Count parent entries before creating child</td></tr>
<tr><td>Path depth limit</td><td>Count path components on create</td></tr>
</tbody>
</table>
</div>
<h3 id="edge-cases"><a class="header" href="#edge-cases">Edge Cases</a></h3>
<ol>
<li><strong>Partial write failure:</strong> If <code>inner.write()</code> fails, don’t update counters.</li>
<li><strong>Streaming write failure:</strong> <code>QuotaWriter</code> updates optimistically; on error, may need rollback.</li>
<li><strong>Rename:</strong> Doesn’t change total size.</li>
<li><strong>Copy:</strong> Adds destination size.</li>
<li><strong>Append:</strong> Adds appended bytes only.</li>
</ol>
<h3 id="verdict--implementable-4"><a class="header" href="#verdict--implementable-4">Verdict: ✅ Implementable</a></h3>
<p>The most complex middleware, but well-understood patterns. The <code>QuotaWriter</code> wrapper is the key insight.</p>
<hr>
<h2 id="9-overlayb1-b2"><a class="header" href="#9-overlayb1-b2">9. Overlay&lt;B1, B2&gt;</a></h2>
<p><strong>Complexity:</strong> High
<strong>State:</strong> Two backends + whiteout tracking
<strong>Dependencies:</strong> None</p>
<h3 id="overlay-semantics-docker-style"><a class="header" href="#overlay-semantics-docker-style">Overlay Semantics (Docker-style)</a></h3>
<ul>
<li><strong>Lower layer (base):</strong> Read-only source</li>
<li><strong>Upper layer:</strong> Writable overlay</li>
<li><strong>Whiteouts:</strong> Files named <code>.wh.&lt;filename&gt;</code> mark deletions</li>
<li><strong>Opaque directories:</strong> <code>.wh..wh..opq</code> hides entire lower directory</li>
</ul>
<h3 id="implementation-8"><a class="header" href="#implementation-8">Implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Overlay&lt;Lower, Upper&gt; {
    lower: Lower,
    upper: Upper,
}

impl&lt;Lower, Upper&gt; Overlay&lt;Lower, Upper&gt; {
    const WHITEOUT_PREFIX: &amp;'static str = ".wh.";
    const OPAQUE_MARKER: &amp;'static str = ".wh..wh..opq";

    fn whiteout_path(path: &amp;Path) -&gt; PathBuf {
        let parent = path.parent().unwrap_or(Path::new("/"));
        let name = path.file_name().unwrap_or_default();
        parent.join(format!("{}{}", Self::WHITEOUT_PREFIX, name.to_string_lossy()))
    }

    fn is_whiteout(name: &amp;str) -&gt; bool {
        name.starts_with(Self::WHITEOUT_PREFIX)
    }

    fn original_name(whiteout_name: &amp;str) -&gt; &amp;str {
        &amp;whiteout_name[Self::WHITEOUT_PREFIX.len()..]
    }
}

impl&lt;Lower: FsRead, Upper: FsRead&gt; FsRead for Overlay&lt;Lower, Upper&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = path.as_ref();

        // Check if whiteout exists in upper
        let whiteout = Self::whiteout_path(path);
        if self.upper.exists(&amp;whiteout).unwrap_or(false) {
            return Err(FsError::NotFound { path: path.to_path_buf() });
        }

        // Try upper first
        match self.upper.read(path) {
            Ok(data) =&gt; return Ok(data),
            Err(FsError::NotFound { .. }) =&gt; {}
            Err(e) =&gt; return Err(e),
        }

        // Fall back to lower
        self.lower.read(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; Result&lt;bool, FsError&gt; {
        let path = path.as_ref();

        // Check whiteout first
        let whiteout = Self::whiteout_path(path);
        if self.upper.exists(&amp;whiteout).unwrap_or(false) {
            return Ok(false);  // Whited out = doesn't exist
        }

        // Check upper, then lower
        if self.upper.exists(path).unwrap_or(false) {
            return Ok(true);
        }

        self.lower.exists(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = path.as_ref();

        // Check whiteout
        let whiteout = Self::whiteout_path(path);
        if self.upper.exists(&amp;whiteout).unwrap_or(false) {
            return Err(FsError::NotFound { path: path.to_path_buf() });
        }

        // Upper first, then lower
        match self.upper.metadata(path) {
            Ok(meta) =&gt; return Ok(meta),
            Err(FsError::NotFound { .. }) =&gt; {}
            Err(e) =&gt; return Err(e),
        }

        self.lower.metadata(path)
    }
}

impl&lt;Lower: FsRead, Upper: Fs&gt; FsWrite for Overlay&lt;Lower, Upper&gt; {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();

        // Remove whiteout if it exists
        let whiteout = Self::whiteout_path(path);
        let _ = self.upper.remove_file(&amp;whiteout);  // Ignore if doesn't exist

        // Write to upper
        self.upper.write(path, data)
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();

        // Try to remove from upper
        let _ = self.upper.remove_file(path);

        // If file exists in lower, create whiteout
        if self.lower.exists(path).unwrap_or(false) {
            let whiteout = Self::whiteout_path(path);
            self.upper.write(&amp;whiteout, b"")?;  // Create whiteout marker
        }

        Ok(())
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let from = from.as_ref();
        let to = to.as_ref();

        // Copy-on-write: read from overlay, write to upper, whiteout original
        let data = self.read(from)?;
        self.write(to, &amp;data)?;
        self.remove_file(from)?;

        Ok(())
    }
}

impl&lt;Lower: FsRead + FsDir, Upper: Fs&gt; FsDir for Overlay&lt;Lower, Upper&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        let path = path.as_ref();

        // Check for opaque marker
        let opaque_marker = path.join(Self::OPAQUE_MARKER);
        let is_opaque = self.upper.exists(&amp;opaque_marker).unwrap_or(false);

        // Get entries from upper
        let mut entries: HashMap&lt;String, DirEntry&gt; = HashMap::new();
        let mut whiteouts: HashSet&lt;String&gt; = HashSet::new();

        if let Ok(upper_iter) = self.upper.read_dir(path) {
            for entry in upper_iter {
                let entry = entry?;
                let name = entry.name.clone();

                if Self::is_whiteout(&amp;name) {
                    whiteouts.insert(Self::original_name(&amp;name).to_string());
                } else if name != Self::OPAQUE_MARKER {
                    entries.insert(name, entry);
                }
            }
        }

        // Merge lower entries (unless opaque)
        if !is_opaque {
            if let Ok(lower_iter) = self.lower.read_dir(path) {
                for entry in lower_iter {
                    let entry = entry?;
                    let name = entry.name.clone();

                    // Skip if already in upper or whited out
                    if !entries.contains_key(&amp;name) &amp;&amp; !whiteouts.contains(&amp;name) {
                        entries.insert(name, entry);
                    }
                }
            }
        }

        // Convert to iterator
        let entries_vec: Vec&lt;_&gt; = entries.into_values().map(Ok).collect();
        Ok(ReadDirIter::from_vec(entries_vec))
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();

        // Remove whiteout if exists
        let whiteout = Self::whiteout_path(path);
        let _ = self.upper.remove_file(&amp;whiteout);

        self.upper.create_dir(path)
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = path.as_ref();

        // Try to remove from upper
        let _ = self.upper.remove_dir(path);

        // If exists in lower, create whiteout
        if self.lower.exists(path).unwrap_or(false) {
            let whiteout = Self::whiteout_path(path);
            self.upper.write(&amp;whiteout, b"")?;
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Whiteout</strong></td><td><code>.wh.&lt;name&gt;</code> file in upper marks deletion of <code>&lt;name&gt;</code> from lower</td></tr>
<tr><td><strong>Opaque</strong></td><td><code>.wh..wh..opq</code> file in a directory hides all lower entries</td></tr>
<tr><td><strong>Copy-on-write</strong></td><td>First write copies from lower to upper, then modifies</td></tr>
<tr><td><strong>Merge</strong></td><td><code>read_dir()</code> combines both layers, respecting whiteouts</td></tr>
</tbody>
</table>
</div>
<h3 id="challenges"><a class="header" href="#challenges">Challenges</a></h3>
<ol>
<li><strong>Whiteout storage:</strong> Whiteouts are regular files - backend doesn’t need special support.</li>
<li><strong>Directory listing merge:</strong> Must be memory-buffered to remove duplicates and whiteouts.</li>
<li><strong>Rename:</strong> Implemented as copy + delete (standard CoW pattern).</li>
<li><strong>Symlinks in lower:</strong> Need to handle carefully - symlink targets might point to lower layer.</li>
</ol>
<h3 id="readdiriter-consideration"><a class="header" href="#readdiriter-consideration">ReadDirIter Consideration</a></h3>
<p>For Overlay, we need to buffer the merged directory listing. This means <code>ReadDirIter</code> must support construction from a <code>Vec</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ReadDirIter {
    pub fn from_vec(entries: Vec&lt;Result&lt;DirEntry, FsError&gt;&gt;) -&gt; Self {
        Self(Box::new(entries.into_iter()))
    }
}
<span class="boring">}</span></code></pre>
<h3 id="verdict--implementable-5"><a class="header" href="#verdict--implementable-5">Verdict: ✅ Implementable</a></h3>
<p>The most complex middleware, but uses well-established patterns from OverlayFS. Key insight: whiteouts are just marker files, no special backend support needed.</p>
<hr>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Middleware</th><th>Complexity</th><th>Key Implementation Insight</th></tr>
</thead>
<tbody>
<tr><td>ReadOnly</td><td>Trivial</td><td>Block all writes</td></tr>
<tr><td>Restrictions</td><td>Simple</td><td>Flag checks</td></tr>
<tr><td>Tracing</td><td>Simple</td><td>Wrap operations in spans</td></tr>
<tr><td>RateLimit</td><td>Moderate</td><td>Atomic counter + time window</td></tr>
<tr><td>DryRun</td><td>Moderate</td><td>Log writes, return Ok without executing</td></tr>
<tr><td>PathFilter</td><td>Moderate</td><td>Glob matching + filtered ReadDirIter</td></tr>
<tr><td>Cache</td><td>Moderate</td><td>LRU cache, invalidate on writes</td></tr>
<tr><td>Quota</td><td>High</td><td>Usage counters + QuotaWriter wrapper</td></tr>
<tr><td>Overlay</td><td>High</td><td>Whiteout markers + merged directory listing</td></tr>
</tbody>
</table>
</div>
<h3 id="required-framework-features"><a class="header" href="#required-framework-features">Required Framework Features</a></h3>
<p>These middleware implementations assume:</p>
<ol>
<li><strong><code>ReadDirIter</code> is a trait object wrapper</strong> - allows filtering and composition</li>
<li><strong>All methods use <code>&amp;self</code></strong> - interior mutability for state</li>
<li><strong><code>FsError</code> has all necessary variants</strong> - ReadOnly, RateLimitExceeded, QuotaExceeded, AccessDenied, FeatureNotEnabled</li>
</ol>
<p>All of these are already part of our design. <strong>All middleware are implementable.</strong></p>
<hr>
<h2 id="appendix-layer-trait-implementation"><a class="header" href="#appendix-layer-trait-implementation">Appendix: Layer Trait Implementation</a></h2>
<p>Each middleware provides a corresponding Layer type for composition:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example for Quota
pub struct QuotaLayer {
    config: QuotaConfig,
}

impl QuotaLayer {
    pub fn builder() -&gt; QuotaLayerBuilder&lt;Unconfigured&gt; {
        QuotaLayerBuilder::new()
    }
}

impl&lt;B: Fs&gt; Layer&lt;B&gt; for QuotaLayer {
    type Backend = Quota&lt;B&gt;;

    fn layer(self, backend: B) -&gt; Self::Backend {
        Quota::new(backend, self.config).expect("quota initialization failed")
    }
}

// Usage:
let fs = MemoryBackend::new()
    .layer(QuotaLayer::builder()
        .max_total_size(100_000_000)
        .build());
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lessons-from-similar-projects"><a class="header" href="#lessons-from-similar-projects">Lessons from Similar Projects</a></h1>
<p><strong>Analysis of issues from <code>vfs</code> and <code>agentfs</code> to inform AnyFS design.</strong></p>
<p>This chapter documents problems encountered by similar projects and how AnyFS addresses them. These lessons are incorporated into our <a href="#implementation-plan">Implementation Plan</a> and <a href="#backend-implementers-guide">Backend Guide</a>.</p>
<hr>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Priority</th><th>Issue</th><th>AnyFS Response</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>Panics instead of errors</td><td>No-panic policy, always return <code>Result</code></td></tr>
<tr><td>2</td><td>Thread safety problems</td><td>Concurrent stress tests required</td></tr>
<tr><td>3</td><td>Inconsistent path handling</td><td>Normalize in one place, test edge cases</td></tr>
<tr><td>4</td><td>Poor error ergonomics</td><td><code>FsError</code> with context fields</td></tr>
<tr><td>5</td><td>Missing documentation</td><td>Performance &amp; thread safety docs required</td></tr>
<tr><td>6</td><td>Platform issues</td><td>Cross-platform CI pipeline</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-thread-safety-issues"><a class="header" href="#1-thread-safety-issues">1. Thread Safety Issues</a></h2>
<h3 id="what-happened"><a class="header" href="#what-happened">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/72">#72</a></td><td>RwLock panic in production</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/47">#47</a></td><td><code>create_dir_all</code> races with itself</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Insufficient synchronization in concurrent access patterns.</p>
<h3 id="anyfs-response"><a class="header" href="#anyfs-response">AnyFS Response</a></h3>
<ul>
<li><strong>Test concurrent operations explicitly</strong> - stress test with multiple threads</li>
<li><strong>Document thread safety guarantees</strong> per backend</li>
<li><strong><code>Fs: Send</code></strong> bound is intentional</li>
<li><strong><code>MemoryBackend</code> uses <code>Arc&lt;RwLock&lt;...&gt;&gt;</code></strong> for interior mutability</li>
</ul>
<p><strong>Required tests:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_concurrent_create_dir_all() {
    let backend = Arc::new(RwLock::new(create_backend()));
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        let backend = backend.clone();
        std::thread::spawn(move || {
            let mut backend = backend.write().unwrap();
            let _ = backend.create_dir_all(std::path::Path::new("/a/b/c/d"));
        })
    }).collect();
    for handle in handles {
        handle.join().unwrap();
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="2-panics-instead-of-errors"><a class="header" href="#2-panics-instead-of-errors">2. Panics Instead of Errors</a></h2>
<h3 id="what-happened-1"><a class="header" href="#what-happened-1">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/8">#8</a></td><td>AltrootFS panics when file doesn’t exist</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/23">#23</a></td><td>Unhandled edge cases cause panics</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/68">#68</a></td><td>MemoryFS panics in WebAssembly</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Using <code>.unwrap()</code> or <code>.expect()</code> on fallible operations.</p>
<h3 id="anyfs-response-1"><a class="header" href="#anyfs-response-1">AnyFS Response</a></h3>
<p><strong>No-panic policy:</strong> Never use <code>.unwrap()</code> or <code>.expect()</code> in library code.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - will panic
let entry = self.entries.get(&amp;path).unwrap();

// GOOD - returns error
let entry = self.entries.get(&amp;path)
    .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;
<span class="boring">}</span></code></pre>
<p><strong>Edge cases that must return errors (not panic):</strong></p>
<ul>
<li>File doesn’t exist</li>
<li>Directory doesn’t exist</li>
<li>Path is empty string</li>
<li>Invalid UTF-8 in path</li>
<li>Parent directory missing</li>
<li>Type mismatch (file vs directory)</li>
<li>Concurrent access conflicts</li>
</ul>
<hr>
<h2 id="3-path-handling-inconsistencies"><a class="header" href="#3-path-handling-inconsistencies">3. Path Handling Inconsistencies</a></h2>
<h3 id="what-happened-2"><a class="header" href="#what-happened-2">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/24">#24</a></td><td>Inconsistent path definition across backends</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/42">#42</a></td><td>Path join doesn’t behave Unix-like</td></tr>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/22">#22</a></td><td>Non-UTF-8 path support questions</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Each backend implemented path handling differently.</p>
<h3 id="anyfs-response-2"><a class="header" href="#anyfs-response-2">AnyFS Response</a></h3>
<ul>
<li><strong>Normalize paths in ONE place</strong> (FileStorage resolver for virtual backends; <code>SelfResolving</code> backends delegate to the OS)</li>
<li><strong>Consistent semantics:</strong> always absolute, always <code>/</code> separator</li>
<li><strong>Use <code>&amp;Path</code> in core traits</strong> for object safety; provide <code>impl AsRef&lt;Path&gt;</code> at the ergonomic layer (FileStorage/FsExt)</li>
</ul>
<p><strong>Required conformance tests:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Expected Output</th></tr>
</thead>
<tbody>
<tr><td><code>/foo/../bar</code></td><td><code>/bar</code></td></tr>
<tr><td><code>/foo/./bar</code></td><td><code>/foo/bar</code></td></tr>
<tr><td><code>//double//slash</code></td><td><code>/double/slash</code></td></tr>
<tr><td><code>/</code></td><td><code>/</code></td></tr>
<tr><td>`` (empty)</td><td>Error</td></tr>
<tr><td><code>/foo/bar/</code></td><td><code>/foo/bar</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="4-static-lifetime-requirements"><a class="header" href="#4-static-lifetime-requirements">4. Static Lifetime Requirements</a></h2>
<h3 id="what-happened-3"><a class="header" href="#what-happened-3">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/66">#66</a></td><td>Why does filesystem require <code>'static</code>?</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Design decision that confused users and limited flexibility.</p>
<h3 id="anyfs-response-3"><a class="header" href="#anyfs-response-3">AnyFS Response</a></h3>
<ul>
<li><strong>Avoid <code>'static</code> bounds</strong> unless necessary</li>
<li><strong>Our design:</strong> <code>Fs: Send</code> (not <code>'static</code>)</li>
<li><strong>Document why bounds exist</strong> when needed</li>
</ul>
<hr>
<h2 id="5-missing-symlink-support"><a class="header" href="#5-missing-symlink-support">5. Missing Symlink Support</a></h2>
<h3 id="what-happened-4"><a class="header" href="#what-happened-4">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/81">#81</a></td><td>Symlink support missing entirely</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Symlinks are complex and were deferred indefinitely.</p>
<h3 id="anyfs-response-4"><a class="header" href="#anyfs-response-4">AnyFS Response</a></h3>
<ul>
<li><strong>Symlinks supported via <code>FsLink</code> trait</strong> - backends that implement <code>FsLink</code> support symlinks</li>
<li><strong>Compile-time capability</strong> - no <code>FsLink</code> impl = no symlinks (won’t compile)</li>
<li><strong>Bound resolution depth</strong> (default: 40 hops)</li>
<li><strong><code>strict-path</code> prevents symlink escapes</strong> in <code>VRootFsBackend</code></li>
</ul>
<hr>
<h2 id="6-error-type-ergonomics"><a class="header" href="#6-error-type-ergonomics">6. Error Type Ergonomics</a></h2>
<h3 id="what-happened-5"><a class="header" href="#what-happened-5">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/33">#33</a></td><td>Error type hard to match programmatically</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Error enum wasn’t designed for pattern matching.</p>
<h3 id="anyfs-response-5"><a class="header" href="#anyfs-response-5">AnyFS Response</a></h3>
<p><code>FsError</code> includes context and is easy to match:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum FsError {
    #[error("not found: {path}")]
    NotFound { path: PathBuf },

    #[error("{operation}: already exists: {path}")]
    AlreadyExists { path: PathBuf, operation: &amp;'static str },

    #[error("quota exceeded: limit {limit}, requested {requested}, usage {usage}")]
    QuotaExceeded { limit: u64, requested: u64, usage: u64 },

    #[error("feature not enabled: {feature} ({operation})")]
    FeatureNotEnabled { feature: &amp;'static str, operation: &amp;'static str },

    #[error("permission denied: {path} ({operation})")]
    PermissionDenied { path: PathBuf, operation: &amp;'static str },

    // ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="7-seek--write-operations"><a class="header" href="#7-seek--write-operations">7. Seek + Write Operations</a></h2>
<h3 id="what-happened-6"><a class="header" href="#what-happened-6">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/35">#35</a></td><td>Missing file positioning features</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Initial API was too simple.</p>
<h3 id="anyfs-response-6"><a class="header" href="#anyfs-response-6">AnyFS Response</a></h3>
<ul>
<li><strong>Streaming I/O:</strong> <code>open_read</code>/<code>open_write</code> return <code>Box&lt;dyn Read/Write + Send&gt;</code></li>
<li><strong>Seek support varies by backend</strong> - document which support it</li>
<li><strong>Consider future:</strong> <code>open_read_seek</code> variant or capability query</li>
</ul>
<hr>
<h2 id="8-read-only-filesystem-request"><a class="header" href="#8-read-only-filesystem-request">8. Read-Only Filesystem Request</a></h2>
<h3 id="what-happened-7"><a class="header" href="#what-happened-7">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>vfs</td><td><a href="https://github.com/manuel-woelker/rust-vfs/issues/58">#58</a></td><td>Request for immutable filesystem</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> No built-in way to enforce read-only access.</p>
<h3 id="anyfs-response-7"><a class="header" href="#anyfs-response-7">AnyFS Response</a></h3>
<p><strong>Already solved:</strong> <code>ReadOnly&lt;B&gt;</code> middleware blocks all writes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let readonly_fs = FileStorage::new(
    ReadOnly::new(SqliteBackend::open("archive.db")?)
);
// All write operations return FsError::ReadOnly
<span class="boring">}</span></code></pre>
<p>This validates our middleware approach.</p>
<hr>
<h2 id="9-performance-issues"><a class="header" href="#9-performance-issues">9. Performance Issues</a></h2>
<h3 id="what-happened-8"><a class="header" href="#what-happened-8">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/130">#130</a></td><td>File deletion is slow</td></tr>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/135">#135</a></td><td>Benchmark hangs</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> SQLite operations not optimized, FUSE overhead.</p>
<h3 id="anyfs-response-8"><a class="header" href="#anyfs-response-8">AnyFS Response</a></h3>
<ul>
<li><strong>Batch operations</strong> where possible in <code>SqliteBackend</code></li>
<li><strong>Use transactions</strong> for multi-file operations</li>
<li><strong>Document performance characteristics</strong> per backend</li>
<li><strong>Keep mounting optional</strong> - core AnyFS stays a library; mount concerns are behind feature flags (<code>fuse</code>, <code>winfsp</code>)</li>
</ul>
<p><strong>Documentation requirement:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Performance Characteristics
///
/// | Operation | Complexity | Notes |
/// |-----------|------------|-------|
/// | `read` | O(1) | Single DB query |
/// | `write` | O(n) | n = data size |
/// | `remove_dir_all` | O(n) | n = descendants |
pub struct SqliteBackend { ... }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="10-signal-handling--shutdown"><a class="header" href="#10-signal-handling--shutdown">10. Signal Handling / Shutdown</a></h2>
<h3 id="what-happened-9"><a class="header" href="#what-happened-9">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/129">#129</a></td><td>Doesn’t shutdown on SIGTERM</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> FUSE mount cleanup issues.</p>
<h3 id="anyfs-response-9"><a class="header" href="#anyfs-response-9">AnyFS Response</a></h3>
<ul>
<li><strong>Core stays a library</strong> - daemon/mount shutdown concerns are behind feature flags</li>
<li><strong>Ensure <code>Drop</code> implementations clean up properly</strong></li>
<li><strong><code>SqliteBackend</code> flushes on drop</strong></li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for SqliteBackend {
    fn drop(&amp;mut self) {
        if let Err(e) = self.sync() {
            eprintln!("Warning: failed to sync on drop: {}", e);
        }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="11-platform-compatibility"><a class="header" href="#11-platform-compatibility">11. Platform Compatibility</a></h2>
<h3 id="what-happened-10"><a class="header" href="#what-happened-10">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/132">#132</a></td><td>FUSE-T support (macOS)</td></tr>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/138">#138</a></td><td>virtio-fs support</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Platform-specific FUSE variants.</p>
<h3 id="anyfs-response-10"><a class="header" href="#anyfs-response-10">AnyFS Response</a></h3>
<ul>
<li><strong>We isolate this</strong> - core traits stay pure; FUSE lives behind feature flags (<code>fuse</code>, <code>winfsp</code>) in the <code>anyfs</code> crate</li>
<li><strong>Cross-platform by design</strong> - Memory and SQLite work everywhere</li>
<li><strong><code>VRootFsBackend</code> uses <code>strict-path</code></strong> which handles Windows/Unix</li>
</ul>
<p><strong>CI requirement:</strong></p>
<pre><code class="language-yaml">strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
</code></pre>
<hr>
<h2 id="12-multiple-sessions--concurrent-access"><a class="header" href="#12-multiple-sessions--concurrent-access">12. Multiple Sessions / Concurrent Access</a></h2>
<h3 id="what-happened-11"><a class="header" href="#what-happened-11">What Happened</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Issue</th><th>Problem</th></tr>
</thead>
<tbody>
<tr><td>agentfs</td><td><a href="https://github.com/tursodatabase/agentfs/issues/126">#126</a></td><td>Can’t have multiple sessions on same filesystem</td></tr>
</tbody>
</table>
</div>
<p><strong>Root cause:</strong> Locking/concurrency design.</p>
<h3 id="anyfs-response-11"><a class="header" href="#anyfs-response-11">AnyFS Response</a></h3>
<ul>
<li><strong><code>SqliteBackend</code> uses WAL mode</strong> for concurrent readers</li>
<li><strong>Document concurrency model</strong> per backend</li>
<li><strong><code>MemoryBackend</code> uses <code>Arc&lt;RwLock&lt;...&gt;&gt;</code></strong> for sharing</li>
</ul>
<hr>
<h2 id="issues-we-already-avoid"><a class="header" href="#issues-we-already-avoid">Issues We Already Avoid</a></h2>
<p>Our design decisions already prevent these problems:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Problem in Others</th><th>AnyFS Solution</th></tr>
</thead>
<tbody>
<tr><td>No middleware pattern</td><td>Tower-style composable middleware</td></tr>
<tr><td>No quota enforcement</td><td><code>Quota&lt;B&gt;</code> middleware</td></tr>
<tr><td>No read-only mode</td><td><code>ReadOnly&lt;B&gt;</code> middleware</td></tr>
<tr><td>Symlink complexity</td><td><code>FsLink</code> trait (compile-time)</td></tr>
<tr><td>Path escape via symlinks</td><td><code>strict-path</code> canonicalization</td></tr>
<tr><td>FUSE complexity</td><td>Isolated behind feature flags</td></tr>
<tr><td>SQLite-only</td><td>Multiple backends</td></tr>
<tr><td>Monolithic features</td><td>Composable middleware</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://github.com/manuel-woelker/rust-vfs/issues">rust-vfs Issues</a></li>
<li><a href="https://github.com/tursodatabase/agentfs/issues">agentfs Issues</a></li>
<li><a href="#implementation-plan">Implementation Plan</a> - incorporates these lessons</li>
<li><a href="#backend-implementers-guide">Backend Guide</a> - implementation requirements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="open-questions--future-considerations"><a class="header" href="#open-questions--future-considerations">Open Questions &amp; Future Considerations</a></h1>
<p><strong>Status:</strong> Resolved (future considerations tracked)
<strong>Last Updated:</strong> 2025-12-28</p>
<hr>
<p>This document captures previously open questions and design considerations. Unless explicitly marked as future, the items below are resolved.</p>
<blockquote>
<p><strong>Note:</strong> Final decisions live in the Architecture Decision Records.</p>
</blockquote>
<hr>
<h2 id="symlink-security-following-vs-creating"><a class="header" href="#symlink-security-following-vs-creating">Symlink Security: Following vs Creating</a></h2>
<p><strong>Status:</strong> Resolved</p>
<h3 id="decision"><a class="header" href="#decision">Decision</a></h3>
<ul>
<li>Symlink support is a backend capability (via <code>FsLink</code>).</li>
<li><code>FileStorage</code> resolves paths via pluggable <code>PathResolver</code> for non-<code>SelfResolving</code> backends.</li>
<li>The default <code>IterativeResolver</code> follows symlinks when <code>FsLink</code> is available. Custom resolvers can implement different behaviors.</li>
<li><code>SelfResolving</code> backends delegate to the OS. <code>strict-path</code> prevents escapes.</li>
</ul>
<h3 id="implications"><a class="header" href="#implications">Implications</a></h3>
<ul>
<li>If you need symlink-free semantics, use a backend that does not implement <code>FsLink</code> or block symlink creation and ensure no preexisting symlinks exist.</li>
<li><code>Restrictions</code> only controls creation, not resolution.</li>
</ul>
<h3 id="why"><a class="header" href="#why">Why</a></h3>
<ul>
<li>Virtual backends have no host filesystem to escape to; symlink resolution stays inside the virtual structure.</li>
<li>OS-backed backends cannot reliably disable symlink following without TOCTOU risks or platform-specific hacks.</li>
</ul>
<hr>
<h2 id="virtual-vs-real-backends-path-resolution"><a class="header" href="#virtual-vs-real-backends-path-resolution">Virtual vs Real Backends: Path Resolution</a></h2>
<p><strong>Status:</strong> Resolved (see also ADR-033 for PathResolver)</p>
<p><strong>Question:</strong> Should path resolution logic be different for virtual backends (memory, SQLite) vs filesystem-based backends (StdFsBackend, VRootFsBackend)?</p>
<p><strong>Resolution:</strong> <code>FileStorage</code> handles path resolution via pluggable <code>PathResolver</code> trait for non-<code>SelfResolving</code> backends. <code>SelfResolving</code> backends delegate to the OS, so FileStorage does not pre-resolve paths for them.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Type</th><th>Path Resolution</th><th>Symlink Handling</th></tr>
</thead>
<tbody>
<tr><td>MemoryBackend</td><td><strong>PathResolver</strong> (default: IterativeResolver)</td><td>Resolver follows symlinks</td></tr>
<tr><td>SqliteBackend</td><td><strong>PathResolver</strong> (default: IterativeResolver)</td><td>Resolver follows symlinks</td></tr>
<tr><td>VRootFsBackend</td><td><strong>OS</strong> (implements <code>SelfResolving</code>)</td><td>OS follows symlinks (strict-path prevents escapes)</td></tr>
</tbody>
</table>
</div>
<p><strong>Key design decisions:</strong></p>
<ol>
<li>Backends that wrap a real filesystem implement the <code>SelfResolving</code> marker trait to tell <code>FileStorage</code> to skip resolution:</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SelfResolving for VRootFsBackend {}
<span class="boring">}</span></code></pre>
<ol start="2">
<li>Path resolution is pluggable via <code>PathResolver</code> trait (ADR-033). Built-in resolvers include:
<ul>
<li><code>IterativeResolver</code> - default symlink-aware resolution (when backend implements <code>FsLink</code>)</li>
<li><code>NoOpResolver</code> - for <code>SelfResolving</code> backends</li>
<li><code>CachingResolver</code> - LRU cache wrapper around another resolver</li>
</ul>
</li>
</ol>
<hr>
<h2 id="compression-and-encryption"><a class="header" href="#compression-and-encryption">Compression and Encryption</a></h2>
<p><strong>Question:</strong> Does the current design allow backends to compress/decompress or encrypt/decrypt files transparently?</p>
<p><strong>Answer:</strong> Yes. The backend receives the data and stores it however it wants. A backend could:</p>
<ul>
<li>Compress data before writing to SQLite</li>
<li>Encrypt blobs with a user-provided key</li>
<li>Use a remote object store with encryption at rest</li>
</ul>
<p>This is an implementation detail of the backend, not visible to the <code>FileStorage</code> API.</p>
<hr>
<h2 id="hooks-and-callbacks"><a class="header" href="#hooks-and-callbacks">Hooks and Callbacks</a></h2>
<p><strong>Question:</strong> Should AnyFS support hooks or callbacks for file operations (e.g., audit logging, validation)?</p>
<p><strong>Considerations:</strong></p>
<ul>
<li>AgentFS (see comparison below) provides audit logging as a core feature</li>
<li>Hooks add complexity but enable powerful use cases</li>
<li>Could be implemented as a middleware pattern around FileStorage</li>
</ul>
<p><strong>Resolution:</strong> Implemented via <code>Tracing</code> middleware. Users can also wrap <code>FileStorage</code> or backends for custom hooks.</p>
<hr>
<h2 id="agentfs-comparison"><a class="header" href="#agentfs-comparison">AgentFS Comparison</a></h2>
<p><strong>Note:</strong> There are two projects named “AgentFS”:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="https://github.com/tursodatabase/agentfs">tursodatabase/agentfs</a></td><td>Full AI agent runtime (Turso/libSQL)</td></tr>
<tr><td><a href="https://github.com/cryptopatrick/agentfs">cryptopatrick/agentfs</a></td><td>Related to <a href="https://lib.rs/crates/agentdb">AgentDB</a> abstraction layer</td></tr>
</tbody>
</table>
</div>
<p>This section focuses on <strong>Turso’s AgentFS</strong>, which has a <a href="https://github.com/tursodatabase/agentfs/blob/main/SPEC.md">published spec</a>.</p>
<h3 id="what-agentfs-provides"><a class="header" href="#what-agentfs-provides">What AgentFS Provides</a></h3>
<p>AgentFS is an <strong>agent runtime</strong>, not just a filesystem. It provides three integrated subsystems:</p>
<ol>
<li><strong>Virtual Filesystem</strong> - POSIX-like, inode-based, chunked storage in SQLite</li>
<li><strong>Key-Value Store</strong> - Agent state and context storage</li>
<li><strong>Tool Call Audit Trail</strong> - Records all tool invocations for debugging/compliance</li>
</ol>
<h3 id="anyfs-vs-agentfs-different-abstractions"><a class="header" href="#anyfs-vs-agentfs-different-abstractions">AnyFS vs AgentFS: Different Abstractions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>AnyFS</th><th>AgentFS</th></tr>
</thead>
<tbody>
<tr><td><strong>Scope</strong></td><td>Filesystem abstraction</td><td>Agent runtime</td></tr>
<tr><td><strong>Filesystem</strong></td><td>Full</td><td>Full</td></tr>
<tr><td><strong>Key-Value store</strong></td><td>Not our domain</td><td>Included</td></tr>
<tr><td><strong>Tool auditing</strong></td><td><code>Tracing</code> middleware</td><td>Built-in</td></tr>
<tr><td><strong>Backends</strong></td><td>Memory, SQLite, VRootFs, custom</td><td>SQLite only (spec)</td></tr>
<tr><td><strong>Middleware</strong></td><td>Composable layers</td><td>Monolithic</td></tr>
</tbody>
</table>
</div>
<h3 id="relationship-options"><a class="header" href="#relationship-options">Relationship Options</a></h3>
<p><strong>AnyFS could be used BY AgentFS:</strong></p>
<ul>
<li>AgentFS could implement its filesystem portion using <code>Fs</code> trait</li>
<li>Our middleware (Quota, PathFilter, etc.) would work with their system</li>
</ul>
<p><strong>AgentFS-compatible backend for AnyFS:</strong></p>
<ul>
<li>Someone could implement <code>Fs</code> using AgentFS’s SQLite schema</li>
<li>Would enable interop with AgentFS tooling</li>
</ul>
<p><strong>What we should NOT do:</strong></p>
<ul>
<li>Add KV store to <code>Fs</code> (different abstraction, scope creep)</li>
<li>Add tool call auditing to core trait (that’s what <code>Tracing</code> middleware is for)</li>
</ul>
<h3 id="when-to-use-which"><a class="header" href="#when-to-use-which">When to Use Which</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Need just filesystem operations</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need composable middleware (quota, sandboxing)</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need full agent runtime (FS + KV + auditing)</td><td><strong>AgentFS</strong></td></tr>
<tr><td>Need multiple backend types (memory, real FS)</td><td><strong>AnyFS</strong></td></tr>
<tr><td>Need AgentFS-compatible SQLite format</td><td><strong>AgentFS</strong> or custom AnyFS backend</td></tr>
</tbody>
</table>
</div>
<h3 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h3>
<p>AnyFS and AgentFS solve different problems at different layers:</p>
<ul>
<li><strong>AnyFS</strong> = filesystem abstraction with composable middleware</li>
<li><strong>AgentFS</strong> = complete agent runtime with integrated storage</li>
</ul>
<p>They can complement each other rather than compete.</p>
<hr>
<h2 id="vfs-crate-comparison"><a class="header" href="#vfs-crate-comparison">VFS Crate Comparison</a></h2>
<p>The <a href="https://docs.rs/vfs/">vfs crate</a> provides virtual filesystem abstractions with:</p>
<ul>
<li><strong>PhysicalFS</strong>: Host filesystem access</li>
<li><strong>MemoryFS</strong>: In-memory storage</li>
<li><strong>AltrootFS</strong>: Rooted filesystem (similar to our VRootFsBackend)</li>
<li><strong>OverlayFS</strong>: Layered filesystem</li>
<li><strong>EmbeddedFS</strong>: Compile resources into binary</li>
</ul>
<p><strong>Similarities with AnyFS:</strong></p>
<ul>
<li>Trait-based abstraction over storage</li>
<li>Memory and physical filesystem backends</li>
</ul>
<p><strong>Differences:</strong></p>
<ul>
<li>VFS doesn’t have SQLite backend</li>
<li>VFS doesn’t have policy/quota layer</li>
<li>AnyFS focuses on isolation and limits</li>
</ul>
<p><strong>Why not use VFS?</strong> VFS is a good library, but AnyFS’s design goals differ:</p>
<ol>
<li>We want SQLite as a first-class backend</li>
<li>We need quota/limit enforcement</li>
<li>We want feature whitelisting (least privilege)</li>
</ol>
<hr>
<h2 id="fuse-mount-support"><a class="header" href="#fuse-mount-support">FUSE Mount Support</a></h2>
<p><strong>Status:</strong> Designed - Part of <code>anyfs</code> crate (feature flags: <code>fuse</code>, <code>winfsp</code>)</p>
<p><strong>What is FUSE?</strong>
<a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE (Filesystem in Userspace)</a> allows implementing filesystems in userspace rather than kernel code. It enables:</p>
<ul>
<li>Mounting any backend as a real filesystem</li>
<li>Using standard Unix tools (ls, cat, etc.) on AnyFS containers</li>
<li>Integration with existing workflows</li>
</ul>
<p><strong>Resolution:</strong> Part of <code>anyfs</code> crate with feature flags:</p>
<ul>
<li>Linux: FUSE (native) - <code>fuse</code> feature</li>
<li>macOS: macFUSE - <code>fuse</code> feature</li>
<li>Windows: WinFsp - <code>winfsp</code> feature</li>
</ul>
<p>See <a href="#cross-platform-virtual-drive-mounting">Cross-Platform Mounting</a> for full details.</p>
<hr>
<h2 id="type-system-protection-for-cross-container-operations"><a class="header" href="#type-system-protection-for-cross-container-operations">Type-System Protection for Cross-Container Operations</a></h2>
<p><strong>Status:</strong> Resolved - Implemented via marker types</p>
<p><strong>Question:</strong> Should we use the type system to prevent accidentally mixing data between containers?</p>
<p><strong>Resolution:</strong> Implemented via <code>FileStorage&lt;B, R, M&gt;</code> where <code>M</code> is a marker type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Sandbox;
struct UserData;

let sandbox: FileStorage&lt;_, _, Sandbox&gt; = FileStorage::new(MemoryBackend::new());
let userdata: FileStorage&lt;_, _, UserData&gt; = FileStorage::new(SqliteBackend::open("data.db")?);

fn process_sandbox(fs: &amp;FileStorage&lt;impl Fs, IterativeResolver, Sandbox&gt;) { /* only accepts Sandbox */ }

process_sandbox(&amp;sandbox);   // OK
process_sandbox(&amp;userdata);  // Compile error!
<span class="boring">}</span></code></pre>
<p>See <a href="#filestorageb-r-m-anyfs">FileStorage&lt;B, R, M&gt;</a> for details.</p>
<hr>
<h2 id="naming-considerations"><a class="header" href="#naming-considerations">Naming Considerations</a></h2>
<p>Based on review feedback, the following naming concerns were raised:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Current Name</th><th>Concern</th><th>Alternatives Considered</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-traits</code></td><td>“traits” is vague</td><td><code>anyfs-backend</code> (adopted)</td></tr>
<tr><td><code>anyfs-container</code></td><td>Could imply Docker</td><td>Merged into <code>anyfs</code> (adopted)</td></tr>
<tr><td><code>anyfs</code></td><td>Sounds like Hebrew “ani efes” (I am zero)</td><td><code>anyfs</code> retained for simplicity</td></tr>
</tbody>
</table>
</div>
<p><strong>Decision:</strong> Renamed <code>anyfs-traits</code> to <code>anyfs-backend</code>. Merged <code>anyfs-container</code> into <code>anyfs</code>.</p>
<hr>
<h2 id="posix-behavior"><a class="header" href="#posix-behavior">POSIX Behavior</a></h2>
<p><strong>Question:</strong> How POSIX-compatible should AnyFS be?</p>
<p><strong>Answer:</strong> AnyFS is <strong>not</strong> a POSIX emulator. We use <code>std::fs</code>-like naming and semantics for familiarity, but we don’t aim for full POSIX compliance. Specific differences:</p>
<ul>
<li>Symlink-aware path resolution (FileStorage walks the virtual structure using <code>metadata()</code> and <code>read_link()</code>)</li>
<li>No file descriptors or open file handles in the basic API</li>
<li>Simplified permissions model</li>
<li>No device files, FIFOs, or sockets</li>
</ul>
<hr>
<h2 id="async-support"><a class="header" href="#async-support">Async Support</a></h2>
<p><strong>Question:</strong> Should <code>Fs</code> traits be async?</p>
<p><strong>Decision:</strong> Sync-first, async-ready (see ADR-010).</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All built-in backends are naturally synchronous (rusqlite, std::fs, memory)</li>
<li>No runtime dependency (tokio/async-std) required</li>
<li>Rust 1.75+ has native async traits, so adding later is low-cost</li>
</ul>
<p><strong>Async-ready design:</strong></p>
<ul>
<li>Traits require <code>Send</code> - compatible with async executors</li>
<li>Return types are <code>Result&lt;T, FsError&gt;</code> - works with async</li>
<li>No hidden blocking state</li>
<li>Methods are stateless per-call</li>
</ul>
<p><strong>Future path:</strong> When needed (e.g., S3/network backends), add parallel <code>AsyncFs</code> trait:</p>
<ul>
<li>Separate trait, not replacing <code>Fs</code></li>
<li>Blanket impl possible via <code>spawn_blocking</code></li>
<li>No breaking changes to existing sync API</li>
</ul>
<hr>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Topic</th><th>Decision</th></tr>
</thead>
<tbody>
<tr><td>Symlink security</td><td>Backend-defined (<code>FsLink</code>); VRootFsBackend uses <code>strict-path</code> for containment</td></tr>
<tr><td>Path resolution</td><td>FileStorage (symlink-aware); VRootFs = OS via <code>SelfResolving</code></td></tr>
<tr><td>Compression/encryption</td><td>Backend responsibility</td></tr>
<tr><td>Hooks/callbacks</td><td><code>Tracing</code> middleware</td></tr>
<tr><td>FUSE mount</td><td>Part of <code>anyfs</code> crate (<code>fuse</code>, <code>winfsp</code> feature flags)</td></tr>
<tr><td>Type-system protection</td><td><code>FileStorage&lt;B, R, M&gt;</code> marker types</td></tr>
<tr><td>POSIX compatibility</td><td>Not a goal</td></tr>
<tr><td><code>truncate</code></td><td>Added to <code>FsWrite</code></td></tr>
<tr><td><code>sync</code> / <code>fsync</code></td><td>Added to <code>FsSync</code></td></tr>
<tr><td>Async support</td><td>Sync-first, async-ready (ADR-010)</td></tr>
<tr><td>Layer trait</td><td>Tower-style composition (ADR-011)</td></tr>
<tr><td>Logging</td><td>Tracing with tracing ecosystem (ADR-012)</td></tr>
<tr><td>Extension methods</td><td><code>FsExt</code> (ADR-013)</td></tr>
<tr><td>Zero-copy bytes</td><td>Optional <code>bytes</code> feature (ADR-014)</td></tr>
<tr><td>Error context</td><td>Contextual <code>FsError</code> (ADR-015)</td></tr>
<tr><td>BackendStack builder</td><td>Fluent API via <code>.layer()</code></td></tr>
<tr><td>Path-based access control</td><td><code>PathFilter</code> middleware (ADR-016)</td></tr>
<tr><td>Read-only mode</td><td><code>ReadOnly</code> middleware (ADR-017)</td></tr>
<tr><td>Rate limiting</td><td><code>RateLimit</code> middleware (ADR-018)</td></tr>
<tr><td>Dry-run testing</td><td><code>DryRun</code> middleware (ADR-019)</td></tr>
<tr><td>Read caching</td><td><code>Cache</code> middleware (ADR-020)</td></tr>
<tr><td>Union filesystem</td><td><code>Overlay</code> middleware (ADR-021)</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-review-rust-community-alignment"><a class="header" href="#design-review-rust-community-alignment">Design Review: Rust Community Alignment</a></h1>
<p>This document critically reviews AnyFS design decisions against Rust community expectations and best practices. The goal is to identify potential friction points before implementation.</p>
<hr>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Issues Found</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Critical (must fix)</td><td>2</td><td>✅ Fixed</td></tr>
<tr><td>Should fix</td><td>4</td><td>🟡 In progress</td></tr>
<tr><td>Document clearly</td><td>3</td><td>🟢 Ongoing</td></tr>
<tr><td>Non-issues</td><td>5</td><td>✅ Verified</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="-critical-issues-fixed"><a class="header" href="#-critical-issues-fixed">✅ Critical Issues (Fixed)</a></h2>
<h3 id="1-fserror-missing-non_exhaustive--fixed"><a class="header" href="#1-fserror-missing-non_exhaustive--fixed">1. FsError Missing <code>#[non_exhaustive]</code> — FIXED</a></h3>
<p><strong>Problem:</strong> Our <code>FsError</code> enum doesn’t have <code>#[non_exhaustive]</code>. This is a <strong>semver hazard</strong>.</p>
<p><strong>Status:</strong> ✅ Fixed in <code>design-overview.md</code>. FsError now has <code>#[non_exhaustive]</code>, <code>thiserror::Error</code> derive, and <code>From&lt;std::io::Error&gt;</code> impl.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current (problematic)
pub enum FsError {
    NotFound { path: PathBuf },
    AlreadyExists { path: PathBuf, operation: &amp;'static str },
    // ...
}

// If we add a variant in 1.1:
pub enum FsError {
    NotFound { path: PathBuf },
    AlreadyExists { path: PathBuf, operation: &amp;'static str },
    TooManySymlinks { path: PathBuf },  // NEW - breaks exhaustive matches!
}
<span class="boring">}</span></code></pre>
<p><strong>Impact:</strong> Users with exhaustive matches will get compile errors on minor version bumps.</p>
<p><strong>Fix:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
#[derive(Debug, thiserror::Error)]
pub enum FsError {
    #[error("not found: {path}")]
    NotFound { path: PathBuf },
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Also needed:</strong></p>
<ul>
<li><code>impl std::error::Error for FsError</code></li>
<li><code>impl From&lt;std::io::Error&gt; for FsError</code></li>
<li>Consider <code>#[non_exhaustive]</code> on struct variants too</li>
</ul>
<hr>
<h3 id="2-documentation-shows-mut-self-despite-adr-023--fixed"><a class="header" href="#2-documentation-shows-mut-self-despite-adr-023--fixed">2. Documentation Shows <code>&amp;mut self</code> Despite ADR-023 — FIXED</a></h3>
<p><strong>Problem:</strong> Several code examples still show <code>&amp;mut self</code> or <code>&amp;mut impl Fs</code>.</p>
<p><strong>Status:</strong> ✅ Fixed. All examples in <code>design-overview.md</code> and <code>files-container.md</code> now use <code>&amp;self</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In design-overview.md line 346:
fn with_symlinks(fs: &amp;mut (impl Fs + FsLink)) {  // WRONG
    fs.write("/target.txt", b"content")?;
    fs.symlink("/target.txt", "/link.txt")?;
}

// Should be:
fn with_symlinks(fs: &amp;(impl Fs + FsLink)) {  // Correct
    fs.write("/target.txt", b"content")?;
    fs.symlink("/target.txt", "/link.txt")?;
}
<span class="boring">}</span></code></pre>
<p><strong>Impact:</strong> Contradicts ADR-023 (interior mutability). Confuses implementers.</p>
<p><strong>Fix:</strong> Audit all examples and ensure <code>&amp;self</code> everywhere.</p>
<hr>
<h2 id="-should-fix"><a class="header" href="#-should-fix">🟡 Should Fix</a></h2>
<h3 id="3-sync-only-design-may-limit-adoption"><a class="header" href="#3-sync-only-design-may-limit-adoption">3. Sync-Only Design May Limit Adoption</a></h3>
<p><strong>Problem:</strong> No async support. Many modern Rust projects are async-first.</p>
<p><strong>Current stance (ADR-024):</strong> Sync now, async later via parallel traits.</p>
<p><strong>Community expectation:</strong> Projects like <code>tokio</code>, <code>async-std</code> are dominant. Users may expect:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
<span class="boring">}</span></code></pre>
<p><strong>Mitigation:</strong></p>
<ol>
<li>Document clearly: “Sync-first by design, async planned”</li>
<li>Ensure <code>Send + Sync</code> bounds enable <code>spawn_blocking</code> wrapper</li>
<li>Consider shipping <code>anyfs-async</code> adapter crate early</li>
</ol>
<p><strong>Recommendation:</strong> Acceptable. Async support is a future consideration.</p>
<hr>
<h3 id="4-interior-mutability-may-surprise-users"><a class="header" href="#4-interior-mutability-may-surprise-users">4. Interior Mutability May Surprise Users</a></h3>
<p><strong>Problem:</strong> <code>&amp;self</code> for write operations is unusual in Rust.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Our design
pub trait FsWrite: Send + Sync {
    fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
}

// What users might expect (std::io::Write pattern)
pub trait FsWrite {
    fn write(&amp;mut self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Why we chose this (ADR-023):</strong></p>
<ul>
<li>Filesystems are shared resources</li>
<li>Enables concurrent access</li>
<li>Matches how <code>std::fs::write()</code> works (takes path, not mutable handle)</li>
</ul>
<p><strong>Potential friction:</strong></p>
<ul>
<li>Users may try to use <code>&amp;mut self</code> patterns</li>
<li>May conflict with borrowck mental models</li>
</ul>
<p><strong>Mitigation:</strong></p>
<ol>
<li>Document prominently with rationale</li>
<li>Show examples of concurrent usage</li>
<li>Explain: “Like std::fs, not like std::io::Write”</li>
</ol>
<p><strong>Recommendation:</strong> Keep the design, but add prominent documentation.</p>
<hr>
<h3 id="5-layer-trait-doesnt-match-tower-exactly"><a class="header" href="#5-layer-trait-doesnt-match-tower-exactly">5. Layer Trait Doesn’t Match Tower Exactly</a></h3>
<p><strong>Problem:</strong> Tower’s <code>Layer</code> trait has a different signature:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Tower's Layer
pub trait Layer&lt;S&gt; {
    type Service;
    fn layer(&amp;self, inner: S) -&gt; Self::Service;
}

// Our Layer (appears to be)
pub trait Layer&lt;B: Fs&gt; {
    type Backend: Fs;
    fn layer(self, backend: B) -&gt; Self::Backend;
}
<span class="boring">}</span></code></pre>
<p><strong>Differences:</strong></p>
<ol>
<li>Tower uses <code>&amp;self</code>, we use <code>self</code> (consumes the layer)</li>
<li>Tower calls it <code>Service</code>, we call it <code>Backend</code></li>
<li>Tower doesn’t require bounds on <code>S</code></li>
</ol>
<p><strong>Impact:</strong> Users familiar with Tower may be confused.</p>
<p><strong>Options:</strong></p>
<ol>
<li><strong>Match Tower exactly</strong> - maximum familiarity</li>
<li><strong>Keep our design</strong> - <code>self</code> consumption is arguably cleaner for our use case</li>
<li><strong>Document differences</strong> - explain why we diverge</li>
</ol>
<p><strong>Recommendation:</strong> Document the differences. Our <code>self</code> consumption prevents accidental reuse of configured layers, which is appropriate for our use case.</p>
<hr>
<h3 id="6-no-must_use-on-results"><a class="header" href="#6-no-must_use-on-results">6. No <code>#[must_use]</code> on Results</a></h3>
<p><strong>Problem:</strong> Functions returning <code>Result</code> should have <code>#[must_use]</code> to catch ignored errors.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current
fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;

// Better
#[must_use]
fn write(&amp;self, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
<span class="boring">}</span></code></pre>
<p><strong>Impact:</strong> Users might accidentally ignore errors.</p>
<p><strong>Fix:</strong> Add <code>#[must_use]</code> to all <code>Result</code>-returning methods, or use <code>#[must_use]</code> on the trait itself.</p>
<hr>
<h2 id="-document-clearly"><a class="header" href="#-document-clearly">🟢 Document Clearly</a></h2>
<h3 id="7-path-semantics-are-virtual-not-os"><a class="header" href="#7-path-semantics-are-virtual-not-os">7. Path Semantics Are Virtual, Not OS</a></h3>
<p><strong>Consideration:</strong> Our paths are virtual filesystem paths, not OS paths.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// On Windows, this works the same as on Unix:
fs.write("/documents/file.txt", data)?;  // Forward slashes always
<span class="boring">}</span></code></pre>
<p><strong>Potential confusion:</strong></p>
<ul>
<li>Windows users might expect backslashes</li>
<li>Path normalization rules may differ from OS</li>
</ul>
<p><strong>Mitigation:</strong> Document:</p>
<ul>
<li>“Paths are virtual, always use forward slashes”</li>
<li>“Path resolution is platform-independent”</li>
<li>Show examples on Windows</li>
</ul>
<hr>
<h3 id="8-fs-as-marker-trait-pattern"><a class="header" href="#8-fs-as-marker-trait-pattern">8. <code>Fs</code> as Marker Trait Pattern</a></h3>
<p><strong>Pattern:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fs: FsRead + FsWrite + FsDir {}
impl&lt;T: FsRead + FsWrite + FsDir&gt; Fs for T {}
<span class="boring">}</span></code></pre>
<p><strong>This is valid Rust</strong> but may surprise some users. They might expect:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fs {
    fn read(...);
    fn write(...);
    // etc
}
<span class="boring">}</span></code></pre>
<p><strong>Why we do it:</strong></p>
<ul>
<li>Granular traits for partial implementations</li>
<li>Middleware only needs to implement what it wraps</li>
</ul>
<p><strong>Mitigation:</strong> Document the pattern clearly with examples.</p>
<hr>
<h3 id="9-builder-pattern-requires-configuration"><a class="header" href="#9-builder-pattern-requires-configuration">9. Builder Pattern Requires Configuration</a></h3>
<p><strong>Pattern:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile - no build() on unconfigured builder
let quota = QuotaLayer::builder().build();  // Error!

// Must configure at least one limit
let quota = QuotaLayer::builder()
    .max_total_size(1_000_000)
    .build();  // OK
<span class="boring">}</span></code></pre>
<p><strong>This is intentional</strong> (ADR-022) but may surprise users expecting defaults.</p>
<p><strong>Mitigation:</strong> Clear error messages and documentation.</p>
<hr>
<h2 id="-non-issues-were-doing-it-right"><a class="header" href="#-non-issues-were-doing-it-right">✅ Non-Issues (We’re Doing It Right)</a></h2>
<h3 id="10-object-safe-path-parameters"><a class="header" href="#10-object-safe-path-parameters">10. Object-Safe Path Parameters</a></h3>
<p>✅ Core traits use <code>&amp;Path</code>; ergonomics come from <code>FileStorage</code>/<code>FsExt</code>.</p>
<h3 id="11-send--sync-requirements"><a class="header" href="#11-send--sync-requirements">11. <code>Send + Sync</code> Requirements</a></h3>
<p>✅ Standard for thread-safe abstractions. Enables use across async boundaries.</p>
<h3 id="12-feature-gated-backends"><a class="header" href="#12-feature-gated-backends">12. Feature-Gated Backends</a></h3>
<p>✅ Standard Cargo pattern. Reduces compile time for unused backends.</p>
<h3 id="13-strategic-boxing-adr-025"><a class="header" href="#13-strategic-boxing-adr-025">13. Strategic Boxing (ADR-025)</a></h3>
<p>✅ Matches Tower/Axum approach. Well-documented rationale.</p>
<h3 id="14-generic-middleware-composition"><a class="header" href="#14-generic-middleware-composition">14. Generic Middleware Composition</a></h3>
<p>✅ Zero-cost abstractions. Idiomatic Rust.</p>
<hr>
<h2 id="action-items-1"><a class="header" href="#action-items-1">Action Items</a></h2>
<h3 id="before-mvp"><a class="header" href="#before-mvp">Before MVP</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Priority</th><th>Issue</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>🔴 Critical</td><td>FsError non_exhaustive</td><td>Add <code>#[non_exhaustive]</code> and <code>thiserror</code> derive</td></tr>
<tr><td>🔴 Critical</td><td>&amp;mut in examples</td><td>Audit all examples for &amp;self consistency</td></tr>
<tr><td>🟡 Should</td><td>#[must_use]</td><td>Add to all Result-returning methods</td></tr>
<tr><td>🟢 Document</td><td>Interior mutability</td><td>Add prominent section explaining why</td></tr>
<tr><td>🟢 Document</td><td>Path semantics</td><td>Add section on virtual paths</td></tr>
</tbody>
</table>
</div>
<h3 id="should-fix"><a class="header" href="#should-fix">Should Fix</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Priority</th><th>Issue</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>🟡 Should</td><td>Async support</td><td>Ship <code>anyfs-async</code> or document workaround</td></tr>
<tr><td>🟡 Should</td><td>Layer trait docs</td><td>Document differences from Tower</td></tr>
<tr><td>🟢 Document</td><td>Marker trait pattern</td><td>Explain Fs = FsRead + FsWrite + FsDir</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="comparison-to-axums-success-factors"><a class="header" href="#comparison-to-axums-success-factors">Comparison to Axum’s Success Factors</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Factor</th><th>Axum</th><th>AnyFS</th><th>Assessment</th></tr>
</thead>
<tbody>
<tr><td>Tower integration</td><td>Native</td><td>Inspired by</td><td>🟡 Different but similar</td></tr>
<tr><td>Async support</td><td>Yes</td><td>No (planned)</td><td>🟡 Gap, but documented</td></tr>
<tr><td>Error handling</td><td>thiserror</td><td>Planned</td><td>🔴 Must add</td></tr>
<tr><td>Documentation</td><td>Excellent</td><td>In progress</td><td>🟡 Continue</td></tr>
<tr><td>Examples</td><td>Comprehensive</td><td>In progress</td><td>🟡 Continue</td></tr>
<tr><td>Ecosystem fit</td><td>tokio native</td><td>std::fs native</td><td>✅ Different target</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p><strong>Overall assessment:</strong> The design is sound and follows Rust best practices. The main gaps are:</p>
<ol>
<li><strong>Critical:</strong> <code>#[non_exhaustive]</code> on FsError (semver hazard)</li>
<li><strong>Critical:</strong> Inconsistent <code>&amp;mut</code> in examples (contradicts ADR-023)</li>
<li><strong>Important:</strong> No async yet (but documented path forward)</li>
<li><strong>Minor:</strong> Documentation gaps (being addressed)</li>
</ol>
<p>With these fixes, the design should be well-received by the Rust community.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="license"><a class="header" href="#license">License</a></h1>
<p>This project is dual-licensed to allow for open collaboration on the design while ensuring the resulting code examples can be freely used in software implementations.</p>
<hr>
<h2 id="documentation-text-and-media"><a class="header" href="#documentation-text-and-media">Documentation (Text and Media)</a></h2>
<p>The text, diagrams, and other media in this design manual are licensed under the <strong>Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)</strong> license.</p>
<p><strong>You are free to:</strong></p>
<ul>
<li><strong>Share</strong> — copy and redistribute the material in any medium or format</li>
<li><strong>Adapt</strong> — remix, transform, and build upon the material for any purpose, even commercially</li>
</ul>
<p><strong>Under the following terms:</strong></p>
<ul>
<li><strong>Attribution</strong> — You must give appropriate credit, provide a link to the license, and indicate if changes were made</li>
<li><strong>ShareAlike</strong> — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original</li>
</ul>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Full CC BY-SA 4.0 Legal Text</a></p>
<hr>
<h2 id="code-samples"><a class="header" href="#code-samples">Code Samples</a></h2>
<p>Any code snippets, examples, or software implementation details contained within this manual are dual-licensed under your choice of:</p>
<ul>
<li><strong>MIT License</strong> — <a href="https://opensource.org/licenses/MIT">Full Text</a></li>
<li><strong>Apache License 2.0</strong> — <a href="https://www.apache.org/licenses/LICENSE-2.0">Full Text</a></li>
</ul>
<p>This is the same licensing model used by the Rust ecosystem.</p>
<hr>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Content Type</th><th>License</th></tr>
</thead>
<tbody>
<tr><td>Documentation text</td><td>CC BY-SA 4.0</td></tr>
<tr><td>Diagrams and media</td><td>CC BY-SA 4.0</td></tr>
<tr><td>Code snippets</td><td>MIT OR Apache-2.0</td></tr>
<tr><td>Example implementations</td><td>MIT OR Apache-2.0</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>When attributing this work, please use:</p>
<blockquote>
<p>AnyFS Design Manual by David Krasnitsky, licensed under CC BY-SA 4.0 (documentation) and MIT/Apache-2.0 (code samples).
https://github.com/DK26/anyfs-design-manual</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
