<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AnyFS Ecosystem Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for AnyFS: pluggable virtual filesystem backends + container layer for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-788b0482.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-076f33df.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">AnyFS Ecosystem Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/vfs-design-manual" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="anyfs-ecosystem"><a class="header" href="#anyfs-ecosystem">AnyFS Ecosystem</a></h1>
<p><strong>An open standard for pluggable virtual filesystem backends in Rust.</strong></p>
<hr>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>AnyFS is an <strong>open standard</strong> that allows anyone to create custom storage backends. Whether you need to store files in a database, object store, network filesystem, or any other medium—AnyFS provides the contract and tools to make it happen.</p>
<p>The ecosystem is a three-crate design:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>VfsBackend</code> trait + core types. Backend implementers depend on this.</td></tr>
<tr><td><code>anyfs</code></td><td>Low-level execution layer for calling any <code>VfsBackend</code>. Also provides built-in backends (MemoryBackend, SqliteBackend, VRootFsBackend).</td></tr>
<tr><td><code>anyfs-container</code></td><td><code>FilesContainer&lt;B: VfsBackend&gt;</code> policy layer (limits + least-privilege feature whitelist)</td></tr>
</tbody>
</table>
</div>
<p>High-level data flow:</p>
<pre><code class="language-text">Your application
  -&gt; anyfs-container (FilesContainer: ergonomic paths + policy)
      -&gt; anyfs (executes operations on any VfsBackend)
          -&gt; any backend (built-in or custom)
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <code>strict-path</code> crate is <strong>only</strong> used by <code>VRootFsBackend</code>—a backend that wraps a real host filesystem directory. It is not part of the core AnyFS API.</p>
</blockquote>
<hr>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick example</a></h2>
<pre class="playground"><code class="language-rust">use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut container = FilesContainer::new(MemoryBackend::new());

    container.create_dir_all("/data")?;
    container.write("/data/file.txt", b"hello")?;

    Ok(())
}</code></pre>
<hr>
<h2 id="how-to-use-this-manual"><a class="header" href="#how-to-use-this-manual">How to use this manual</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Section</th><th>Audience</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Overview</td><td>Stakeholders</td><td>One-page understanding</td></tr>
<tr><td>Getting Started</td><td>Developers</td><td>Practical examples</td></tr>
<tr><td>Design &amp; Architecture</td><td>Contributors</td><td>Detailed design</td></tr>
<tr><td>Traits &amp; APIs</td><td>Backend authors</td><td>Contract and types</td></tr>
<tr><td>Implementation</td><td>Implementers</td><td>Plan + backend guide</td></tr>
<tr><td>Review</td><td>Contributors</td><td>Historical review record</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="authoritative-documents"><a class="header" href="#authoritative-documents">Authoritative documents</a></h2>
<ol>
<li><code>book/src/architecture/design-overview.md</code></li>
<li><code>book/src/architecture/adrs.md</code></li>
</ol>
<p>If something conflicts with <code>AGENTS.md</code>, treat <code>AGENTS.md</code> as authoritative.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---executive-summary"><a class="header" href="#anyfs---executive-summary">AnyFS - Executive Summary</a></h1>
<p>One-page overview for stakeholders and decision-makers.</p>
<hr>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust.</p>
<p>You get a familiar, <code>std::fs</code>-aligned API (read/write/create_dir/read_dir/etc.) while choosing where the data lives:</p>
<ul>
<li>in-memory (fast caching, testing, speed-critical applications)</li>
<li>a single SQLite database file (portable storage)</li>
<li>a contained host filesystem directory (sandboxed by VRootFsBackend)</li>
<li>or any custom backend you implement</li>
</ul>
<hr>
<h2 id="why-does-it-matter"><a class="header" href="#why-does-it-matter">Why does it matter?</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Problem</th><th>How AnyFS helps</th></tr>
</thead>
<tbody>
<tr><td>Multi-tenant isolation</td><td>One container per tenant, separate namespaces</td></tr>
<tr><td>Portability</td><td>SQLite backend: a tenant filesystem is a single <code>.db</code> file</td></tr>
<tr><td>Security</td><td>Path normalization prevents traversal attacks</td></tr>
<tr><td>Resource control</td><td>Built-in limits: max bytes, max file size, max nodes, etc.</td></tr>
<tr><td>Speed-critical storage</td><td>In-memory backend for caching or temporary storage</td></tr>
<tr><td>Custom storage</td><td>Implement your own backend for any storage medium</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="key-design-points"><a class="header" href="#key-design-points">Key design points</a></h2>
<ul>
<li>
<p><strong>Three-crate structure</strong></p>
<ul>
<li><code>anyfs-backend</code>: minimal backend contract (<code>VfsBackend</code> trait) and types</li>
<li><code>anyfs</code>: low-level execution layer for calling any <code>VfsBackend</code> (also provides built-in backends)</li>
<li><code>anyfs-container</code>: <code>FilesContainer&lt;B&gt;</code> policy layer (limits + least privilege)</li>
</ul>
</li>
<li>
<p><strong>Simple path handling</strong></p>
<ul>
<li>User APIs accept <code>impl AsRef&lt;Path&gt;</code> for ergonomics.</li>
<li>Backends receive normalized <code>&amp;str</code> paths.</li>
<li><code>strict-path</code> is only used internally by VRootFsBackend.</li>
</ul>
</li>
<li>
<p><strong>Least privilege by default</strong></p>
<ul>
<li>Advanced behavior is denied unless explicitly enabled per container:
<ul>
<li>symlinks</li>
<li>hard links</li>
<li>permission mutation</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::FilesContainer;

let mut fs = FilesContainer::new(SqliteBackend::open_or_create("tenant_123.db")?)
    .with_max_total_size(100 * 1024 * 1024);

fs.create_dir_all("/documents")?;
fs.write("/documents/hello.txt", b"Hello!")?;
let content = fs.read("/documents/hello.txt")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Design</td><td>Complete</td></tr>
<tr><td>Implementation</td><td>Not started</td></tr>
</tbody>
</table>
</div>
<hr>
<p>For details, see <code>book/src/architecture/design-overview.md</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---project-structure"><a class="header" href="#anyfs---project-structure">AnyFS - Project Structure</a></h1>
<p><strong>Status:</strong> Current
<strong>Last updated:</strong> 2025-12-23</p>
<hr>
<h2 id="repository-layout"><a class="header" href="#repository-layout">Repository Layout</a></h2>
<pre><code>anyfs-backend/             # Crate 1: core trait + types
  Cargo.toml
  src/
    lib.rs
    backend.rs
    types.rs
    error.rs

anyfs/                     # Crate 2: built-in backends (feature-gated)
  Cargo.toml
  src/
    lib.rs                 # backend implementations
    memory/                # [feature: memory] (default)
    vrootfs/               # [feature: vrootfs]
    sqlite/                # [feature: sqlite]

anyfs-container/           # Crate 3: policy layer (quotas + isolation)
  Cargo.toml
  src/
    lib.rs
    container.rs           # FilesContainer&lt;B: VfsBackend&gt;
    limits.rs              # CapacityLimits
    usage.rs               # CapacityUsage, CapacityRemaining
    error.rs               # ContainerError
</code></pre>
<hr>
<h2 id="dependency-model"><a class="header" href="#dependency-model">Dependency Model</a></h2>
<pre><code>anyfs-backend (trait + types)
    &lt;- anyfs (execution layer, calls any VfsBackend)
    &lt;- anyfs-container (wraps backends with policy)

strict-path (VirtualPath, VirtualRoot)
    &lt;- anyfs [vrootfs feature only]
</code></pre>
<p><strong>Key point:</strong> Custom backends depend only on <code>anyfs-backend</code>. The <code>anyfs</code> crate is the execution layer that can call any backend—built-in or custom. <code>strict-path</code> is only used by the <code>vrootfs</code> feature.</p>
<hr>
<h2 id="path-flow"><a class="header" href="#path-flow">Path Flow</a></h2>
<pre><code>User code:  container.read("/a/b.txt")
   -&gt; FilesContainer (policy checks, normalization)
   -&gt; backend.read(path)  # receives impl AsRef&lt;Path&gt;
</code></pre>
<p>Both layers use <code>impl AsRef&lt;Path&gt;</code> for std::fs alignment.</p>
<hr>
<h2 id="cargo-features"><a class="header" href="#cargo-features">Cargo Features</a></h2>
<p>Cargo features in <code>anyfs</code> select which built-in backends to include:</p>
<ul>
<li><code>memory</code> — In-memory storage (default)</li>
<li><code>sqlite</code> — SQLite-backed persistent storage</li>
<li><code>vrootfs</code> — Host filesystem backend (uses <code>strict-path</code> internally)</li>
</ul>
<p>The runtime feature whitelist (symlinks, hard_links, permissions) is configured per <code>FilesContainer</code> instance, not at compile time.</p>
<hr>
<h2 id="where-to-start"><a class="header" href="#where-to-start">Where To Start</a></h2>
<ul>
<li>Application usage: <code>book/src/getting-started/guide.md</code></li>
<li>Trait details: <code>book/src/traits/vfs-trait.md</code></li>
<li>Decisions and rationale: <code>book/src/architecture/adrs.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--getting-started-guide"><a class="header" href="#anyfs--getting-started-guide">AnyFS — Getting Started Guide</a></h1>
<p><strong>A practical introduction with examples</strong></p>
<hr>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
anyfs-container = "0.1"
</code></pre>
<p>By default, <code>anyfs</code> includes only the in-memory backend. For additional backends:</p>
<pre><code class="language-toml">[dependencies]
anyfs = { version = "0.1", features = ["sqlite", "vrootfs"] }
anyfs-container = "0.1"
</code></pre>
<p>Available features for <code>anyfs</code>:</p>
<ul>
<li><code>memory</code> — In-memory storage (default). Fast and isolated—useful for testing, caching, or any speed-critical application.</li>
<li><code>sqlite</code> — SQLite-backed persistent storage. Portable single-file storage.</li>
<li><code>vrootfs</code> — Host filesystem backend (uses <code>strict-path</code> internally for path containment).</li>
</ul>
<hr>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create an in-memory container
    let mut container = FilesContainer::new(MemoryBackend::new());

    // Write a file (accepts any path-like type)
    container.write("/hello.txt", b"Hello, AnyFS!")?;

    // Read it back
    let content = container.read("/hello.txt")?;
    println!("{}", String::from_utf8_lossy(&amp;content));
    // Output: Hello, AnyFS!

    Ok(())
}</code></pre>
<h3 id="persistent-storage-with-sqlite"><a class="header" href="#persistent-storage-with-sqlite">Persistent Storage with SQLite</a></h3>
<pre class="playground"><code class="language-rust">use anyfs::SqliteBackend;
use anyfs_container::FilesContainer;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create or open a SQLite-backed container
    let mut container = FilesContainer::new(
        SqliteBackend::open_or_create("my_data.db")?
    );

    // Create a directory structure
    container.create_dir_all("/documents/work")?;

    // Write some files
    container.write("/documents/work/notes.txt", b"Meeting notes for Monday")?;

    // Data persists across program runs
    Ok(())
}</code></pre>
<hr>
<h2 id="common-tasks"><a class="header" href="#common-tasks">Common Tasks</a></h2>
<h3 id="creating-directories"><a class="header" href="#creating-directories">Creating Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single directory (parent must exist)
container.create_dir("/documents")?;

// Recursive (creates parents as needed)
container.create_dir_all("/documents/projects/2024/q1")?;
<span class="boring">}</span></code></pre>
<h3 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and Writing Files</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Write (creates or overwrites)
container.write("/data.txt", b"line 1\n")?;

// Append
container.append("/data.txt", b"line 2\n")?;

// Read entire file
let content = container.read("/data.txt")?;

// Read partial (offset 0, length 6)
let partial = container.read_range("/data.txt", 0, 6)?;
<span class="boring">}</span></code></pre>
<h3 id="listing-directories"><a class="header" href="#listing-directories">Listing Directories</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in container.read_dir("/documents")? {
    match entry.file_type {
        FileType::File =&gt; {
            println!("  {} (file)", entry.name);
        }
        FileType::Directory =&gt; {
            println!("  {}/", entry.name);
        }
        FileType::Symlink =&gt; {
            println!("  {} -&gt; ...", entry.name);
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="checking-existence-and-metadata"><a class="header" href="#checking-existence-and-metadata">Checking Existence and Metadata</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if container.exists("/maybe-exists.txt")? {
    let meta = container.metadata("/maybe-exists.txt")?;
    println!("Size: {} bytes", meta.size);
    println!("Created: {:?}", meta.created);
    println!("Modified: {:?}", meta.modified);
}
<span class="boring">}</span></code></pre>
<h3 id="copying-and-moving"><a class="header" href="#copying-and-moving">Copying and Moving</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copy a file
container.copy("/original.txt", "/copy.txt")?;

// Move (rename)
container.rename("/original.txt", "/renamed.txt")?;
<span class="boring">}</span></code></pre>
<h3 id="deleting"><a class="header" href="#deleting">Deleting</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Delete a file
container.remove_file("/old-file.txt")?;

// Delete an empty directory
container.remove_dir("/empty-folder")?;

// Delete directory and all contents
container.remove_dir_all("/old-folder")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::FilesContainer;

let container = FilesContainer::new(SqliteBackend::open_or_create("data.db")?)
    // Set capacity limits
    .with_max_total_size(500 * 1024 * 1024)  // 500 MB total
    .with_max_file_size(50 * 1024 * 1024)    // 50 MB per file
    .with_max_node_count(100_000)             // 100K files/dirs
    .with_max_dir_entries(5_000)              // 5K entries per directory
    // Set depth limits
    .with_max_path_depth(32);
<span class="boring">}</span></code></pre>
<h3 id="checking-capacity"><a class="header" href="#checking-capacity">Checking Capacity</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current usage
let usage = container.usage()?;
println!("Using {} bytes", usage.total_size);
println!("Files: {}", usage.file_count);
println!("Directories: {}", usage.directory_count);

// Remaining capacity
let remaining = container.remaining()?;
if !remaining.can_write {
    println!("Storage is full!");
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<p>Symlinks, hard links, and permission mutation are <strong>disabled by default</strong>. Enable only what you need via the builder pattern (feature whitelist).</p>
<h3 id="symbolic-links"><a class="header" href="#symbolic-links">Symbolic Links</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(MemoryBackend::new())
    .with_symlinks()                     // disabled by default (least privilege)
    .with_max_symlink_resolution(40);    // optional; default: 40

// Create a symlink
container.create_dir_all("/deep/nested/dir")?;
container.symlink("/deep/nested/dir", "/shortcut")?;

// Read the target (without following)
let target = container.read_link("/shortcut")?;

// Regular operations follow symlinks when enabled
container.read_dir("/shortcut")?;  // lists /deep/nested/dir
<span class="boring">}</span></code></pre>
<h3 id="hard-links"><a class="header" href="#hard-links">Hard Links</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(MemoryBackend::new())
    .with_hard_links();              // disabled by default (least privilege)

// Create a file
container.write("/original.txt", b"content")?;

// Create a hard link (same file, different path)
container.hard_link("/original.txt", "/link.txt")?;

// Both paths refer to the same content
// Deleting one doesn't affect the other
container.remove_file("/original.txt")?;
let content = container.read("/link.txt")?;  // Still works
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="pattern-matching-on-errors"><a class="header" href="#pattern-matching-on-errors">Pattern Matching on Errors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_container::ContainerError;

match container.write("/file.txt", &amp;large_data) {
    Ok(()) =&gt; println!("Written successfully"),

    Err(ContainerError::NotFound(p)) =&gt; {
        println!("Parent directory doesn't exist: {}", p);
    }

    Err(ContainerError::FileSizeExceeded { size, limit }) =&gt; {
        println!("File too large: {} bytes (limit: {})", size, limit);
    }

    Err(ContainerError::TotalSizeExceeded { used, limit }) =&gt; {
        println!("Storage full: {} / {} bytes", used, limit);
    }

    Err(ContainerError::FeatureNotEnabled(name)) =&gt; {
        println!("Feature is disabled by default: {}", name);
    }

    Err(e) =&gt; println!("Other error: {}", e),
}
<span class="boring">}</span></code></pre>
<h3 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error</th><th>Cause</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td><code>NotFound</code></td><td>Path doesn’t exist</td><td>Check with <code>exists()</code> first, or use <code>create_dir_all</code></td></tr>
<tr><td><code>AlreadyExists</code></td><td>Creating over existing</td><td>Remove first, or check existence</td></tr>
<tr><td><code>NotADirectory</code></td><td>Operating on file as dir</td><td>Check <code>metadata().file_type</code></td></tr>
<tr><td><code>DirectoryNotEmpty</code></td><td>Removing non-empty dir</td><td>Use <code>remove_dir_all()</code> instead</td></tr>
<tr><td><code>FileSizeExceeded</code></td><td>File too large</td><td>Increase limit or split file</td></tr>
<tr><td><code>TotalSizeExceeded</code></td><td>Storage full</td><td>Delete files or increase quota</td></tr>
<tr><td><code>FeatureNotEnabled</code></td><td>Feature is disabled by policy</td><td>Enable via <code>ContainerBuilder</code> (whitelist)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="use-in-memory-backend"><a class="header" href="#use-in-memory-backend">Use In-Memory Backend</a></h3>
<p>The in-memory backend is fast and isolated. It’s useful for:</p>
<ul>
<li>Unit and integration tests</li>
<li>Caching or temporary storage</li>
<li>Speed-critical applications where persistence isn’t needed</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use anyfs::MemoryBackend;
    use anyfs_container::FilesContainer;

    fn test_container() -&gt; FilesContainer&lt;MemoryBackend&gt; {
        FilesContainer::new(MemoryBackend::new())
    }

    #[test]
    fn test_write_and_read() {
        let mut container = test_container();

        container.write("/test.txt", b"test data").unwrap();
        let content = container.read("/test.txt").unwrap();

        assert_eq!(content, b"test data");
    }

    #[test]
    fn test_directory_operations() {
        let mut container = test_container();

        container.create_dir_all("/a/b/c").unwrap();

        assert!(container.exists("/a").unwrap());
        assert!(container.exists("/a/b").unwrap());
        assert!(container.exists("/a/b/c").unwrap());
    }
}
<span class="boring">}</span></code></pre>
<h3 id="test-with-capacity-limits"><a class="header" href="#test-with-capacity-limits">Test with Capacity Limits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

#[test]
fn test_storage_limit() {
    let mut container = FilesContainer::new(MemoryBackend::new())
        .with_max_total_size(1024);  // 1 KB limit

    let big_data = vec![0u8; 2048];  // 2 KB

    let result = container.write("/big.bin", &amp;big_data);

    assert!(result.is_err());
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-handle-errors-gracefully"><a class="header" href="#1-handle-errors-gracefully">1. Handle Errors Gracefully</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::VfsBackend;
use anyfs_container::{FilesContainer, ContainerError};

fn ensure_parent_exists&lt;B: VfsBackend&gt;(
    container: &amp;mut FilesContainer&lt;B&gt;,
    path: &amp;str,
) -&gt; Result&lt;(), ContainerError&gt; {
    // FilesContainer handles path parsing internally
    if let Some(parent) = std::path::Path::new(path).parent() {
        if !container.exists(parent)? {
            container.create_dir_all(parent)?;
        }
    }
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="2-use-appropriate-backend-for-use-case"><a class="header" href="#2-use-appropriate-backend-for-use-case">2. Use Appropriate Backend for Use Case</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Recommended Backend</th></tr>
</thead>
<tbody>
<tr><td>Unit tests</td><td><code>MemoryBackend</code></td></tr>
<tr><td>Integration tests</td><td><code>MemoryBackend</code> or temp <code>SqliteBackend</code></td></tr>
<tr><td>Production</td><td><code>SqliteBackend</code></td></tr>
<tr><td>Host filesystem access</td><td><code>VRootFsBackend</code></td></tr>
</tbody>
</table>
</div>
<h3 id="3-set-reasonable-limits"><a class="header" href="#3-set-reasonable-limits">3. Set Reasonable Limits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::FilesContainer;

// Production defaults suggestion
let container = FilesContainer::new(SqliteBackend::create("data.db")?)
    .with_max_total_size(1024 * 1024 * 1024)  // 1 GB
    .with_max_file_size(100 * 1024 * 1024)    // 100 MB
    .with_max_node_count(1_000_000)            // 1M nodes
    .with_max_dir_entries(10_000)              // 10K per dir
    .with_max_path_depth(64);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#anyfs--api-quick-reference">API Quick Reference</a> — Condensed API overview</li>
<li><a href="#backend-implementers-guide">Backend Implementer’s Guide</a> — Create custom backends</li>
<li><a href="#anyfs---design-overview">Design Overview</a> — Technical architecture</li>
</ul>
<hr>
<p><em>Happy coding!</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--api-quick-reference"><a class="header" href="#anyfs--api-quick-reference">AnyFS — API Quick Reference</a></h1>
<p><strong>Condensed reference for developers</strong></p>
<hr>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
anyfs = "0.1"
anyfs-container = "0.1"
</code></pre>
<p>With specific backends:</p>
<pre><code class="language-toml">[dependencies]
anyfs = { version = "0.1", features = ["sqlite", "vrootfs"] }
anyfs-container = "0.1"
</code></pre>
<hr>
<h2 id="creating-a-container"><a class="header" href="#creating-a-container">Creating a Container</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::{MemoryBackend, SqliteBackend};
use anyfs_container::FilesContainer;

// In-memory (testing, caching, speed-critical applications)
let container = FilesContainer::new(MemoryBackend::new());

// SQLite (production)
let container = FilesContainer::new(
    SqliteBackend::open_or_create("data.db")?
);

// Full configuration with capacity limits
let container = FilesContainer::new(SqliteBackend::open_or_create("data.db")?)
    // Security posture: advanced features are opt-in (whitelist)
    .with_symlinks()
    .with_max_symlink_resolution(40)
    .with_hard_links()
    .with_permissions()
    .with_max_total_size(100 * 1024 * 1024)  // 100 MB
    .with_max_file_size(10 * 1024 * 1024)    // 10 MB
    .with_max_node_count(10_000)
    .with_max_dir_entries(1_000)
    .with_max_path_depth(64);

// Note: advanced features (symlinks/hard links/permissions) are disabled by default and must be explicitly enabled
// When symlinks are disabled, operations reject paths that traverse symlinks (nofollow).
<span class="boring">}</span></code></pre>
<hr>
<h2 id="path-handling"><a class="header" href="#path-handling">Path Handling</a></h2>
<p>FilesContainer accepts any path-like type (<code>&amp;str</code>, <code>String</code>, <code>&amp;Path</code>, <code>PathBuf</code>):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All of these work
container.write("/documents/report.pdf", data)?;
container.write(String::from("/file.txt"), data)?;
container.write(Path::new("/data.bin"), data)?;

// Normalization (automatic)
// "//a/../b/./c"  → "/b/c"
// "/../../../a"   → "/a" (can't escape root)
<span class="boring">}</span></code></pre>
<p>Backends receive normalized path strings (<code>&amp;str</code>). Path normalization is handled by FilesContainer before reaching the backend.</p>
<hr>
<h2 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h2>
<h3 id="reading"><a class="header" href="#reading">Reading</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check existence
container.exists("/path")?                    // → bool

// Get metadata (follows symlinks)
let meta = container.metadata("/path")?;
meta.size                                     // file size
meta.file_type                                // File | Directory | Symlink
meta.permissions                              // Permissions
meta.nlink                                    // hard link count
meta.created                                  // Option&lt;SystemTime&gt;
meta.modified                                 // Option&lt;SystemTime&gt;
meta.accessed                                 // Option&lt;SystemTime&gt;

// Get metadata without following symlinks
let meta = container.symlink_metadata("/path")?;

// Read file
let bytes = container.read("/path")?;         // → Vec&lt;u8&gt;
let text = container.read_to_string("/path")?; // → String (UTF-8)
let chunk = container.read_range("/path", 0, 1024)?;  // partial read

// List directory (std::fs aligned name)
let entries = container.read_dir("/path")?;   // → Vec&lt;DirEntry&gt;
for entry in entries {
    println!("{}: {:?}", entry.name, entry.file_type);
}

// Read symlink target (without following; requires symlinks enabled)
let target = container.read_link("/path")?;   // → PathBuf
<span class="boring">}</span></code></pre>
<h3 id="writing"><a class="header" href="#writing">Writing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create directory (std::fs aligned names)
container.create_dir("/path")?;               // single level
container.create_dir_all("/path")?;           // recursive

// Write file (create or overwrite)
container.write("/path", b"content")?;

// Append to file
container.append("/path", b"more")?;

// Create symlink (requires symlinks enabled)
container.symlink("/target", "/link")?;       // link points to target

// Create hard link (requires hard links enabled)
container.hard_link("/original", "/link")?;   // link shares content with original

// Delete (std::fs aligned: separate file/dir methods)
container.remove_file("/path")?;              // file only
container.remove_dir("/path")?;               // empty directory only
container.remove_dir_all("/path")?;           // recursive

// Set permissions (requires permissions enabled)
container.set_permissions("/path", Permissions::new())?;

// Rename/move
container.rename("/from", "/to")?;

// Copy
container.copy("/from", "/to")?;              // single file
<span class="boring">}</span></code></pre>
<hr>
<h2 id="capacity-management"><a class="header" href="#capacity-management">Capacity Management</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check usage
let usage = container.usage()?;
usage.total_size       // bytes used
usage.node_count       // total nodes
usage.file_count
usage.directory_count

// Check limits
let limits = container.limits();
limits.max_total_size  // Option&lt;u64&gt;
limits.max_file_size

// Check remaining
let remaining = container.remaining()?;
remaining.bytes        // Option&lt;u64&gt;
remaining.nodes
remaining.can_write    // quick check
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_container::ContainerError;

match container.write("/path", &amp;data) {
    Ok(()) =&gt; println!("Written"),

    Err(ContainerError::NotFound(p)) =&gt; println!("Path not found: {}", p),
    Err(ContainerError::AlreadyExists(p)) =&gt; println!("Already exists: {}", p),
    Err(ContainerError::NotADirectory(p)) =&gt; println!("Not a directory: {}", p),
    Err(ContainerError::NotAFile(p)) =&gt; println!("Not a file: {}", p),
    Err(ContainerError::DirectoryNotEmpty(p)) =&gt; println!("Not empty: {}", p),

    Err(ContainerError::TotalSizeExceeded { used, limit }) =&gt; {
        println!("Storage full: {} / {} bytes", used, limit);
    }
    Err(ContainerError::FileSizeExceeded { size, limit }) =&gt; {
        println!("File too large: {} &gt; {} bytes", size, limit);
    }

    Err(ContainerError::FeatureNotEnabled(name)) =&gt; {
        println!("Feature not enabled: {}", name);
    }

    Err(e) =&gt; println!("Other error: {}", e),
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="backend-lifecycle"><a class="header" href="#backend-lifecycle">Backend Lifecycle</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;

// Create new (fails if exists)
let backend = SqliteBackend::create("new.db")?;

// Open existing (fails if doesn't exist)
let backend = SqliteBackend::open("existing.db")?;

// Open or create
let backend = SqliteBackend::open_or_create("data.db")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="quick-patterns"><a class="header" href="#quick-patterns">Quick Patterns</a></h2>
<h3 id="ensure-parent-directories-exist"><a class="header" href="#ensure-parent-directories-exist">Ensure parent directories exist</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::VfsBackend;
use anyfs_container::{FilesContainer, ContainerError};

fn write_with_parents&lt;B: VfsBackend&gt;(
    container: &amp;mut FilesContainer&lt;B&gt;,
    path: &amp;str,
    data: &amp;[u8],
) -&gt; Result&lt;(), ContainerError&gt; {
    if let Some(parent) = std::path::Path::new(path).parent() {
        container.create_dir_all(parent)?;
    }
    container.write(path, data)
}
<span class="boring">}</span></code></pre>
<h3 id="walk-directory-tree"><a class="header" href="#walk-directory-tree">Walk directory tree</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{VfsBackend, DirEntry, FileType};
use anyfs_container::{FilesContainer, ContainerError};

fn walk&lt;B: VfsBackend&gt;(
    container: &amp;FilesContainer&lt;B&gt;,
    path: &amp;str,
    f: &amp;mut impl FnMut(&amp;str, &amp;DirEntry),
) -&gt; Result&lt;(), ContainerError&gt; {
    for entry in container.read_dir(path)? {
        let child_path = format!("{}/{}", path, entry.name);
        f(&amp;child_path, &amp;entry);
        if entry.file_type == FileType::Directory {
            walk(container, &amp;child_path, f)?;
        }
    }
    Ok(())
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="type-reference"><a class="header" href="#type-reference">Type Reference</a></h2>
<h3 id="from-anyfs-backend"><a class="header" href="#from-anyfs-backend">From <code>anyfs-backend</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>VfsBackend</code></td><td>Core trait for backends</td></tr>
<tr><td><code>FileType</code></td><td><code>File</code>, <code>Directory</code>, <code>Symlink</code></td></tr>
<tr><td><code>Metadata</code></td><td>File/directory metadata (includes <code>nlink</code>, <code>permissions</code>, <code>accessed</code>)</td></tr>
<tr><td><code>Permissions</code></td><td>File permissions (readonly flag)</td></tr>
<tr><td><code>DirEntry</code></td><td>Directory listing entry</td></tr>
<tr><td><code>VfsError</code></td><td>Backend-level errors</td></tr>
</tbody>
</table>
</div>
<h3 id="from-anyfs"><a class="header" href="#from-anyfs">From <code>anyfs</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>In-memory storage (fast, isolated)</td></tr>
<tr><td><code>SqliteBackend</code></td><td>SQLite-backed storage (portable)</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Host filesystem (contained via strict-path)</td></tr>
</tbody>
</table>
</div>
<h3 id="from-anyfs-container"><a class="header" href="#from-anyfs-container">From <code>anyfs-container</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>FilesContainer&lt;B&gt;</code></td><td>Main API, generic over backend (includes builder methods)</td></tr>
<tr><td><code>CapacityLimits</code></td><td>Quota configuration</td></tr>
<tr><td><code>CapacityUsage</code></td><td>Current usage stats</td></tr>
<tr><td><code>ContainerError</code></td><td>Container-level errors</td></tr>
</tbody>
</table>
</div>
<hr>
<p><em>For full details, see the <a href="#anyfs---design-overview">Design Overview</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---design-overview"><a class="header" href="#anyfs---design-overview">AnyFS - Design Overview</a></h1>
<p><strong>Status:</strong> Current
<strong>Last updated:</strong> 2025-12-23</p>
<hr>
<h2 id="what-this-project-is"><a class="header" href="#what-this-project-is">What This Project Is</a></h2>
<p>AnyFS is an <strong>open standard</strong> for pluggable virtual filesystem backends in Rust. Anyone can implement a custom backend for their own storage needs—whether that’s a database, object store, network filesystem, or any other medium.</p>
<p>The ecosystem provides:</p>
<ul>
<li><strong>A minimal backend trait</strong> that any storage implementer can satisfy</li>
<li><strong>Built-in backends</strong> for common cases (memory, SQLite, real filesystem)</li>
<li><strong>An optional policy layer</strong> (<code>FilesContainer</code>) for quotas, limits, and feature whitelisting</li>
</ul>
<p>It is designed for:</p>
<ul>
<li>portable application storage (SQLite backend = single <code>.db</code> file)</li>
<li>tenant isolation (one container per tenant)</li>
<li>quotas/limits (enforced in the container layer)</li>
<li>high-performance use cases (in-memory backend for speed-critical applications)</li>
</ul>
<p>It is not a POSIX emulator and does not try to expose OS-specific behavior.</p>
<blockquote>
<p><strong>Note on strict-path:</strong> The <code>strict-path</code> crate (providing <code>VirtualPath</code> and <code>VirtualRoot</code>) is <strong>only relevant for the <code>VRootFsBackend</code></strong>—a backend that wraps a real host filesystem directory. Other backends (SQLite, memory, custom) do not use or require strict-path.</p>
</blockquote>
<hr>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th><th>Who uses it</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-backend</code></td><td>Minimal contract: <code>VfsBackend</code> trait + core types</td><td>Backend implementers</td></tr>
<tr><td><code>anyfs</code></td><td>Low-level execution layer for calling any <code>VfsBackend</code>. Also provides built-in backends (feature-gated).</td><td>Direct backend manipulation</td></tr>
<tr><td><code>anyfs-container</code></td><td><code>FilesContainer&lt;B: VfsBackend&gt;</code> + limits + feature whitelist (least privilege)</td><td>Application code</td></tr>
</tbody>
</table>
</div>
<h3 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h3>
<pre><code>anyfs-backend (trait + types)
    &lt;- anyfs (calls any VfsBackend, provides built-in backends)
    &lt;- anyfs-container (wraps backends with policy)

strict-path (VirtualPath, VirtualRoot)
    &lt;- anyfs [vrootfs feature only]
</code></pre>
<p><strong>Key point:</strong> <code>anyfs-backend</code> defines the contract. <code>anyfs</code> is the execution layer that can call any backend—built-in or custom. <code>strict-path</code> is only used by the <code>vrootfs</code> feature.</p>
<hr>
<h2 id="path-handling-1"><a class="header" href="#path-handling-1">Path Handling</a></h2>
<p>AnyFS uses <code>impl AsRef&lt;Path&gt;</code> throughout, aligned with <code>std::fs</code>:</p>
<ol>
<li><strong>User-facing API (<code>FilesContainer</code>)</strong> accepts <code>impl AsRef&lt;Path&gt;</code> for ergonomics.</li>
<li><strong>Backend API (<code>VfsBackend</code>)</strong> accepts <code>impl AsRef&lt;Path&gt;</code> (same as std::fs).</li>
</ol>
<p>This keeps the API familiar and works correctly across all platforms (Windows UTF-16, Unix arbitrary bytes, etc.).</p>
<p><strong>VRootFsBackend</strong> — This backend (which wraps a real host filesystem directory) internally uses <code>strict-path::VirtualPath</code> to ensure path containment. This is an implementation detail of that backend, not part of the core trait.</p>
<hr>
<h2 id="core-trait-vfsbackend-in-anyfs-backend"><a class="header" href="#core-trait-vfsbackend-in-anyfs-backend">Core Trait: <code>VfsBackend</code> (in <code>anyfs-backend</code>)</a></h2>
<p><code>VfsBackend</code> is a path-based trait aligned with <code>std::fs</code> naming and signatures.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;

pub trait VfsBackend: Send {
    // Read
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, VfsError&gt;;
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt;;
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, VfsError&gt;;

    // Write
    fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn append(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_file(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn rename(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn copy(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // Links
    fn symlink(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn hard_link(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // Permissions
    fn set_permissions(&amp;mut self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), VfsError&gt;;

    // Streaming I/O (for large files)
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, VfsError&gt;;
    fn open_write(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Semantics (high-level):</strong></p>
<ul>
<li><code>read</code>/<code>write</code>/<code>metadata</code>/<code>exists</code>/<code>copy</code> follow symlinks.</li>
<li><code>symlink_metadata</code> and <code>read_link</code> do not follow.</li>
<li><code>remove_file</code> removes the symlink itself, not the target.</li>
<li>Streaming methods (<code>open_read</code>, <code>open_write</code>) enable efficient handling of large files.</li>
</ul>
<hr>
<h2 id="built-in-backends-in-anyfs"><a class="header" href="#built-in-backends-in-anyfs">Built-in Backends (in <code>anyfs</code>)</a></h2>
<p>These are provided by the <code>anyfs</code> crate and selected via Cargo features:</p>
<ul>
<li><code>memory</code> (default): <code>MemoryBackend</code> (test/reference backend)</li>
<li><code>vrootfs</code>: <code>VRootFsBackend</code> (contained real filesystem via <code>strict_path::VirtualRoot</code>)</li>
<li><code>sqlite</code>: <code>SqliteBackend</code> (single-file portable database backend)</li>
</ul>
<hr>
<h2 id="filescontainer-in-anyfs-container"><a class="header" href="#filescontainer-in-anyfs-container"><code>FilesContainer</code> (in <code>anyfs-container</code>)</a></h2>
<p><code>FilesContainer&lt;B&gt;</code> wraps any backend and provides:</p>
<ul>
<li>ergonomic paths (<code>impl AsRef&lt;Path&gt;</code>)</li>
<li>quota enforcement (limits)</li>
<li>a <strong>feature whitelist</strong> for advanced behavior (least privilege)</li>
</ul>
<h3 id="feature-whitelist-least-privilege"><a class="header" href="#feature-whitelist-least-privilege">Feature Whitelist (Least Privilege)</a></h3>
<p>Advanced features are <strong>disabled by default</strong>. Enable only what you need:</p>
<ul>
<li><code>symlinks</code> gates symlink creation and symlink-following behavior</li>
<li><code>hard_links</code> gates hard-link creation</li>
<li><code>permissions</code> gates permission mutation via <code>set_permissions</code></li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(MemoryBackend::new())
    .with_symlinks()
    .with_max_symlink_resolution(40)
    .with_hard_links()
    .with_permissions()
    .with_max_total_size(100 * 1024 * 1024);
<span class="boring">}</span></code></pre>
<p>When a feature is disabled, operations that require it return <code>ContainerError::FeatureNotEnabled("...")</code>.</p>
<h3 id="limits"><a class="header" href="#limits">Limits</a></h3>
<p>Limits are enforced by the container layer (not by backends):</p>
<ul>
<li><code>max_total_size</code></li>
<li><code>max_file_size</code></li>
<li><code>max_node_count</code></li>
<li><code>max_dir_entries</code></li>
<li><code>max_path_depth</code></li>
</ul>
<hr>
<h2 id="security-model-summary"><a class="header" href="#security-model-summary">Security Model (Summary)</a></h2>
<p>Security and isolation are achieved differently depending on the backend:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Isolation Mechanism</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Each instance is isolated by OS process memory</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Each container is a separate <code>.db</code> file</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Uses <code>strict-path::VirtualRoot</code> to clamp all paths to a root directory</td></tr>
</tbody>
</table>
</div>
<p><strong>Common guarantees:</strong></p>
<ul>
<li><strong>Least privilege:</strong> the container disables advanced features by default and requires explicit opt-in.</li>
<li><strong>Path normalization:</strong> all user paths are normalized before reaching the backend.</li>
<li><strong>No host paths in API:</strong> application code interacts only with virtual paths; backends decide actual storage.</li>
</ul>
<p>For more detail, see <code>book/src/comparisons/security.md</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="two-layer-design-ergonomic-paths--validated-paths"><a class="header" href="#two-layer-design-ergonomic-paths--validated-paths">Two-Layer Design: Ergonomic Paths + Validated Paths</a></h1>
<p>AnyFS intentionally uses two layers of path handling:</p>
<ol>
<li><strong>User-facing</strong>: <code>FilesContainer</code> methods take <code>impl AsRef&lt;Path&gt;</code>.</li>
<li><strong>Backend-facing</strong>: <code>VfsBackend</code> methods take <code>&amp;VirtualPath</code> (from <code>strict-path</code>).</li>
</ol>
<p>This keeps application code ergonomic while giving backends a single, validated path type.</p>
<hr>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<ul>
<li><strong>Least privilege</strong>: validation happens once at the boundary.</li>
<li><strong>Backend simplicity</strong>: backends do not re-parse strings or fight <code>..</code> traversal edge cases.</li>
<li><strong>Consistency</strong>: all backends receive the same normalized representation.</li>
</ul>
<hr>
<h2 id="flow"><a class="header" href="#flow">Flow</a></h2>
<pre><code>User code:
  container.write("/data/file.txt", b"...")

FilesContainer:
  VirtualPath::new("/data/file.txt") -&gt; VirtualPath
  backend.write(&amp;vpath, data)

Backend:
  receives &amp;VirtualPath (already validated)
</code></pre>
<hr>
<h2 id="important-interaction-with-security"><a class="header" href="#important-interaction-with-security">Important Interaction With Security</a></h2>
<p><code>FilesContainer</code> is the enforcement point for:</p>
<ul>
<li>quota/limit checks</li>
<li>feature whitelisting (deny-by-default for advanced behavior)</li>
</ul>
<p>The backend provides storage and filesystem semantics, but the container decides what is allowed for a given application.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs---architecture-decision-records"><a class="header" href="#anyfs---architecture-decision-records">AnyFS - Architecture Decision Records</a></h1>
<p>This file captures the decisions for the current AnyFS design.</p>
<hr>
<h2 id="adr-index"><a class="header" href="#adr-index">ADR Index</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ADR</th><th>Title</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>ADR-001</td><td>Path-based <code>VfsBackend</code> trait (20 methods)</td><td>Accepted</td></tr>
<tr><td>ADR-002</td><td>Three-crate structure (<code>anyfs-traits</code>, <code>anyfs</code>, <code>anyfs-container</code>)</td><td>Accepted</td></tr>
<tr><td>ADR-003</td><td>Two-layer path handling (<code>AsRef&lt;Path&gt;</code> -&gt; <code>VirtualPath</code>)</td><td>Accepted</td></tr>
<tr><td>ADR-004</td><td>Use <code>strict-path</code> for <code>VirtualPath</code> / containment</td><td>Accepted</td></tr>
<tr><td>ADR-005</td><td><code>std::fs</code>-aligned method names</td><td>Accepted</td></tr>
<tr><td>ADR-006</td><td>Least-privilege feature whitelist in <code>FilesContainer</code></td><td>Accepted</td></tr>
<tr><td>ADR-007</td><td>Limits enforced in container (not backend)</td><td>Accepted</td></tr>
<tr><td>ADR-008</td><td>Built-in backends are feature-gated</td><td>Accepted</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="adr-001-path-based-vfsbackend-trait-20-methods"><a class="header" href="#adr-001-path-based-vfsbackend-trait-20-methods">ADR-001: Path-based <code>VfsBackend</code> trait (20 methods)</a></h2>
<p><strong>Decision:</strong> Backends implement a path-based trait aligned with <code>std::fs</code> method naming.</p>
<p><strong>Why:</strong> Filesystem operations are naturally path-oriented; a single, familiar trait surface is easier to implement and adopt than graph-store or inode models.</p>
<hr>
<h2 id="adr-002-three-crate-structure"><a class="header" href="#adr-002-three-crate-structure">ADR-002: Three-crate structure</a></h2>
<p><strong>Decision:</strong></p>
<ul>
<li><code>anyfs-traits</code> is minimal and dependency-light</li>
<li><code>anyfs</code> provides optional built-in backends and re-exports the trait</li>
<li><code>anyfs-container</code> adds quotas/isolation/policy and should not force backend dependencies on custom backend authors</li>
</ul>
<hr>
<h2 id="adr-003-two-layer-path-handling"><a class="header" href="#adr-003-two-layer-path-handling">ADR-003: Two-layer path handling</a></h2>
<p><strong>Decision:</strong></p>
<ul>
<li><code>FilesContainer</code> accepts <code>impl AsRef&lt;Path&gt;</code> for ergonomics</li>
<li><code>VfsBackend</code> uses <code>&amp;VirtualPath</code> so backends receive validated paths</li>
</ul>
<hr>
<h2 id="adr-004-virtualpath-from-strict-path"><a class="header" href="#adr-004-virtualpath-from-strict-path">ADR-004: <code>VirtualPath</code> from <code>strict-path</code></a></h2>
<p><strong>Decision:</strong> Re-export <code>strict_path::VirtualPath</code> instead of defining a custom path type.</p>
<p><strong>Why:</strong> Centralizes containment and normalization in a tested dependency.</p>
<hr>
<h2 id="adr-005-stdfs-aligned-method-names"><a class="header" href="#adr-005-stdfs-aligned-method-names">ADR-005: <code>std::fs</code>-aligned method names</a></h2>
<p><strong>Decision:</strong> Prefer <code>read_dir</code>, <code>create_dir_all</code>, <code>remove_file</code>, etc.</p>
<p><strong>Why:</strong> Familiarity and reduced cognitive overhead.</p>
<hr>
<h2 id="adr-006-least-privilege-feature-whitelist-in-filescontainer"><a class="header" href="#adr-006-least-privilege-feature-whitelist-in-filescontainer">ADR-006: Least-privilege feature whitelist in <code>FilesContainer</code></a></h2>
<p><strong>Decision:</strong> Advanced behavior is disabled by default and explicitly enabled per container instance.</p>
<ul>
<li><code>symlinks()</code> enables symlink creation and symlink-following behavior (bounded by <code>max_symlink_resolution</code>, default 40)</li>
<li><code>hard_links()</code> enables hard link creation</li>
<li><code>permissions()</code> enables permission mutation via <code>set_permissions</code></li>
</ul>
<p>When disabled, the relevant operations return <code>ContainerError::FeatureNotEnabled("...")</code>.</p>
<hr>
<h2 id="adr-007-limits-enforced-in-container-not-backend"><a class="header" href="#adr-007-limits-enforced-in-container-not-backend">ADR-007: Limits enforced in container (not backend)</a></h2>
<p><strong>Decision:</strong> Capacity limits are enforced at the <code>anyfs-container</code> layer.</p>
<p><strong>Why:</strong> Limits are a policy decision and should be consistent across all backends.</p>
<hr>
<h2 id="adr-008-built-in-backends-are-feature-gated"><a class="header" href="#adr-008-built-in-backends-are-feature-gated">ADR-008: Built-in backends are feature-gated</a></h2>
<p><strong>Decision:</strong> <code>anyfs</code> uses Cargo features so users only pull the dependencies they need.</p>
<ul>
<li><code>memory</code> default</li>
<li><code>sqlite</code> optional</li>
<li><code>vrootfs</code> optional</li>
</ul>
<hr>
<h2 id="historical-notes"><a class="header" href="#historical-notes">Historical Notes</a></h2>
<p>Older docs referencing a graph-store (<code>StorageBackend</code>, <code>NodeId</code>, transactions) or inode-based traits are kept only as history and should not be treated as current.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vfsbackend-trait-anyfs-backend"><a class="header" href="#vfsbackend-trait-anyfs-backend">VfsBackend Trait (anyfs-backend)</a></h1>
<p><strong>The core backend contract for AnyFS</strong></p>
<hr>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><code>VfsBackend</code> is the minimal interface a storage backend implements.</p>
<ul>
<li>It is <strong>path-based</strong> and aligned with <code>std::fs</code> naming and signatures.</li>
<li>It uses <code>impl AsRef&lt;Path&gt;</code> for paths (same as <code>std::fs</code>).</li>
<li>It does not include quotas or application policy; that lives in <code>anyfs-container</code>.</li>
</ul>
<p>If you are implementing a custom backend, depend only on <code>anyfs-backend</code>.</p>
<hr>
<h2 id="trait-surface"><a class="header" href="#trait-surface">Trait Surface</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{Read, Write};
use std::path::{Path, PathBuf};

pub trait VfsBackend: Send {
    // Read
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn read_to_string(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;String, VfsError&gt;;
    fn read_range(&amp;self, path: impl AsRef&lt;Path&gt;, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn exists(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;bool, VfsError&gt;;
    fn metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn symlink_metadata(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Metadata, VfsError&gt;;
    fn read_dir(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
    fn read_link(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;PathBuf, VfsError&gt;;

    // Write
    fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn append(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn create_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_file(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn remove_dir_all(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn rename(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn copy(&amp;mut self, from: impl AsRef&lt;Path&gt;, to: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // Links
    fn symlink(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;
    fn hard_link(&amp;mut self, original: impl AsRef&lt;Path&gt;, link: impl AsRef&lt;Path&gt;) -&gt; Result&lt;(), VfsError&gt;;

    // Permissions
    fn set_permissions(&amp;mut self, path: impl AsRef&lt;Path&gt;, perm: Permissions) -&gt; Result&lt;(), VfsError&gt;;

    // Streaming I/O (for large files)
    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, VfsError&gt;;
    fn open_write(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="notes-on-semantics"><a class="header" href="#notes-on-semantics">Notes on Semantics</a></h2>
<ul>
<li><code>read</code>/<code>write</code>/<code>metadata</code>/<code>exists</code>/<code>copy</code> follow symlinks.</li>
<li><code>symlink_metadata</code> and <code>read_link</code> do not follow.</li>
<li><code>remove_file</code> removes the symlink itself, not the target.</li>
<li>Streaming methods (<code>open_read</code>, <code>open_write</code>) enable efficient handling of large files.</li>
</ul>
<p>The container layer may still deny certain operations via feature whitelisting.</p>
<hr>
<h2 id="implementing-a-backend"><a class="header" href="#implementing-a-backend">Implementing a Backend</a></h2>
<ul>
<li>Depend on <code>anyfs-backend</code> only.</li>
<li>Accept <code>impl AsRef&lt;Path&gt;</code> for all path parameters (aligned with std::fs).</li>
<li>Implement the semantics consistently across backends (a shared conformance suite is recommended).</li>
</ul>
<p>See <code>book/src/implementation/backend-guide.md</code> for a step-by-step guide.</p>
<hr>
<h2 id="note-on-vrootfsbackend"><a class="header" href="#note-on-vrootfsbackend">Note on VRootFsBackend</a></h2>
<p>The <code>VRootFsBackend</code> (which wraps a real host filesystem directory) internally uses <code>strict-path::VirtualPath</code> for path containment. This is an <strong>implementation detail</strong> of that specific backend—not part of the core trait contract.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="filescontainer-anyfs-container"><a class="header" href="#filescontainer-anyfs-container">FilesContainer (anyfs-container)</a></h1>
<p><strong>The user-facing API: ergonomic paths + policy (limits + feature whitelist)</strong></p>
<hr>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p><code>FilesContainer&lt;B: VfsBackend&gt;</code> wraps a backend and provides:</p>
<ul>
<li>ergonomic path inputs (<code>impl AsRef&lt;Path&gt;</code>)</li>
<li>centralized path normalization</li>
<li>quota enforcement (limits)</li>
<li>deny-by-default feature whitelisting for advanced behavior</li>
</ul>
<hr>
<h2 id="creating-a-container-1"><a class="header" href="#creating-a-container-1">Creating a Container</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(SqliteBackend::open_or_create("data.db")?)
    .with_max_total_size(100 * 1024 * 1024)
    .with_max_file_size(10 * 1024 * 1024)
    // advanced features are opt-in
    .with_symlinks()
    .with_max_symlink_resolution(40)
    .with_hard_links()
    .with_permissions();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="stdfs-aligned-methods"><a class="header" href="#stdfs-aligned-methods">std::fs-aligned Methods</a></h2>
<p>Most methods map directly to <code>std::fs</code> naming:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FilesContainer</th><th>std::fs</th></tr>
</thead>
<tbody>
<tr><td><code>read()</code></td><td><code>std::fs::read</code></td></tr>
<tr><td><code>read_to_string()</code></td><td><code>std::fs::read_to_string</code></td></tr>
<tr><td><code>write()</code></td><td><code>std::fs::write</code></td></tr>
<tr><td><code>append()</code></td><td><code>OpenOptions::append</code></td></tr>
<tr><td><code>read_dir()</code></td><td><code>std::fs::read_dir</code></td></tr>
<tr><td><code>create_dir()</code></td><td><code>std::fs::create_dir</code></td></tr>
<tr><td><code>create_dir_all()</code></td><td><code>std::fs::create_dir_all</code></td></tr>
<tr><td><code>remove_file()</code></td><td><code>std::fs::remove_file</code></td></tr>
<tr><td><code>remove_dir()</code></td><td><code>std::fs::remove_dir</code></td></tr>
<tr><td><code>remove_dir_all()</code></td><td><code>std::fs::remove_dir_all</code></td></tr>
<tr><td><code>rename()</code></td><td><code>std::fs::rename</code></td></tr>
<tr><td><code>copy()</code></td><td><code>std::fs::copy</code></td></tr>
<tr><td><code>metadata()</code></td><td><code>std::fs::metadata</code></td></tr>
<tr><td><code>symlink_metadata()</code></td><td><code>std::fs::symlink_metadata</code></td></tr>
<tr><td><code>read_link()</code></td><td><code>std::fs::read_link</code></td></tr>
<tr><td><code>set_permissions()</code></td><td><code>std::fs::set_permissions</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="feature-whitelist-least-privilege-1"><a class="header" href="#feature-whitelist-least-privilege-1">Feature Whitelist (Least Privilege)</a></h2>
<p>Advanced capabilities are disabled by default and must be explicitly enabled:</p>
<ul>
<li><code>symlinks()</code> enables symlink operations and symlink following</li>
<li><code>hard_links()</code> enables hard-link creation</li>
<li><code>permissions()</code> enables <code>set_permissions</code></li>
</ul>
<p>If disabled, the operation returns <code>ContainerError::FeatureNotEnabled("...")</code>.</p>
<hr>
<h2 id="limits-quotas"><a class="header" href="#limits-quotas">Limits (Quotas)</a></h2>
<p>Limits are enforced by the container, consistently across backends:</p>
<ul>
<li>total bytes</li>
<li>max file size</li>
<li>max nodes</li>
<li>max directory entries</li>
<li>max path depth</li>
</ul>
<p>See <code>book/src/getting-started/guide.md</code> for usage examples.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="which-crate-should-i-use"><a class="header" href="#which-crate-should-i-use">Which Crate Should I Use?</a></h1>
<hr>
<h2 id="decision-guide"><a class="header" href="#decision-guide">Decision Guide</a></h2>
<ul>
<li>Building an application? Use <code>anyfs-container</code> (<code>FilesContainer</code>).</li>
<li>Need a built-in backend (memory/sqlite/vrootfs)? Use <code>anyfs</code>.</li>
<li>Implementing your own backend? Depend only on <code>anyfs-traits</code>.</li>
</ul>
<hr>
<h2 id="quick-examples"><a class="header" href="#quick-examples">Quick Examples</a></h2>
<h3 id="application-code-recommended"><a class="header" href="#application-code-recommended">Application code (recommended)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(MemoryBackend::new());
container.create_dir_all("/data")?;
container.write("/data/file.txt", b"hello")?;
<span class="boring">}</span></code></pre>
<h3 id="application-code-with-policy-quotas--feature-whitelist"><a class="header" href="#application-code-with-policy-quotas--feature-whitelist">Application code with policy (quotas + feature whitelist)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::ContainerBuilder;

let mut container = ContainerBuilder::new(SqliteBackend::open_or_create("tenant.db")?)
    .max_total_size(100 * 1024 * 1024)
    .symlinks()
    .max_symlink_resolution(40)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="custom-backend-implementation"><a class="header" href="#custom-backend-implementation">Custom backend implementation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_traits::{VfsBackend, VirtualPath};

pub struct MyBackend;

impl VfsBackend for MyBackend {
    fn read(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt; {
        todo!()
    }

    // ... implement the remaining methods
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-mistake"><a class="header" href="#common-mistake">Common Mistake</a></h2>
<p>If you are implementing a backend, avoid depending on <code>anyfs</code> unless you specifically need built-in backends.
Use <code>anyfs-traits</code> as your dependency.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-container---comparison-and-positioning"><a class="header" href="#anyfs-container---comparison-and-positioning">AnyFS Container - Comparison and Positioning</a></h1>
<p><strong>How AnyFS Container compares to existing solutions</strong></p>
<p>AnyFS Container (<code>anyfs-container</code>) is a policy layer (quotas + isolation) over a pluggable virtual filesystem backend (<code>VfsBackend</code> from <code>anyfs-traits</code>). With the SQLite backend (<code>anyfs</code> feature <code>sqlite</code>), a tenant’s filesystem becomes a single portable <code>.db</code> file. It defaults to a least-privilege feature set; advanced features (symlinks, hard links, permissions) are opt-in.</p>
<hr>
<h2 id="executive-comparison"><a class="header" href="#executive-comparison">Executive Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Solution</th><th>Type</th><th style="text-align: right">Isolation</th><th style="text-align: right">Portability</th><th style="text-align: right">Multi-tenant</th><th style="text-align: right">Backend choice</th></tr>
</thead>
<tbody>
<tr><td><strong>AnyFS Container</strong></td><td>Library</td><td style="text-align: right">Yes</td><td style="text-align: right">Backend-dependent (SQLite = single file)</td><td style="text-align: right">Yes (per-tenant containers + quotas)</td><td style="text-align: right">Yes (trait-based)</td></tr>
<tr><td>SQLAR</td><td>Archive format</td><td style="text-align: right">No</td><td style="text-align: right">Yes (single file)</td><td style="text-align: right">No</td><td style="text-align: right">No (SQLite only)</td></tr>
<tr><td>libsqlfs</td><td>FUSE filesystem</td><td style="text-align: right">Varies (via mount)</td><td style="text-align: right">Yes (single file)</td><td style="text-align: right">No</td><td style="text-align: right">No (SQLite only)</td></tr>
<tr><td>AgentFS</td><td>Agent sandbox</td><td style="text-align: right">Yes (namespaces)</td><td style="text-align: right">Yes (SQLite)</td><td style="text-align: right">Partial</td><td style="text-align: right">No (SQLite only)</td></tr>
<tr><td><code>vfs</code> crate</td><td>Abstraction</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">No</td><td style="text-align: right">Yes (trait-based)</td></tr>
<tr><td>Docker/containers</td><td>Runtime</td><td style="text-align: right">Yes</td><td style="text-align: right">Complex</td><td style="text-align: right">Yes</td><td style="text-align: right">N/A</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="detailed-comparisons"><a class="header" href="#detailed-comparisons">Detailed Comparisons</a></h2>
<h3 id="vs-sqlar-sqlite-archive"><a class="header" href="#vs-sqlar-sqlite-archive">vs. SQLAR (SQLite archive)</a></h3>
<p><strong>What it is:</strong> SQLite’s official archive format. It’s great for import/export and backups, but it’s not a VFS API.</p>
<p><strong>Schema (representative):</strong></p>
<pre><code class="language-sql">CREATE TABLE sqlar(
  name TEXT PRIMARY KEY,
  mode INT,
  mtime INT,
  sz INT,
  data BLOB
);
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>SQLAR</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>API</td><td>SQL statements</td><td><code>FilesContainer</code> methods (<code>read</code>, <code>write</code>, <code>read_dir</code>, …)</td></tr>
<tr><td>Quotas</td><td>No</td><td>Yes (container-enforced)</td></tr>
<tr><td>Isolation</td><td>No</td><td>Yes (validated virtual paths, no host escape)</td></tr>
<tr><td>Transactions (public API)</td><td>Manual</td><td>No (SQLite backend uses transactions internally)</td></tr>
<tr><td>Link semantics</td><td>Not the focus</td><td>Supported (opt-in: symlink + hard link + permissions)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use SQLAR when:</strong> you want a simple archive/restore format.</p>
<p><strong>Use AnyFS Container when:</strong> your application needs filesystem-like operations + isolation + quotas.</p>
<hr>
<h3 id="vs-libsqlfs-guardian-project"><a class="header" href="#vs-libsqlfs-guardian-project">vs. libsqlfs (Guardian Project)</a></h3>
<p><strong>What it is:</strong> A FUSE filesystem backed by SQLite, aimed at secure mobile storage.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>libsqlfs</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Interface</td><td>Mounted filesystem</td><td>Library API</td></tr>
<tr><td>Deployment</td><td>Requires FUSE + OS integration</td><td>No mount, no host path access</td></tr>
<tr><td>Scope</td><td>POSIX filesystem</td><td><code>std::fs</code>-aligned trait (not full POSIX)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use libsqlfs when:</strong> you need a real mounted filesystem.</p>
<p><strong>Use AnyFS Container when:</strong> you want embedded application storage without mounting.</p>
<hr>
<h3 id="vs-agentfs-turso"><a class="header" href="#vs-agentfs-turso">vs. AgentFS (Turso)</a></h3>
<p><strong>What it is:</strong> A SQLite-backed virtual filesystem aimed at sandboxing AI agents.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>AgentFS</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Focus</td><td>Agent sandboxing + audit</td><td>General-purpose embedded storage</td></tr>
<tr><td>Isolation</td><td>OS namespaces</td><td>Structural (validated virtual paths)</td></tr>
<tr><td>Backend</td><td>SQLite only</td><td>Pluggable (SQLite is one option)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use AgentFS when:</strong> you want OS-level sandboxing + auditing.</p>
<p><strong>Use AnyFS Container when:</strong> you want a small, embeddable library with backend choice and quotas.</p>
<hr>
<h3 id="vs-vfs-crate-rust"><a class="header" href="#vs-vfs-crate-rust">vs. <code>vfs</code> crate (Rust)</a></h3>
<p><strong>What it is:</strong> A general Rust VFS trait + backends.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th><code>vfs</code> crate</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Trait design</td><td>Path-based operations</td><td>Path-based <code>VfsBackend</code> (<code>std::fs</code>-aligned)</td></tr>
<tr><td>Path safety</td><td>Backend-dependent</td><td>Centralized validation into <code>VirtualPath</code></td></tr>
<tr><td>SQLite backend</td><td>Not included</td><td>Built-in backend (feature-gated)</td></tr>
<tr><td>Quotas</td><td>No</td><td>Yes (<code>anyfs-container</code>)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use <code>vfs</code> when:</strong> you want a drop-in abstraction close to <code>std::fs</code>.</p>
<p><strong>Use AnyFS Container when:</strong> you need portable storage + quotas + containment guarantees.</p>
<hr>
<h3 id="vs-dockercontainers"><a class="header" href="#vs-dockercontainers">vs. Docker/containers</a></h3>
<p><strong>What it is:</strong> OS-level virtualization with isolated filesystem namespaces.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Containers</th><th>AnyFS Container</th></tr>
</thead>
<tbody>
<tr><td>Isolation level</td><td>OS process</td><td>Library</td></tr>
<tr><td>Overhead</td><td>High</td><td>Low</td></tr>
<tr><td>Primary use</td><td>Execute code</td><td>Store data</td></tr>
</tbody>
</table>
</div>
<p><strong>Use containers when:</strong> you need to run untrusted code.</p>
<p><strong>Use AnyFS Container when:</strong> you just need isolated application data storage.</p>
<hr>
<h2 id="feature-matrix"><a class="header" href="#feature-matrix">Feature Matrix</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>AnyFS Container</th><th>SQLAR</th><th>libsqlfs</th><th>AgentFS</th><th><code>vfs</code> crate</th></tr>
</thead>
<tbody>
<tr><td>Directories</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Files</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Symlinks</td><td>Yes</td><td>Limited/unstandardized</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Hard links</td><td>Yes</td><td>No</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Permissions</td><td>Yes (simple)</td><td>Limited (mode only)</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Extended attrs</td><td>No (future)</td><td>No</td><td>Varies</td><td>Varies</td><td>No</td></tr>
<tr><td>Transactions (public API)</td><td>No</td><td>Manual</td><td>Yes</td><td>Varies</td><td>No</td></tr>
<tr><td>Capacity limits</td><td>Yes (built-in)</td><td>No</td><td>No</td><td>Varies</td><td>No</td></tr>
<tr><td>Streaming I/O</td><td>No (future)</td><td>No</td><td>Yes</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Async API</td><td>No (future)</td><td>N/A</td><td>No</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>FUSE mount</td><td>No (by design)</td><td>No</td><td>Yes</td><td>Yes</td><td>Backend-dependent</td></tr>
<tr><td>Compression</td><td>Backend</td><td>Yes (deflate)</td><td>Varies</td><td>Varies</td><td>Backend-dependent</td></tr>
<tr><td>Encryption</td><td>Backend</td><td>No</td><td>Yes (SQLCipher)</td><td>Varies</td><td>Backend-dependent</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="when-to-use-anyfs-container"><a class="header" href="#when-to-use-anyfs-container">When to Use AnyFS Container</a></h2>
<p><strong>Good fit:</strong></p>
<ul>
<li>Multi-tenant SaaS that needs per-tenant quotas</li>
<li>Desktop apps that want portable user data</li>
<li>Testing that needs deterministic isolated storage</li>
<li>Plugin systems that need per-plugin isolation</li>
</ul>
<p><strong>Not a good fit:</strong></p>
<ul>
<li>You must mount a filesystem into the host OS (use a FUSE solution)</li>
<li>You need full POSIX behavior (xattrs/ACLs/etc.)</li>
<li>You need maximum throughput over safety/portability</li>
</ul>
<hr>
<h2 id="migration-paths"><a class="header" href="#migration-paths">Migration Paths</a></h2>
<h3 id="from-raw-sqlitesqlar"><a class="header" href="#from-raw-sqlitesqlar">From raw SQLite/SQLAR</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Old: raw SQL
conn.execute("INSERT INTO sqlar(name, data) VALUES (?, ?)", [path, data])?;

// New: AnyFS Container
container.write(path, data)?;
<span class="boring">}</span></code></pre>
<h3 id="from-stdfs"><a class="header" href="#from-stdfs">From <code>std::fs</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Old: host filesystem
std::fs::write("/data/file.txt", content)?;

// New: AnyFS Container
container.write("/data/file.txt", content)?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>AnyFS Container occupies a niche between archives (SQLAR) and mounted filesystems (FUSE): it is an <strong>application-level</strong> filesystem API with <strong>quotas</strong> and <strong>containment guarantees</strong>, with <strong>backend choice</strong> (including a portable SQLite option).</p>
<p><em>For technical details, see the <a href="#anyfs---design-overview">Design Overview</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h1>
<p><strong>Security model, threat analysis, and containment guarantees</strong></p>
<hr>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The AnyFS ecosystem is designed with security as a primary concern. This document outlines the security model, potential threats, and the guarantees provided by the architecture.</p>
<hr>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<h3 id="in-scope"><a class="header" href="#in-scope">In Scope</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Description</th><th>Mitigation</th></tr>
</thead>
<tbody>
<tr><td><strong>Path traversal</strong></td><td>Attacker attempts to access files outside the container via <code>../</code></td><td>Lexical path resolution in <code>VirtualPath</code></td></tr>
<tr><td><strong>Symlink attacks</strong></td><td>Attacker uses symlinks to bypass controls</td><td>Symlinks are disabled by default; when enabled, targets validated and resolution is bounded</td></tr>
<tr><td><strong>Resource exhaustion</strong></td><td>Attacker fills storage or creates excessive files</td><td>Capacity limits enforced by <code>FilesContainer</code></td></tr>
<tr><td><strong>Tenant data leakage</strong></td><td>One tenant accesses another’s data</td><td>Complete isolation via separate containers</td></tr>
</tbody>
</table>
</div>
<h3 id="out-of-scope"><a class="header" href="#out-of-scope">Out of Scope</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><strong>Side-channel attacks</strong></td><td>Timing attacks, cache analysis — requires OS-level mitigations</td></tr>
<tr><td><strong>Physical access</strong></td><td>Disk encryption is application’s responsibility</td></tr>
<tr><td><strong>SQLite vulnerabilities</strong></td><td>Upstream dependency; update regularly</td></tr>
<tr><td><strong>Denial of service</strong></td><td>Rate limiting is application’s responsibility</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h2>
<h3 id="1-path-normalization"><a class="header" href="#1-path-normalization">1. Path Normalization</a></h3>
<p>All user paths are normalized by <code>FilesContainer</code> before reaching the backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User input is normalized immediately
// These attacks are structurally prevented:
"/../../../etc/passwd"  // → "/etc/passwd" (clamped to root)
"/data/../../../../tmp" // → "/tmp" (clamped to root)
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: No path can escape the virtual root, regardless of <code>..</code> sequences.</p>
<h3 id="2-lexical-path-resolution"><a class="header" href="#2-lexical-path-resolution">2. Lexical Path Resolution</a></h3>
<p>Unlike POSIX filesystems, paths are resolved <strong>lexically</strong> without consulting the filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// POSIX behavior (dangerous):
// /foo/bar/.. where bar → /etc would resolve to /etc/../ → /

// AnyFS behavior (safe):
// /foo/bar/.. always resolves to /foo (pure string manipulation)
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: Lexical normalization is deterministic. If symlinks are disabled (default), resolution cannot be influenced by filesystem state; if enabled, symlink traversal is contained and bounded.</p>
<h3 id="path-containment-by-backend-type"><a class="header" href="#path-containment-by-backend-type">Path Containment by Backend Type</a></h3>
<p>Different backends achieve containment differently:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Containment Mechanism</th></tr>
</thead>
<tbody>
<tr><td><code>MemoryBackend</code></td><td>Isolated by OS process memory—no host filesystem access</td></tr>
<tr><td><code>SqliteBackend</code></td><td>Each container is a separate <code>.db</code> file—no path traversal possible</td></tr>
<tr><td><code>VRootFsBackend</code></td><td>Uses <code>strict-path::VirtualRoot</code> to clamp all paths to a root directory</td></tr>
</tbody>
</table>
</div>
<h3 id="3-symlink-safety-opt-in"><a class="header" href="#3-symlink-safety-opt-in">3. Symlink Safety (Opt-In)</a></h3>
<p>Symlink safety:</p>
<ul>
<li>Symlinks are <strong>disabled by default</strong> (least privilege / whitelist)</li>
<li>If enabled, symlink targets are validated</li>
<li>Resolution is bounded by a configurable hop limit (default: 40)</li>
<li>Symlinks cannot point outside the container</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let mut container = FilesContainer::new(MemoryBackend::new())
    .with_symlinks()
    .with_max_symlink_resolution(40);

// Symlink creation validates the target (when enabled)
container.symlink("/deeply/nested/path", "/shortcut")?;

// Following symlinks respects the depth limit
container.read("/shortcut")?;  // Max 40 hops
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: Symlink loops are detected; symlinks cannot escape containment (when enabled).</p>
<h3 id="4-capacity-limits"><a class="header" href="#4-capacity-limits">4. Capacity Limits</a></h3>
<p><code>FilesContainer</code> enforces configurable limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

let container = FilesContainer::new(MemoryBackend::new())
    .with_max_total_size(100 * 1024 * 1024)  // 100 MB total
    .with_max_file_size(10 * 1024 * 1024)    // 10 MB per file
    .with_max_node_count(10_000)              // 10K files/directories
    .with_max_dir_entries(1_000)              // 1K entries per directory
    .with_max_path_depth(64);                 // Max directory depth
<span class="boring">}</span></code></pre>
<p><strong>Guarantee</strong>: Resource exhaustion attacks are mitigated.</p>
<hr>
<h2 id="secure-usage-patterns"><a class="header" href="#secure-usage-patterns">Secure Usage Patterns</a></h2>
<h3 id="multi-tenant-isolation"><a class="header" href="#multi-tenant-isolation">Multi-Tenant Isolation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::FilesContainer;

// Each tenant gets a completely separate container
fn create_tenant_storage(tenant_id: &amp;str) -&gt; FilesContainer&lt;SqliteBackend&gt; {
    let db_path = format!("tenants/{}.db", tenant_id);
    let backend = SqliteBackend::create(&amp;db_path).unwrap();

    FilesContainer::new(backend)
        .with_max_total_size(tenant_quota(tenant_id))
}

// No path can cross tenant boundaries — they're different files entirely
<span class="boring">}</span></code></pre>
<h3 id="untrusted-input-handling"><a class="header" href="#untrusted-input-handling">Untrusted Input Handling</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::VfsBackend;
use anyfs_container::{FilesContainer, ContainerError};

fn handle_user_upload(
    container: &amp;mut FilesContainer&lt;impl VfsBackend&gt;,
    user_filename: &amp;str,  // Untrusted input
    data: &amp;[u8],
) -&gt; Result&lt;(), ContainerError&gt; {
    // FilesContainer normalizes the path internally:
    // - Rejects invalid UTF-8
    // - Normalizes path (removes .., .)
    // - Ensures absolute path
    let path = format!("/uploads/{}", user_filename);

    // Safe to use - container validates before reaching backend
    container.write(&amp;path, data)?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="sandboxed-execution"><a class="header" href="#sandboxed-execution">Sandboxed Execution</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::MemoryBackend;
use anyfs_container::FilesContainer;

// Create an isolated sandbox for untrusted code
let sandbox = FilesContainer::new(MemoryBackend::new())
    .with_max_total_size(10 * 1024 * 1024)  // 10 MB limit
    .with_max_file_size(1024 * 1024)         // 1 MB per file
    .with_max_node_count(100);               // Max 100 files

// Untrusted code can only access this sandbox
// Cannot escape, cannot exhaust resources
<span class="boring">}</span></code></pre>
<hr>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h2>
<h3 id="for-application-developers"><a class="header" href="#for-application-developers">For Application Developers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Set appropriate capacity limits for your use case</li>
<li><input disabled="" type="checkbox"> Use separate containers for separate tenants/users</li>
<li><input disabled="" type="checkbox"> Let <code>FilesContainer</code> handle path normalization—don’t bypass it</li>
<li><input disabled="" type="checkbox"> Consider restricting link operations if not needed (they’re off by default)</li>
<li><input disabled="" type="checkbox"> Keep dependencies updated (especially <code>rusqlite</code> for SQLite backend)</li>
</ul>
<h3 id="for-backend-implementers"><a class="header" href="#for-backend-implementers">For Backend Implementers</a></h3>
<ul>
<li><input disabled="" type="checkbox"> Ensure paths cannot escape the backend’s intended scope</li>
<li><input disabled="" type="checkbox"> For filesystem backends: use <code>strict-path</code> for path containment</li>
<li><input disabled="" type="checkbox"> Handle concurrent access safely (if supporting <code>Sync</code>)</li>
<li><input disabled="" type="checkbox"> Report errors without leaking internal/host paths</li>
</ul>
<hr>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<ol>
<li><strong>No encryption at rest</strong>: Use OS-level encryption (LUKS, FileVault) or encrypted SQLite extensions</li>
<li><strong>No access control lists</strong>: Permissions are opt-in and simple (Unix mode bits only)</li>
<li><strong>No audit logging</strong>: Application must implement its own logging</li>
<li><strong>Time-of-check-time-of-use (TOCTOU)</strong>: Like all filesystems, check-then-act patterns may race</li>
</ol>
<hr>
<h2 id="reporting-security-issues"><a class="header" href="#reporting-security-issues">Reporting Security Issues</a></h2>
<p>If you discover a security vulnerability, please report it responsibly:</p>
<ol>
<li>Do not open a public issue</li>
<li>Email security concerns to the maintainers</li>
<li>Allow time for a fix before public disclosure</li>
</ol>
<hr>
<p><em>For implementation details, see <a href="#anyfs---architecture-decision-records">Architecture Decision Records</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-container---technical-comparison-with-alternatives"><a class="header" href="#anyfs-container---technical-comparison-with-alternatives">AnyFS Container - Technical Comparison with Alternatives</a></h1>
<p>This document compares AnyFS (especially <code>anyfs-container</code>) with existing Rust filesystem abstractions.</p>
<hr>
<h2 id="executive-summary"><a class="header" href="#executive-summary">Executive summary</a></h2>
<p>AnyFS is opinionated around three goals:</p>
<ul>
<li><strong>Safety by construction</strong>: container APIs accept <code>impl AsRef&lt;Path&gt;</code>, but backends only see validated <code>&amp;VirtualPath</code> (from <code>strict-path</code>).</li>
<li><strong>Least privilege by default</strong>: advanced behaviors (symlinks, hard links, permission mutation) are denied unless explicitly enabled per container.</li>
<li><strong>Portable storage</strong>: the SQLite backend turns a tenant filesystem into a single portable <code>.db</code> file.</li>
</ul>
<hr>
<h2 id="compared-solutions"><a class="header" href="#compared-solutions">Compared solutions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Solution</th><th>What it is</th><th>Where it fits</th></tr>
</thead>
<tbody>
<tr><td><code>vfs</code></td><td>General-purpose VFS trait + backends</td><td>Simple path-based abstraction, streaming handles</td></tr>
<tr><td><code>virtual-filesystem</code></td><td>std::fs-like interface with sandbox option</td><td>Small abstraction for in-process sandboxing</td></tr>
<tr><td>OpenDAL</td><td>Object storage access layer</td><td>Cloud/object storage (async-first)</td></tr>
<tr><td>AgentFS</td><td>SQLite-backed agent sandbox</td><td>OS-level sandboxing + auditing (product-focused)</td></tr>
<tr><td>AnyFS</td><td>VFS backends + policy layer</td><td>Embedded storage, multi-tenant quotas, portability</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-trait--api-design"><a class="header" href="#1-trait--api-design">1. Trait / API design</a></h2>
<h3 id="vfs-crate-typical-shape"><a class="header" href="#vfs-crate-typical-shape"><code>vfs</code> crate (typical shape)</a></h3>
<p><code>vfs</code> exposes a path-based trait taking raw strings and often returns streaming handles:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FileSystem: Send + Sync {
    fn read_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn Iterator&lt;Item = String&gt; + Send&gt;&gt;;
    fn create_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn open_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndRead + Send&gt;&gt;;
    fn create_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;Box&lt;dyn SeekAndWrite + Send&gt;&gt;;
    fn metadata(&amp;self, path: &amp;str) -&gt; VfsResult&lt;VfsMetadata&gt;;
    fn exists(&amp;self, path: &amp;str) -&gt; VfsResult&lt;bool&gt;;
    fn remove_file(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
    fn remove_dir(&amp;self, path: &amp;str) -&gt; VfsResult&lt;()&gt;;
}
<span class="boring">}</span></code></pre>
<p><strong>Implications:</strong></p>
<ul>
<li>Backends must validate/normalize paths themselves.</li>
<li>The API surface is typically “filesystem flavored”, but not standardized on <code>std::fs</code> naming.</li>
</ul>
<h3 id="anyfs-two-layer-path-handling--policy-layer"><a class="header" href="#anyfs-two-layer-path-handling--policy-layer">AnyFS: two-layer path handling + policy layer</a></h3>
<p>AnyFS splits responsibilities across three crates:</p>
<ul>
<li><code>anyfs-traits</code>: minimal <code>VfsBackend</code> + core types (backend implementers depend only on this)</li>
<li><code>anyfs</code>: re-exports <code>anyfs-traits</code> and provides built-in backends (feature-gated)</li>
<li><code>anyfs-container</code>: <code>FilesContainer&lt;B: VfsBackend&gt;</code> plus limits and feature whitelist</li>
</ul>
<p><strong>Backend trait (<code>anyfs-traits</code>):</strong> validated paths only.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

pub trait VfsBackend: Send {
    fn read(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    fn write(&amp;mut self, path: &amp;VirtualPath, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    fn read_dir(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
    fn symlink(&amp;mut self, original: &amp;VirtualPath, link: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    fn hard_link(&amp;mut self, original: &amp;VirtualPath, link: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    fn set_permissions(&amp;mut self, path: &amp;VirtualPath, perm: Permissions) -&gt; Result&lt;(), VfsError&gt;;
    // ... (20 std::fs-aligned methods total)
}
<span class="boring">}</span></code></pre>
<p><strong>User-facing API (<code>anyfs-container</code>):</strong> ergonomic paths, plus enforcement.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;

impl&lt;B: VfsBackend&gt; FilesContainer&lt;B&gt; {
    pub fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, ContainerError&gt;;
    pub fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), ContainerError&gt;;
    // ... names aligned with std::fs
}
<span class="boring">}</span></code></pre>
<p><strong>Implications:</strong></p>
<ul>
<li>Path validation happens once, centrally, before any backend sees the path.</li>
<li>Limits and default-deny features are consistent across all backends.</li>
</ul>
<hr>
<h2 id="2-what-makes-anyfs-container-better"><a class="header" href="#2-what-makes-anyfs-container-better">2. What makes AnyFS Container better</a></h2>
<h3 id="21-centralized-path-safety"><a class="header" href="#21-centralized-path-safety">2.1 Centralized path safety</a></h3>
<ul>
<li><code>VirtualPath</code> normalizes <code>.</code> / <code>..</code> lexically and prevents escaping the virtual root.</li>
<li>Backends do not accept raw strings, reducing the attack surface.</li>
</ul>
<h3 id="22-least-privilege-feature-whitelist"><a class="header" href="#22-least-privilege-feature-whitelist">2.2 Least privilege (feature whitelist)</a></h3>
<p>Advanced behavior is disabled by default and enabled explicitly per container instance:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_container::ContainerBuilder;

let container = ContainerBuilder::new(backend)
    .symlinks()
    .max_symlink_resolution(40)
    .hard_links()
    .permissions()
    .build()?;
<span class="boring">}</span></code></pre>
<p>This supports a default-deny posture for apps handling untrusted input.</p>
<h3 id="23-built-in-quotas-and-limits"><a class="header" href="#23-built-in-quotas-and-limits">2.3 Built-in quotas and limits</a></h3>
<p><code>FilesContainer</code> can enforce limits like:</p>
<ul>
<li>max total bytes</li>
<li>max file size</li>
<li>max node count</li>
<li>max directory entries</li>
<li>max path depth</li>
</ul>
<p>Backends remain focused on storage, while enforcement stays consistent.</p>
<h3 id="24-portable-single-file-storage-sqlite-backend"><a class="header" href="#24-portable-single-file-storage-sqlite-backend">2.4 Portable “single file” storage (SQLite backend)</a></h3>
<p>With the <code>sqlite</code> backend, an entire tenant filesystem is a single <code>.db</code> file that can be copied/moved as a unit.</p>
<h3 id="25-dependency-control"><a class="header" href="#25-dependency-control">2.5 Dependency control</a></h3>
<ul>
<li><code>anyfs</code> uses Cargo features (<code>memory</code> default, <code>sqlite</code>, <code>vrootfs</code>) so users only compile what they use.</li>
<li>Custom backend authors depend only on <code>anyfs-traits</code>.</li>
</ul>
<hr>
<h2 id="3-tradeoffs--downsides"><a class="header" href="#3-tradeoffs--downsides">3. Tradeoffs / downsides</a></h2>
<h3 id="31-fewer-backends-initially"><a class="header" href="#31-fewer-backends-initially">3.1 Fewer backends (initially)</a></h3>
<p>AnyFS intentionally starts small: Memory, SQLite, and a contained host filesystem backend.</p>
<h3 id="32-sync-only-whole-file-io"><a class="header" href="#32-sync-only-whole-file-io">3.2 Sync-only, whole-file I/O</a></h3>
<p>The core API is sync-first and the common read/write APIs are whole-buffer (<code>Vec&lt;u8&gt;</code>).
Streaming handles and async APIs are future work.</p>
<h3 id="33-not-full-posix"><a class="header" href="#33-not-full-posix">3.3 Not full POSIX</a></h3>
<p>AnyFS aims for <code>std::fs</code> alignment, but does not try to exactly emulate OS edge cases.</p>
<h3 id="34-cross-platform-link-semantics"><a class="header" href="#34-cross-platform-link-semantics">3.4 Cross-platform link semantics</a></h3>
<p>Symlink and hard-link behavior differs across OSes and filesystems. AnyFS exposes links as a virtual concept, but real host filesystem behavior (especially on Windows) may vary.</p>
<hr>
<h2 id="4-when-to-use-what"><a class="header" href="#4-when-to-use-what">4. When to use what</a></h2>
<ul>
<li>Use <strong>AnyFS Container</strong> when you need embedded app storage, multi-tenant isolation, quotas, and portability.</li>
<li>Use <strong><code>vfs</code></strong> when you want a general-purpose VFS abstraction with streaming handles and you are comfortable with backend-specific path validation.</li>
<li>Use <strong>OpenDAL</strong> when your “filesystem” is actually object storage (S3/GCS/Azure) and you want async + middleware.</li>
</ul>
<hr>
<h2 id="5-feature-matrix-high-level"><a class="header" href="#5-feature-matrix-high-level">5. Feature matrix (high level)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>AnyFS Container</th><th><code>vfs</code></th><th>OpenDAL</th></tr>
</thead>
<tbody>
<tr><td>Path validation centralized</td><td>Yes (<code>VirtualPath</code>)</td><td>No</td><td>No</td></tr>
<tr><td>Quotas/limits</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td>Least-privilege defaults</td><td>Yes (whitelist)</td><td>No</td><td>N/A</td></tr>
<tr><td>SQLite backend</td><td>Yes (feature <code>sqlite</code>)</td><td>No</td><td>No</td></tr>
<tr><td>Host filesystem containment</td><td>Yes (<code>VRootFsBackend</code> + <code>VirtualRoot</code>)</td><td>Backend-dependent</td><td>N/A</td></tr>
<tr><td>Streaming I/O</td><td>Not yet</td><td>Often yes</td><td>Yes</td></tr>
<tr><td>Async API</td><td>Not yet</td><td>Backend-dependent</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<hr>
<p>If you spot an inconsistency between this document and <code>book/src/architecture/design-overview.md</code> or <code>AGENTS.md</code>, treat those as authoritative.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs-container---build-vs-reuse-analysis"><a class="header" href="#anyfs-container---build-vs-reuse-analysis">AnyFS Container - Build vs. Reuse Analysis</a></h1>
<p><strong>Can your goals be achieved with existing crates, or does this project need to exist?</strong></p>
<hr>
<h2 id="core-requirements"><a class="header" href="#core-requirements">Core Requirements</a></h2>
<ol>
<li><strong>Tenant isolation</strong> - each tenant gets an isolated namespace</li>
<li><strong>Capacity limits</strong> - per-tenant quotas and safe failure modes</li>
<li><strong>Portable storage option</strong> - a single-file backend (SQLite) for easy move/copy/backup</li>
<li><strong>Filesystem semantics</strong> - <code>std::fs</code>-aligned operations including opt-in symlinks and hard links</li>
<li><strong>Containment by construction</strong> - prevent path traversal and symlink escapes</li>
</ol>
<hr>
<h2 id="what-already-exists"><a class="header" href="#what-already-exists">What Already Exists</a></h2>
<h3 id="vfs-crate-rust"><a class="header" href="#vfs-crate-rust"><code>vfs</code> crate (Rust)</a></h3>
<p><strong>What it is:</strong> A general virtual filesystem abstraction with multiple backends.</p>
<p><strong>What it does well:</strong></p>
<ul>
<li>Provides an abstraction layer similar to <code>std::fs</code></li>
<li>Has multiple existing backends</li>
</ul>
<p><strong>What it does not provide (out of the box):</strong></p>
<ul>
<li>SQLite-backed portable storage</li>
<li>Capacity limits / quota enforcement</li>
<li>Built-in tenant isolation patterns</li>
<li>Two-layer path handling (ergonomic user paths + validated internal paths)</li>
</ul>
<p>You <em>can</em> implement a SQLite backend for <code>vfs</code>, but you still need to design quotas + isolation yourself.</p>
<h3 id="rusqlite"><a class="header" href="#rusqlite"><code>rusqlite</code></a></h3>
<p><strong>What it is:</strong> SQLite bindings.</p>
<p><strong>What it provides:</strong> DB access, transactions, blobs (with features), migrations.</p>
<p><strong>What it does not provide:</strong> Filesystem semantics or path safety.</p>
<h3 id="strict-path"><a class="header" href="#strict-path"><code>strict-path</code></a></h3>
<p><strong>What it is:</strong> Path validation + containment primitives (<code>VirtualRoot</code>, <code>VirtualPath</code>).</p>
<p><strong>What it provides:</strong> The “can’t escape the root” guarantee that the whole design depends on.</p>
<p><strong>What it does not provide:</strong> Storage backends (SQLite, memory, etc.) or a filesystem API.</p>
<h3 id="sqlar-sqlite-archive-format"><a class="header" href="#sqlar-sqlite-archive-format">SQLAR (SQLite archive format)</a></h3>
<p><strong>What it is:</strong> A standardized “files in a SQLite table” archive format.</p>
<p><strong>Why it’s not enough:</strong> It’s an archive format, not a filesystem API with quotas, isolation, and link semantics.</p>
<hr>
<h2 id="gap-analysis"><a class="header" href="#gap-analysis">Gap Analysis</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Requirement</th><th style="text-align: right"><code>vfs</code> crate</th><th style="text-align: right">SQLAR</th><th style="text-align: right"><code>rusqlite</code></th><th style="text-align: right"><code>strict-path</code></th></tr>
</thead>
<tbody>
<tr><td>Filesystem API</td><td style="text-align: right">Yes</td><td style="text-align: right">No</td><td style="text-align: right">No</td><td style="text-align: right">No</td></tr>
<tr><td>SQLite-backed portable storage</td><td style="text-align: right">No</td><td style="text-align: right">Yes (format)</td><td style="text-align: right">Yes (raw)</td><td style="text-align: right">No</td></tr>
<tr><td>Tenant isolation model</td><td style="text-align: right">No</td><td style="text-align: right">No</td><td style="text-align: right">Manual</td><td style="text-align: right">No</td></tr>
<tr><td>Capacity limits / quotas</td><td style="text-align: right">No</td><td style="text-align: right">No</td><td style="text-align: right">Manual</td><td style="text-align: right">No</td></tr>
<tr><td>Path traversal safety</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">Manual</td><td style="text-align: right">Manual</td><td style="text-align: right">Yes</td></tr>
<tr><td>Link semantics (symlink + hard link)</td><td style="text-align: right">Backend-dependent</td><td style="text-align: right">Not the focus</td><td style="text-align: right">Manual</td><td style="text-align: right">N/A</td></tr>
</tbody>
</table>
</div>
<p><strong>Conclusion:</strong> You can reuse key building blocks, but no existing crate composes into:</p>
<blockquote>
<p>“A tenant-isolated filesystem API with quotas, backed by SQLite, with containment guarantees.”</p>
</blockquote>
<hr>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<h3 id="option-a-implement-a-sqlite-backend-for-the-vfs-crate"><a class="header" href="#option-a-implement-a-sqlite-backend-for-the-vfs-crate">Option A: Implement a SQLite backend for the <code>vfs</code> crate</a></h3>
<p><strong>Pros</strong></p>
<ul>
<li>Immediate ecosystem compatibility</li>
<li>Familiar trait surface area</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Still need to build tenant isolation + quotas outside the trait</li>
<li>Path containment becomes backend/adapter responsibility</li>
<li>Streaming handle APIs can increase SQLite complexity</li>
</ul>
<h3 id="option-b-current-anyfs-architecture-recommended"><a class="header" href="#option-b-current-anyfs-architecture-recommended">Option B: Current AnyFS architecture (recommended)</a></h3>
<p><strong>Approach:</strong> Keep responsibilities separated into three crates:</p>
<ul>
<li><code>anyfs-traits</code>: <code>VfsBackend</code> + types, uses <code>&amp;VirtualPath</code></li>
<li><code>anyfs</code>: feature-gated built-in backends (<code>MemoryBackend</code>, <code>VRootFsBackend</code>, <code>SqliteBackend</code>)</li>
<li><code>anyfs-container</code>: <code>FilesContainer</code> wrapper (ergonomic <code>impl AsRef&lt;Path&gt;</code> + quotas)</li>
</ul>
<p><strong>Why this exists:</strong> It makes containment a property of the type system and concentrates validation in one place:
<code>FilesContainer</code> validates user paths once, then calls the backend with <code>&amp;VirtualPath</code>.</p>
<h3 id="option-c-stay-on-raw-rusqlite--your-own-helpers"><a class="header" href="#option-c-stay-on-raw-rusqlite--your-own-helpers">Option C: Stay on raw <code>rusqlite</code> (+ your own helpers)</a></h3>
<p>Fastest to prototype, but it becomes an ad-hoc filesystem without a stable contract, and quotas/isolation are easy to get wrong.</p>
<h3 id="option-d-add-a-compatibility-adapter-later-optional"><a class="header" href="#option-d-add-a-compatibility-adapter-later-optional">Option D: Add a compatibility adapter later (optional)</a></h3>
<p>Implement AnyFS as designed, then (optionally) provide an adapter that implements <code>vfs</code> traits on top of <code>FilesContainer</code>.</p>
<hr>
<h2 id="minimal-example-per-tenant-sqlite-file"><a class="header" href="#minimal-example-per-tenant-sqlite-file">Minimal Example (per-tenant SQLite file)</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs::SqliteBackend;
use anyfs_container::ContainerBuilder;

let tenant_db = "tenant_123.db";

let mut container = ContainerBuilder::new(SqliteBackend::open_or_create(tenant_db)?)
    .max_total_size(100 * 1024 * 1024) // 100 MiB per tenant
    .build()?;

container.create_dir_all("/documents")?;
container.write("/documents/report.pdf", b"...")?;

// Portability: moving/copying the tenant is just moving/copying the DB file.
std::fs::copy(tenant_db, "tenant_123.backup.db")?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Build on existing primitives (<code>strict-path</code>, <code>rusqlite</code>, <code>thiserror</code>), but keep the AnyFS split (traits / backends / container). That combination is what makes the design both ergonomic and hard to misuse.</p>
<p>For a concrete phased rollout, see <code>book/src/implementation/plan.md</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementation-plan"><a class="header" href="#implementation-plan">Implementation Plan</a></h1>
<p>This plan describes a phased rollout of the AnyFS ecosystem:</p>
<ul>
<li><code>anyfs-traits</code>: minimal contract (<code>VfsBackend</code> + core types, re-export <code>VirtualPath</code>)</li>
<li><code>anyfs</code>: built-in backends (feature-gated) + re-exports</li>
<li><code>anyfs-container</code>: <code>FilesContainer&lt;B: VfsBackend&gt;</code> policy layer (limits + feature whitelist)</li>
</ul>
<hr>
<h2 id="phase-1-anyfs-traits-core-contract"><a class="header" href="#phase-1-anyfs-traits-core-contract">Phase 1: <code>anyfs-traits</code> (core contract)</a></h2>
<p><strong>Goal:</strong> Define the stable backend interface and shared types.</p>
<ul>
<li>Re-export <code>strict_path::VirtualPath</code></li>
<li>Define core types (<code>Metadata</code>, <code>Permissions</code>, <code>FileType</code>, <code>DirEntry</code>)</li>
<li>Define <code>VfsError</code> (errors carry <code>VirtualPath</code> where relevant)</li>
<li>Define <code>VfsBackend</code> trait (20 <code>std::fs</code>-aligned, path-based methods)</li>
</ul>
<p><strong>Exit criteria:</strong> <code>anyfs-traits</code> stands alone with minimal dependencies (<code>strict-path</code>, <code>thiserror</code>).</p>
<hr>
<h2 id="phase-2-anyfs-built-in-backends"><a class="header" href="#phase-2-anyfs-built-in-backends">Phase 2: <code>anyfs</code> (built-in backends)</a></h2>
<p><strong>Goal:</strong> Provide a small set of reference/production backends behind Cargo features.</p>
<ul>
<li><code>memory</code> (default): <code>MemoryBackend</code></li>
<li><code>vrootfs</code> (optional): <code>VRootFsBackend</code> using <code>strict_path::VirtualRoot</code> for containment</li>
<li><code>sqlite</code> (optional): <code>SqliteBackend</code> storing an entire filesystem in a single <code>.db</code></li>
</ul>
<p><strong>Exit criteria:</strong> Each backend implements <code>VfsBackend</code> and passes the shared conformance suite.</p>
<hr>
<h2 id="phase-3-anyfs-container-policy--ergonomics"><a class="header" href="#phase-3-anyfs-container-policy--ergonomics">Phase 3: <code>anyfs-container</code> (policy + ergonomics)</a></h2>
<p><strong>Goal:</strong> Provide the user-facing <code>std::fs</code>-aligned API with consistent policy enforcement.</p>
<ul>
<li><code>FilesContainer&lt;B&gt;</code> accepts <code>impl AsRef&lt;Path&gt;</code> for ergonomics</li>
<li>Centralizes path validation: convert once to <code>VirtualPath</code>, then call backend</li>
<li>Enforces limits (quota and structural constraints):
<ul>
<li><code>max_total_size</code></li>
<li><code>max_file_size</code></li>
<li><code>max_node_count</code></li>
<li><code>max_dir_entries</code></li>
<li><code>max_path_depth</code></li>
</ul>
</li>
<li>Implements a least-privilege feature whitelist (default deny):
<ul>
<li><code>symlinks()</code> (+ <code>max_symlink_resolution</code>, default 40)</li>
<li><code>hard_links()</code></li>
<li><code>permissions()</code></li>
</ul>
</li>
</ul>
<p><strong>Exit criteria:</strong> An application can use <code>FilesContainer</code> as a drop-in for common <code>std::fs</code> patterns while gaining quotas + default-deny policy.</p>
<hr>
<h2 id="phase-4-conformance-test-suite"><a class="header" href="#phase-4-conformance-test-suite">Phase 4: Conformance test suite</a></h2>
<p><strong>Goal:</strong> Prevent backend divergence and make semantics explicit.</p>
<p>Recommended structure:</p>
<ul>
<li>Backend conformance tests (run against every <code>VfsBackend</code> implementation)
<ul>
<li><code>read</code>/<code>write</code>/<code>append</code> semantics</li>
<li>directory operations (<code>create_dir*</code>, <code>read_dir</code>, <code>remove_dir*</code>)</li>
<li><code>rename</code> and <code>copy</code> semantics</li>
<li>link behavior (<code>symlink</code>, <code>read_link</code>, <code>hard_link</code>, <code>nlink</code>)</li>
<li>permissions (<code>set_permissions</code>) where meaningful</li>
</ul>
</li>
<li>Container policy tests
<ul>
<li>limit enforcement and usage accounting</li>
<li>whitelist behavior (<code>FeatureNotEnabled</code>)</li>
<li>symlink resolution depth limit (when enabled)</li>
</ul>
</li>
</ul>
<p><strong>Exit criteria:</strong> All built-in backends pass the same suite; container policy tests are backend-agnostic.</p>
<hr>
<h2 id="phase-5-documentation--examples"><a class="header" href="#phase-5-documentation--examples">Phase 5: Documentation + examples</a></h2>
<ul>
<li>Keep <code>book/src/architecture/design-overview.md</code> + <code>book/src/architecture/adrs.md</code> authoritative</li>
<li>Provide at least one complete example per backend</li>
<li>Provide a backend implementer guide for <code>anyfs-traits</code></li>
</ul>
<hr>
<h2 id="future-work-out-of-scope-for-mvp"><a class="header" href="#future-work-out-of-scope-for-mvp">Future work (out of scope for MVP)</a></h2>
<ul>
<li>Streaming I/O (file handles)</li>
<li>Async API</li>
<li>Import/export helpers (host path &lt;-&gt; container path)</li>
<li>Extended attributes</li>
<li>Encryption-at-rest helpers (backend-specific)</li>
<li>Capability negotiation (optional): detect when a backend cannot support certain operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="backend-implementers-guide"><a class="header" href="#backend-implementers-guide">Backend Implementer’s Guide</a></h1>
<p>This guide walks you through implementing a custom AnyFS backend.</p>
<p>If you are writing a backend for other people to consume, depend only on <code>anyfs-backend</code>.</p>
<hr>
<h2 id="what-you-are-implementing"><a class="header" href="#what-you-are-implementing">What you are implementing</a></h2>
<p>A backend implements <code>VfsBackend</code>: a path-based trait aligned with <code>std::fs</code> naming and signatures.</p>
<p>Key properties:</p>
<ul>
<li>Backends accept <code>impl AsRef&lt;Path&gt;</code> for all path parameters (same as std::fs).</li>
<li>The policy layer (<code>anyfs-container</code>) handles quotas/limits and feature whitelisting.</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{DirEntry, Metadata, Permissions, VfsBackend, VfsError};
use std::io::{Read, Write};
use std::path::Path;

pub struct MyBackend {
    // storage fields...
}

impl VfsBackend for MyBackend {
    fn read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn write(&amp;mut self, path: impl AsRef&lt;Path&gt;, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn open_read(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Read + Send&gt;, VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    fn open_write(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Box&lt;dyn Write + Send&gt;, VfsError&gt; {
        let path = path.as_ref();
        todo!()
    }

    // ... implement all methods
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="step-1-pick-a-data-model"><a class="header" href="#step-1-pick-a-data-model">Step 1: Pick a data model</a></h2>
<p>A practical internal model is a small “virtual inode” representation:</p>
<ul>
<li><strong>Directory</strong>: owns a mapping <code>name -&gt; child</code> (or can be derived from a global path index).</li>
<li><strong>File</strong>: points to bytes (inline, blob table, object store key, etc.).</li>
<li><strong>Symlink</strong>: stores a <em>target</em> path (as a string).</li>
<li><strong>Hard links</strong>: multiple paths refer to the same underlying file content.</li>
</ul>
<p>You do not need to expose any of this publicly; it is an implementation detail.</p>
<h3 id="recommended-minimum-metadata"><a class="header" href="#recommended-minimum-metadata">Recommended minimum metadata</a></h3>
<p>Your backend needs enough metadata to populate <code>Metadata</code> and return correct errors:</p>
<ul>
<li>file type (file/dir/symlink)</li>
<li>size</li>
<li>link count (<code>nlink</code>) for hard links</li>
<li>timestamps (optional)</li>
<li>permissions (even if simplified)</li>
</ul>
<hr>
<h2 id="step-2-implement-the-easy-surface-first"><a class="header" href="#step-2-implement-the-easy-surface-first">Step 2: Implement the “easy” surface first</a></h2>
<p>Start with these operations:</p>
<ul>
<li><code>exists</code></li>
<li><code>create_dir</code> / <code>create_dir_all</code></li>
<li><code>read_dir</code></li>
<li><code>write</code> / <code>read</code> / <code>append</code> / <code>read_range</code></li>
<li><code>open_read</code> / <code>open_write</code> (streaming I/O)</li>
<li><code>remove_file</code> / <code>remove_dir</code> / <code>remove_dir_all</code></li>
<li><code>rename</code> / <code>copy</code></li>
</ul>
<p>Guidelines:</p>
<ul>
<li>You receive <code>impl AsRef&lt;Path&gt;</code> - call <code>.as_ref()</code> to get <code>&amp;Path</code>.</li>
<li>Match <code>std::fs</code>-like error expectations:
<ul>
<li>creating an existing directory should return <code>AlreadyExists</code></li>
<li><code>remove_dir</code> should fail on non-empty directories</li>
<li><code>remove_file</code> should fail on directories</li>
</ul>
</li>
</ul>
<hr>
<h2 id="step-3-links-symlinks--hard-links"><a class="header" href="#step-3-links-symlinks--hard-links">Step 3: Links (symlinks + hard links)</a></h2>
<p>AnyFS includes link methods in the core trait.</p>
<h3 id="symlinks"><a class="header" href="#symlinks">Symlinks</a></h3>
<ul>
<li><code>symlink(original, link)</code> creates a symlink at <code>link</code> whose target is <code>original</code>.</li>
<li><code>read_link(path)</code> returns the stored target.</li>
<li><code>symlink_metadata(path)</code> returns metadata about the symlink itself (not the target).</li>
</ul>
<p>Note: <code>anyfs-container</code> may deny symlink operations unless explicitly enabled (least privilege).</p>
<h3 id="hard-links-1"><a class="header" href="#hard-links-1">Hard links</a></h3>
<ul>
<li><code>hard_link(original, link)</code> creates a second directory entry pointing at the same underlying file.</li>
<li>Update <code>nlink</code> and any reference-counting you maintain.</li>
<li><code>remove_file</code> decrements link count and only deletes the underlying content when it reaches zero.</li>
</ul>
<hr>
<h2 id="step-4-permissions"><a class="header" href="#step-4-permissions">Step 4: Permissions</a></h2>
<p>AnyFS models permissions as a minimal type (<code>Permissions</code>) to keep the cross-platform story simple.</p>
<ul>
<li><code>set_permissions</code> should mutate the stored permissions.</li>
<li>Backends may implement stricter semantics internally, but the API stays small.</li>
</ul>
<p>As with links, <code>anyfs-container</code> may deny permission mutation unless enabled.</p>
<hr>
<h2 id="step-5-error-mapping"><a class="header" href="#step-5-error-mapping">Step 5: Error mapping</a></h2>
<p>Backends should return <code>VfsError</code> variants that are meaningful to callers.</p>
<p>Recommended principles:</p>
<ul>
<li>Prefer structured variants like <code>NotFound(String)</code> over generic errors.</li>
<li>Keep backend-specific errors available (e.g., <code>VfsError::Backend(String)</code>) but do not leak host paths when possible.</li>
</ul>
<hr>
<h2 id="step-6-validate-with-a-conformance-suite"><a class="header" href="#step-6-validate-with-a-conformance-suite">Step 6: Validate with a conformance suite</a></h2>
<p>Backends drift without tests.</p>
<p>A useful conformance suite includes:</p>
<ul>
<li>directory creation/removal edge cases</li>
<li><code>rename</code> semantics for files vs directories</li>
<li>symlink metadata vs metadata-following behavior</li>
<li>hard link link-count accounting</li>
<li>copy semantics (copy follows symlinks)</li>
</ul>
<p>See <code>book/src/implementation/plan.md</code> for the recommended test breakdown.</p>
<hr>
<h2 id="checklist"><a class="header" href="#checklist">Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Depends only on <code>anyfs-backend</code></li>
<li><input disabled="" type="checkbox"> Implements all <code>VfsBackend</code> methods (including streaming I/O)</li>
<li><input disabled="" type="checkbox"> Returns correct <code>std::fs</code>-like errors</li>
<li><input disabled="" type="checkbox"> Symlinks store target paths as strings</li>
<li><input disabled="" type="checkbox"> Hard links update <code>nlink</code> and share content</li>
<li><input disabled="" type="checkbox"> Conformance suite passes</li>
</ul>
<hr>
<p>For the trait definition, see <code>book/src/traits/vfs-trait.md</code>.</p>
<hr>
<h2 id="note-on-vrootfsbackend-1"><a class="header" href="#note-on-vrootfsbackend-1">Note on VRootFsBackend</a></h2>
<p>If you are implementing a backend that wraps a <strong>real host filesystem directory</strong>, consider using <code>strict-path::VirtualPath</code> and <code>strict-path::VirtualRoot</code> internally for path containment. This is what <code>VRootFsBackend</code> does—it ensures paths cannot escape the designated root directory.</p>
<p>This is an implementation choice for filesystem-based backends, not a requirement of the <code>VfsBackend</code> trait.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--full-architecture--design-review-historical-graph-store-design"><a class="header" href="#anyfs--full-architecture--design-review-historical-graph-store-design">AnyFS — Full Architecture &amp; Design Review (Historical: Graph-Store Design)</a></h1>
<blockquote>
<p>This review covers an earlier (rejected) design iteration that modeled the backend as a transactional graph store (<code>NodeId</code>/<code>Edge</code>/chunks).</p>
<p>The current AnyFS design is path-based (<code>VfsBackend</code> with 20 <code>std::fs</code>-aligned methods). For current decisions see:</p>
<ul>
<li><code>book/src/architecture/adrs.md</code> (especially ADR-001)</li>
<li><code>book/src/architecture/design-overview.md</code></li>
</ul>
</blockquote>
<p><strong>Review Date:</strong> 2025-12-22<br><strong>Project:</strong> VFS Container<br><strong>Scope:</strong> Architecture, data model, API surface, backend design, security model, documentation consistency<br><strong>Overall Status:</strong> ✅ <em>Conditionally approved</em> (implementation can begin <strong>after</strong> resolving the critical items below)</p>
<hr>
<h2 id="0-documents-reviewed"><a class="header" href="#0-documents-reviewed">0. Documents Reviewed</a></h2>
<ul>
<li><code>README.md</code></li>
<li><code>01-executive-summary.md</code></li>
<li><code>02-api-quick-reference.md</code></li>
<li><code>03-backend-implementers-guide.md</code></li>
<li><code>04-architecture-decision-records.md</code></li>
<li><code>05-getting-started-guide.md</code></li>
<li><code>06-comparison-and-positioning.md</code></li>
<li><code>08-technical-comparison-with-alternatives.md</code></li>
<li><code>09-build-vs-reuse-analysis.md</code></li>
<li><code>anyfs-container-design.md</code></li>
</ul>
<hr>
<h2 id="1-executive-summary"><a class="header" href="#1-executive-summary">1. Executive Summary</a></h2>
<p>The core architectural direction is strong: <strong>filesystem semantics live in <code>FilesContainer</code></strong>, while the storage layer is a <strong>typed graph store</strong> (<code>NodeId</code> + <code>Edge</code> + chunk store), guarded by <strong>mandatory transactions</strong> and <strong>lexical-only virtual path normalization</strong>.</p>
<p>This gives you the right primitives for:</p>
<ul>
<li>safe directory renames/moves (without path-as-key issues),</li>
<li>hard links (multiple edges to the same node),</li>
<li>strict escape prevention (virtual paths are not host-resolved),</li>
<li>and predictable multi-tenant enforcement (capacity + optional permission checks in the core).</li>
</ul>
<p>However, several critical gaps must be resolved <strong>before</strong> implementation, because they affect feasibility and correctness across all backends:</p>
<ol>
<li>the docs currently contain <strong>two competing backend trait designs</strong>,</li>
<li>the FS backend is <strong>underspecified</strong> (what it is, and how it can satisfy the graph trait),</li>
<li>the story for large-file I/O, quotas, and import/export semantics needs explicit decisions.</li>
</ol>
<hr>
<h2 id="2-strategic-strengths-keep-these"><a class="header" href="#2-strategic-strengths-keep-these">2. Strategic Strengths (Keep These)</a></h2>
<h3 id="21-clean-separation-of-concerns"><a class="header" href="#21-clean-separation-of-concerns">2.1 Clean separation of concerns</a></h3>
<ul>
<li>The ADRs clearly define a backend that knows nothing about paths/symlinks/permissions; it’s just a typed graph store with chunk IO.</li>
<li>This is a great boundary for safety and testability.</li>
</ul>
<h3 id="22-lexical-path-normalization-is-a-strong-security-primitive"><a class="header" href="#22-lexical-path-normalization-is-a-strong-security-primitive">2.2 Lexical path normalization is a strong security primitive</a></h3>
<ul>
<li>Your <code>VirtualPath</code> rules (collapse <code>//</code>, eliminate <code>.</code>, resolve <code>..</code> lexically, never escape root) eliminate a large class of path traversal bugs at the type level.</li>
</ul>
<h3 id="23-mandatory-transactions-are-the-right-default"><a class="header" href="#23-mandatory-transactions-are-the-right-default">2.3 Mandatory transactions are the right default</a></h3>
<ul>
<li>The “all mutations must happen inside <code>transact()</code>” decision makes multi-step ops crash-safe by construction.</li>
<li>This also prevents “forgot to wrap in a transaction” corruption.</li>
</ul>
<h3 id="24-opt-in-feature-model-reduces-mvp-risk"><a class="header" href="#24-opt-in-feature-model-reduces-mvp-risk">2.4 Opt-in feature model reduces MVP risk</a></h3>
<ul>
<li>Symlinks / hard links / permissions / xattrs are explicitly feature-gated.</li>
<li>This avoids implementing complex semantics accidentally for every user.</li>
</ul>
<hr>
<h2 id="3-critical-findings-must-fix"><a class="header" href="#3-critical-findings-must-fix">3. Critical Findings (Must Fix)</a></h2>
<h3 id="cf-1--competing-backend-trait-designs-across-docs"><a class="header" href="#cf-1--competing-backend-trait-designs-across-docs">CF-1 — <strong>Competing backend trait designs across docs</strong></a></h3>
<p><strong>Severity:</strong> Critical (design/implementation ambiguity)</p>
<p><strong>What’s happening</strong></p>
<ul>
<li><code>anyfs-container-design.md</code> + ADRs define the backend as a <strong>graph store</strong> with <code>transact()</code> and <code>snapshot()</code> and node/edge/chunk primitives.</li>
<li><code>08-technical-comparison-with-alternatives.md</code> shows a “StorageBackend (MVP Design)” that starts as <strong>direct path-based operations</strong> (<code>exists(path)</code>, <code>read(path)</code>, <code>write(path, ...)</code>, etc.), and then later in the same section also shows Snapshot/Transaction methods.</li>
</ul>
<p><strong>Why this matters</strong></p>
<ul>
<li>Whether a backend is “path-based” vs “NodeId graph store” completely changes feasibility for FS, SQLite, conformance tests, and invariants.</li>
<li>This also confuses reviewers and implementers (and will lead to the wrong backend being built).</li>
</ul>
<p><strong>Required action</strong></p>
<ul>
<li>Declare <strong>one</strong> design as authoritative (recommended: the ADR + <code>anyfs-container-design.md</code> graph-store trait).</li>
<li>Update or remove the “direct operations” trait definition from <code>08-technical-comparison-with-alternatives.md</code>.</li>
<li>Add a prominent note in <code>README.md</code> that ADRs are the source of truth.</li>
</ul>
<p><strong>Acceptance criteria</strong></p>
<ul>
<li>There is exactly <strong>one</strong> “StorageBackend trait” definition across the entire doc set.</li>
</ul>
<hr>
<h3 id="cf-2--fsbackend-is-underspecified--ambiguous"><a class="header" href="#cf-2--fsbackend-is-underspecified--ambiguous">CF-2 — <strong>FsBackend is underspecified / ambiguous</strong></a></h3>
<p><strong>Severity:</strong> High (feasibility risk)</p>
<p><strong>What’s happening</strong></p>
<ul>
<li>The design mentions a <code>vfs-fs</code> crate implemented “via strict-path” and that it “inherits host filesystem permissions”.</li>
<li>But there is no concrete spec for how a path-based host filesystem can satisfy a <strong>NodeId/Edge graph</strong> API.</li>
</ul>
<p><strong>There are two different possible meanings</strong></p>
<ol>
<li><strong>“Adapter backend”</strong> over a normal directory tree
<ul>
<li>Requires a persistent mapping: <code>NodeId ↔ HostPath</code> (and stable identity across restarts).</li>
<li>Must define how rename/hardlink/symlink map to host semantics.</li>
</ul>
</li>
<li><strong>“Graph store implemented on host FS”</strong> (host FS used only as bytes+directory persistence)
<ul>
<li>Node/edge/content records are stored in an internal layout keyed by NodeId/ContentId.</li>
<li>This <em>can</em> satisfy the trait without an external DB — but it’s not a “native filesystem adapter”.</li>
</ul>
</li>
</ol>
<p><strong>Required action</strong>
Pick one and document it explicitly:</p>
<ul>
<li><strong>Option A (Recommended for MVP):</strong> Remove <code>vfs-fs</code> from MVP scope; use only SQLite + memory.</li>
<li><strong>Option B:</strong> Make <code>vfs-fs</code> a <strong>graph-store-on-FS</strong> (internal layout), explicitly NOT a transparent adapter.</li>
<li><strong>Option C:</strong> Make <code>vfs-fs</code> an <strong>adapter backend</strong> and require a sidecar index (SQLite or metadata files) to preserve identity.</li>
</ul>
<p><strong>Acceptance criteria</strong></p>
<ul>
<li>The docs explain which option you chose and include:
<ul>
<li>how NodeId persistence works,</li>
<li>what happens on restart,</li>
<li>what semantics are supported / not supported,</li>
<li>how import/export differs from FsBackend (if FsBackend remains).</li>
</ul>
</li>
</ul>
<hr>
<h3 id="cf-3--directory-rename-safety-avoid-cycles-is-not-specified"><a class="header" href="#cf-3--directory-rename-safety-avoid-cycles-is-not-specified">CF-3 — <strong>Directory rename safety (avoid cycles) is not specified</strong></a></h3>
<p><strong>Severity:</strong> High (correctness + potential corruption)</p>
<p>A graph-based filesystem must forbid renaming a directory into its own subtree (e.g., <code>/a</code> → <code>/a/b/a</code>), which would create a cycle.</p>
<p><strong>Required action</strong></p>
<ul>
<li>Add a formal invariant: the directory graph must remain acyclic (a tree rooted at NodeId(1), unless hard links are enabled — and even then, directory hard links are disallowed).</li>
<li>Define the algorithm/check for <code>rename()</code>:
<ul>
<li>when moving a directory, ensure destination parent is not a descendant of the source directory.</li>
</ul>
</li>
<li>Add conformance tests for this behavior.</li>
</ul>
<p><strong>Acceptance criteria</strong></p>
<ul>
<li>Rename into subtree returns a deterministic error.</li>
<li>Conformance tests include at least:
<ul>
<li>rename dir into its subtree,</li>
<li>rename across dirs with existing target,</li>
<li>rename file over file (if allowed/forbidden—must be decided).</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-high-priority-findings-should-fix-before-mvp"><a class="header" href="#4-high-priority-findings-should-fix-before-mvp">4. High Priority Findings (Should Fix Before MVP)</a></h2>
<h3 id="hp-1--large-file-story-is-inconsistent-with-aiml-use-case"><a class="header" href="#hp-1--large-file-story-is-inconsistent-with-aiml-use-case">HP-1 — Large-file story is inconsistent with “AI/ML use case”</a></h3>
<p><strong>Severity:</strong> Medium/High (product positioning vs API design)</p>
<ul>
<li>Executive summary cites AI/ML use cases, but the core API is “bulk bytes” (<code>Vec&lt;u8&gt;</code>) with streaming deferred.</li>
<li>You <em>do</em> have <code>read_range()</code>, and the internal model is chunked (64KB), so large files aren’t impossible — but ergonomics and memory behavior are not good for multi-GB workloads.</li>
</ul>
<p><strong>Recommended action</strong>
Choose one:</p>
<ul>
<li><strong>A:</strong> Explicitly downgrade AI/ML positioning in <code>01-executive-summary.md</code> until streaming exists.</li>
<li><strong>B:</strong> Add a small streaming façade early (e.g., <code>open_read/open_write</code> returning <code>Read/Write</code>) as a supported “phase 2”.</li>
</ul>
<p>Also note: if SQLite is the primary backend, <code>rusqlite</code> supports incremental blob I/O (with the <code>blob</code> feature), which can make streaming practical without changing the on-disk model.</p>
<hr>
<h3 id="hp-2--concurrency-model-needs-an-explicit-contract"><a class="header" href="#hp-2--concurrency-model-needs-an-explicit-contract">HP-2 — Concurrency model needs an explicit contract</a></h3>
<p><strong>Severity:</strong> Medium</p>
<p>The docs say “backend decides” regarding concurrency, but:</p>
<ul>
<li><code>StorageBackend::transact(&amp;mut self, ...)</code> implies exclusive mutable access,</li>
<li>and <code>FilesContainer</code> methods are largely <code>&amp;mut self</code> for writes.</li>
</ul>
<p>This can still be fine, but it needs to be stated clearly.</p>
<p><strong>Recommended action</strong>
Document the concurrency contract explicitly:</p>
<ul>
<li>MVP: <code>FilesContainer</code> is <em>not</em> intended to be shared concurrently without external synchronization.</li>
<li>Recommended pattern: <code>Arc&lt;Mutex&lt;FilesContainer&lt;B&gt;&gt;&gt;</code> for multi-threaded servers.</li>
<li>Backends may have internal locking (SQLite does), but the container API still requires coherent external access.</li>
</ul>
<hr>
<h3 id="hp-3--quotausage-accounting--hard-links-needs-a-correctness-spec"><a class="header" href="#hp-3--quotausage-accounting--hard-links-needs-a-correctness-spec">HP-3 — Quota/usage accounting + hard links needs a correctness spec</a></h3>
<p><strong>Severity:</strong> Medium/High (multi-tenant safety)</p>
<p>Capacity limits are a core differentiator (<code>usage()</code>, <code>remaining()</code>, enforcement points), but correctness becomes tricky with:</p>
<ul>
<li>hard links (multiple directory entries pointing at the same node/content),</li>
<li>copy semantics (open question: preserve hard links or not),</li>
<li>and delete/content GC.</li>
</ul>
<p><strong>Recommended action</strong>
Add explicit accounting rules:</p>
<ul>
<li>Is <code>total_size</code> based on logical file sizes per node, or physical bytes per content_id?</li>
<li>When two nodes share the same content via hard links, how is usage computed?</li>
<li>What exactly triggers <code>delete_content(content_id)</code>?</li>
</ul>
<p>Add tests for:</p>
<ul>
<li>create hard link → usage unchanged,</li>
<li>delete one link → usage unchanged,</li>
<li>delete last link → usage decreases and content removed.</li>
</ul>
<hr>
<h2 id="5-medium-priority-findings-good-to-fix-early"><a class="header" href="#5-medium-priority-findings-good-to-fix-early">5. Medium Priority Findings (Good to Fix Early)</a></h2>
<h3 id="mp-1--importexport-semantics-and-threat-model-are-underspecified"><a class="header" href="#mp-1--importexport-semantics-and-threat-model-are-underspecified">MP-1 — Import/Export semantics and threat model are underspecified</a></h3>
<p>Import/export is a big attack surface:</p>
<ul>
<li>symlinks on host (follow vs preserve),</li>
<li>special files (devices, FIFOs),</li>
<li>resource exhaustion (deep trees, huge file counts),</li>
<li>and <strong>non-UTF-8 filenames</strong> on Linux / Windows path semantics (your VirtualPath is a <code>String</code>).</li>
</ul>
<p><strong>Recommended action</strong>
Define an import/export policy section:</p>
<ul>
<li>filename encoding policy (reject? lossy mapping? base64 escape?),</li>
<li>whether to follow host symlinks,</li>
<li>whether to preserve metadata (timestamps/perms/xattrs),</li>
<li>limits applied during import (max depth, max nodes, total bytes).</li>
</ul>
<hr>
<h3 id="mp-2--extended-attributes-enforce-limits-and-avoid-heavy-reads"><a class="header" href="#mp-2--extended-attributes-enforce-limits-and-avoid-heavy-reads">MP-2 — Extended attributes: enforce limits and avoid heavy reads</a></h3>
<p>You state xattrs are opt-in, and open questions recommend “64KB per attr”, but:</p>
<ul>
<li><code>CapacityLimits</code> doesn’t include xattr size/count limits,</li>
<li><code>NodeMetadata</code> contains a full <code>HashMap&lt;String, Vec&lt;u8&gt;&gt;</code>, which can become heavy if <code>get_node()</code> always returns it.</li>
</ul>
<p><strong>Recommended action</strong></p>
<ul>
<li>Add <code>max_xattr_value_size</code>, <code>max_xattr_total_size</code>, <code>max_xattr_count</code> to limits/config.</li>
<li>Clarify whether backends must return xattrs as part of NodeRecord always, or if xattr access is separate.</li>
</ul>
<hr>
<h3 id="mp-3--doc-numbering--toc-drift"><a class="header" href="#mp-3--doc-numbering--toc-drift">MP-3 — Doc numbering / TOC drift</a></h3>
<p><code>anyfs-container-design.md</code> has numbering inconsistencies:</p>
<ul>
<li>TOC points to “14. Open Questions” but the header is “15. Open Questions”.</li>
<li>“15. Open Questions” and “15. Future Considerations” both exist.</li>
<li>The “Open Questions” subsections are numbered “14.x”.</li>
</ul>
<p><strong>Recommended action</strong></p>
<ul>
<li>Fix TOC and headings, and ensure anchors match.</li>
<li>Add a “Docs are generated / do not edit anchors manually” note if applicable.</li>
</ul>
<hr>
<h2 id="6-backend-specific-notes"><a class="header" href="#6-backend-specific-notes">6. Backend-Specific Notes</a></h2>
<h3 id="61-sqlite-backend"><a class="header" href="#61-sqlite-backend">6.1 SQLite backend</a></h3>
<ul>
<li>Schema versioning exists — define migration approach (forward-only? breaking changes?).</li>
<li>WAL mode is recommended; explicitly document it as default for crash safety.</li>
<li>Add an index strategy for edges/chunks if performance matters (directory listing + partial reads).</li>
</ul>
<h3 id="62-memory-backend"><a class="header" href="#62-memory-backend">6.2 Memory backend</a></h3>
<p>The implementer guide provides a minimal snapshot-by-clone approach. That’s fine as a reference, but call it out explicitly as “for tests only”.</p>
<p><strong>Recommended “production memory backend” approach</strong></p>
<ul>
<li>diff/journal transaction (record mutations; apply on commit; discard on rollback),</li>
<li>or copy-on-write with structural sharing (if you want immutability).</li>
</ul>
<h3 id="63-fs-backend-if-kept"><a class="header" href="#63-fs-backend-if-kept">6.3 Fs backend (if kept)</a></h3>
<p>After resolving CF-2, add conformance test scope:</p>
<ul>
<li>which operations are guaranteed identical to SQLite,</li>
<li>what is intentionally different (permissions inheritance, xattrs, timestamps, etc.).</li>
</ul>
<hr>
<h2 id="7-required-decisions-put-in-one-place"><a class="header" href="#7-required-decisions-put-in-one-place">7. Required Decisions (Put in One Place)</a></h2>
<ol>
<li><strong>Backend trait:</strong> graph-store only (recommended) vs direct path ops</li>
<li><strong>FsBackend meaning:</strong> remove vs adapter vs graph-store-on-FS</li>
<li><strong>Large file I/O:</strong> keep <code>read_range</code> only vs add <code>open_read/open_write</code></li>
<li><strong>Concurrency:</strong> single-threaded by design vs documented external locking pattern</li>
<li><strong>Quota accounting:</strong> logical vs physical bytes with hard links</li>
<li><strong>Import/export policy:</strong> encoding, symlink behavior, special files, metadata preservation</li>
<li><strong>Xattr limits:</strong> sizes/counts and how they’re stored/retrieved</li>
</ol>
<hr>
<h2 id="8-acceptance-checklist-for-full-approval"><a class="header" href="#8-acceptance-checklist-for-full-approval">8. Acceptance Checklist for “Full Approval”</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Only one authoritative backend trait definition across all docs</li>
<li><input disabled="" type="checkbox"> FsBackend scope/semantics are explicit (or removed from MVP)</li>
<li><input disabled="" type="checkbox"> Rename directory cycle prevention spec + tests exist</li>
<li><input disabled="" type="checkbox"> Quota accounting rules are specified and tested (incl. hard links)</li>
<li><input disabled="" type="checkbox"> Import/export threat model + policies are documented</li>
<li><input disabled="" type="checkbox"> Xattr size/count limits are defined and enforced</li>
<li><input disabled="" type="checkbox"> Design doc numbering/TOC is corrected</li>
<li><input disabled="" type="checkbox"> Conformance tests pass for SQLite + memory backends</li>
</ul>
<hr>
<h2 id="9-recommended-next-steps-practical-order"><a class="header" href="#9-recommended-next-steps-practical-order">9. Recommended Next Steps (Practical Order)</a></h2>
<ol>
<li><strong>Docs first:</strong> choose authoritative trait + fix doc drift (CF-1)</li>
<li><strong>Define FsBackend decision</strong> (CF-2)</li>
<li><strong>Specify rename invariants</strong> + write tests (CF-3)</li>
<li>Implement SQLite backend (MVP core) + conformance suite</li>
<li>Implement memory backend (reference) + add a “production strategy” section</li>
<li>Decide large-file plan and update positioning docs</li>
<li>Lock down import/export and xattr policies</li>
</ol>
<hr>
<p><em>End of review.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="addendum--sqlite-as-container-format-vs-custom-binary-format-historical"><a class="header" href="#addendum--sqlite-as-container-format-vs-custom-binary-format-historical">Addendum — SQLite as Container Format vs Custom Binary Format (Historical)</a></h1>
<blockquote>
<p>This addendum was written during the earlier graph-store design iteration. The SQLite-vs-binary tradeoffs are still relevant, but references to <code>StorageBackend</code>/transactions reflect that older architecture.</p>
<p>For the current AnyFS design (path-based <code>VfsBackend</code>), see:</p>
<ul>
<li><code>book/src/architecture/adrs.md</code> (especially ADR-001)</li>
<li><code>book/src/architecture/design-overview.md</code></li>
</ul>
</blockquote>
<p><strong>Date:</strong> 2025-12-22<br><strong>Project:</strong> VFS Container<br><strong>Purpose:</strong> Put the SQLite-vs-binary tradeoffs “on record”, clarify the <em>backend separation</em> user story, and propose a practical path forward (including a “stop / proceed” decision gate).</p>
<hr>
<h2 id="1-problem-statement"><a class="header" href="#1-problem-statement">1. Problem Statement</a></h2>
<p>We need to decide (and document) whether the VFS Container’s primary persistent format should be:</p>
<ol>
<li><strong>SQLite-backed container</strong> (metadata + content stored as tables / blobs / chunks), or</li>
<li><strong>A custom binary container format</strong> (a bespoke file layout for metadata + content).</li>
</ol>
<p>The decision impacts:</p>
<ul>
<li>durability &amp; crash consistency,</li>
<li>performance characteristics,</li>
<li>ability to query/search/visualize containers,</li>
<li>ecosystem/tooling,</li>
<li>maintainability and long-term evolution.</li>
</ul>
<hr>
<h2 id="2-why-backend-separation-matters-user-story-on-record"><a class="header" href="#2-why-backend-separation-matters-user-story-on-record">2. Why Backend Separation Matters (User Story “On Record”)</a></h2>
<h3 id="21-core-principle"><a class="header" href="#21-core-principle">2.1. Core principle</a></h3>
<p>The container should express <strong>filesystem semantics</strong> in one place (<code>FilesContainer</code>), and allow <strong>multiple storage strategies</strong> via a backend abstraction (<code>StorageBackend</code>).</p>
<h3 id="22-user-story-sqlite-for-dashboardanalytics-vs-other-backends-for-other-goals"><a class="header" href="#22-user-story-sqlite-for-dashboardanalytics-vs-other-backends-for-other-goals">2.2. User story: SQLite for dashboard/analytics vs other backends for other goals</a></h3>
<blockquote>
<p><strong>As an integrator</strong>, I want to store my virtual filesystem in <strong>SQLite</strong> so I can build dashboards, inspections, and analytics directly using existing SQLite drivers and tools (GUI viewers, SQL queries, reporting pipelines) without writing a custom parser.</p>
</blockquote>
<blockquote>
<p><strong>As another integrator</strong>, I want a different backend that optimizes for my use case (e.g., memory-only testing, cloud object-store persistence, encrypted-at-rest backend, compressed backend, embedded key-value backend), while still using the same <code>FilesContainer</code> semantics and API.</p>
</blockquote>
<h3 id="23-implication"><a class="header" href="#23-implication">2.3. Implication</a></h3>
<p>The backend interface must be:</p>
<ul>
<li>stable enough to support multiple implementations,</li>
<li>strict enough to preserve filesystem invariants,</li>
<li>and clear about what is “backend responsibility” vs “container responsibility”.</li>
</ul>
<hr>
<h2 id="3-sqlite-backed-container--advantages-put-on-record"><a class="header" href="#3-sqlite-backed-container--advantages-put-on-record">3. SQLite-backed Container — Advantages (Put on Record)</a></h2>
<h3 id="31-acid-transactions-and-crash-safety"><a class="header" href="#31-acid-transactions-and-crash-safety">3.1. ACID transactions and crash safety</a></h3>
<ul>
<li>Mature transactional semantics.</li>
<li>WAL/journaling patterns are known, tested, and widely deployed.</li>
<li>You can get strong “don’t corrupt on crash” behavior early.</li>
</ul>
<h3 id="32-queryability-and-observability-major-differentiator"><a class="header" href="#32-queryability-and-observability-major-differentiator">3.2. Queryability and observability (major differentiator)</a></h3>
<ul>
<li>Search and filtering over metadata (names, sizes, timestamps, tags, hashes) via indexes.</li>
<li>Supports “dashboard-style” use cases naturally:
<ul>
<li>auditing (“show me recently changed files”),</li>
<li>inventory (“largest directories”, “most common extensions”),</li>
<li>compliance (“files missing required metadata”),</li>
<li>operations (“who created what/when”, if you store event logs).</li>
</ul>
</li>
</ul>
<h3 id="33-ecosystem-tooling-and-interoperability"><a class="header" href="#33-ecosystem-tooling-and-interoperability">3.3. Ecosystem tooling and interoperability</a></h3>
<ul>
<li>File is inspectable with mature tools (CLI, GUIs).</li>
<li>Easy to build “support tools” (inspect/repair/export) quickly.</li>
<li>Backups are a known problem with known solutions (online backup APIs, file copying with appropriate locking, etc).</li>
</ul>
<h3 id="34-schema-constraints-and-basic-integrity-enforcement"><a class="header" href="#34-schema-constraints-and-basic-integrity-enforcement">3.4. Schema constraints and basic integrity enforcement</a></h3>
<ul>
<li>Foreign keys, unique constraints, and checks can prevent some corruption classes.</li>
<li>Even if not sufficient for all filesystem invariants, they reduce the “custom format bug surface”.</li>
</ul>
<h3 id="35-incremental-io-is-possible"><a class="header" href="#35-incremental-io-is-possible">3.5. Incremental I/O is possible</a></h3>
<ul>
<li>With the right layout, reads/writes can be incremental (important for large files).</li>
<li>This lets you evolve toward streaming APIs later without changing the persistence substrate.</li>
</ul>
<hr>
<h2 id="4-sqlite-backed-container--disadvantages--risks-put-on-record"><a class="header" href="#4-sqlite-backed-container--disadvantages--risks-put-on-record">4. SQLite-backed Container — Disadvantages / Risks (Put on Record)</a></h2>
<h3 id="41-write-amplification-and-overhead"><a class="header" href="#41-write-amplification-and-overhead">4.1. Write amplification and overhead</a></h3>
<ul>
<li>Small writes can touch multiple pages + indexes + WAL.</li>
<li>Chunk-per-64KB design can create many rows and add overhead.</li>
</ul>
<h3 id="42-filesystem-invariants-are-not-pure-sql"><a class="header" href="#42-filesystem-invariants-are-not-pure-sql">4.2. Filesystem invariants are not “pure SQL”</a></h3>
<p>SQLite cannot naturally enforce all the rules you care about:</p>
<ul>
<li>directory graph acyclicity,</li>
<li>rename rules (prevent rename into own subtree),</li>
<li>hard-link and GC correctness,</li>
<li>transactional quota accounting.</li>
</ul>
<p>You’ll still need application-level checks (or complex triggers—usually not worth it).</p>
<h3 id="43-dashboard-access-can-become-a-footgun"><a class="header" href="#43-dashboard-access-can-become-a-footgun">4.3. “Dashboard access” can become a footgun</a></h3>
<p>If you encourage external tools to open the container database:</p>
<ul>
<li>schema becomes a public contract (breaking it breaks dashboards),</li>
<li>direct writes can corrupt invariants,</li>
<li>migrations need careful versioning.</li>
</ul>
<h3 id="44-concurrency-model-limitations"><a class="header" href="#44-concurrency-model-limitations">4.4. Concurrency model limitations</a></h3>
<ul>
<li>Many readers + one writer is fine; many writers is not.</li>
<li>For multi-process or network-share access, locking semantics become a support risk.</li>
</ul>
<h3 id="45-encryptioncompression-are-not-native"><a class="header" href="#45-encryptioncompression-are-not-native">4.5. Encryption/compression are not native</a></h3>
<ul>
<li>Requires external solutions (e.g., SQLCipher) or application-layer encryption.</li>
<li>Compression is usually implemented at the chunk layer (which is doable, but extra complexity).</li>
</ul>
<hr>
<h2 id="5-custom-binary-container--advantages-put-on-record"><a class="header" href="#5-custom-binary-container--advantages-put-on-record">5. Custom Binary Container — Advantages (Put on Record)</a></h2>
<h3 id="51-performance-and-layout-control"><a class="header" href="#51-performance-and-layout-control">5.1. Performance and layout control</a></h3>
<ul>
<li>You can optimize for sequential I/O and specific access patterns.</li>
<li>Lower overhead for tight loops, heavy write workloads, and large streaming reads.</li>
</ul>
<h3 id="52-tailored-features-are-easier-to-bake-in"><a class="header" href="#52-tailored-features-are-easier-to-bake-in">5.2. Tailored features are easier to “bake in”</a></h3>
<ul>
<li>Content-addressing, checksums, compression, encryption, snapshots, refcounts, and GC can be first-class from day 1 (if you implement them).</li>
</ul>
<h3 id="53-simple-external-api-surface-sometimes"><a class="header" href="#53-simple-external-api-surface-sometimes">5.3. Simple external API surface (sometimes)</a></h3>
<ul>
<li>If you make a stable binary format with a clear spec, external consumers can implement readers.</li>
<li>But this is only true if you maintain the spec rigorously.</li>
</ul>
<hr>
<h2 id="6-custom-binary-container--disadvantages--risks-put-on-record"><a class="header" href="#6-custom-binary-container--disadvantages--risks-put-on-record">6. Custom Binary Container — Disadvantages / Risks (Put on Record)</a></h2>
<h3 id="61-you-must-build-durability-and-recovery-yourself"><a class="header" href="#61-you-must-build-durability-and-recovery-yourself">6.1. You must build durability and recovery yourself</a></h3>
<ul>
<li>Crash safety, partial writes, journaling/WAL/CoW, and integrity checks become your job.</li>
<li>The “format bug surface” is large and long-lived.</li>
</ul>
<h3 id="62-tooling-and-interoperability-cost"><a class="header" href="#62-tooling-and-interoperability-cost">6.2. Tooling and interoperability cost</a></h3>
<ul>
<li>Every “dashboard” or query tool needs a custom parser or library.</li>
<li>Debugging/support is harder (you can’t just open it in a DB browser).</li>
</ul>
<h3 id="63-migrationversioning-complexity"><a class="header" href="#63-migrationversioning-complexity">6.3. Migration/versioning complexity</a></h3>
<ul>
<li>Any format evolution becomes a careful compatibility exercise.</li>
<li>You’ll need robust upgrade paths (and possibly dual readers/writers).</li>
</ul>
<hr>
<h2 id="7-recommended-path-forward-if-we-should-move-forward"><a class="header" href="#7-recommended-path-forward-if-we-should-move-forward">7. Recommended Path Forward (If We Should Move Forward)</a></h2>
<h3 id="71-recommendation-proceed-with-sqlite-first-but-formalize-the-separation"><a class="header" href="#71-recommendation-proceed-with-sqlite-first-but-formalize-the-separation">7.1. Recommendation: proceed with SQLite-first, but formalize the separation</a></h3>
<p>Proceed with SQLite as the <strong>primary</strong> persistent backend for v1, because it:</p>
<ul>
<li>minimizes “storage correctness” risk early,</li>
<li>enables dashboard/query value quickly,</li>
<li>supports your stated multi-tenant and portability goals.</li>
</ul>
<p>But do it in a way that keeps the door open for a custom format later.</p>
<h3 id="72-decision-gate-should-we-move-forward"><a class="header" href="#72-decision-gate-should-we-move-forward">7.2. Decision gate: “should we move forward?”</a></h3>
<p>Move forward <strong>only if</strong> the team agrees to the following constraints:</p>
<ol>
<li><strong>SQLite is the MVP persistence substrate</strong>
<ul>
<li>No parallel custom format in MVP.</li>
</ul>
</li>
<li><strong>The backend interface remains a strict semantic boundary</strong>
<ul>
<li>Filesystem semantics (rename rules, path normalization, feature flags) stay in <code>FilesContainer</code>.</li>
</ul>
</li>
<li><strong>Schema becomes an explicit contract</strong>
<ul>
<li>Versioned schema, migration policy, “read-only external access recommended”.</li>
</ul>
</li>
<li><strong>We decide how dashboards access data safely</strong>
<ul>
<li>Prefer read-only connections and/or a stable “views” layer.</li>
</ul>
</li>
</ol>
<p>If these aren’t acceptable, don’t proceed until the format decision is resolved.</p>
<hr>
<h2 id="8-concrete-suggestions-to-make-sqlite-shine-and-stay-safe"><a class="header" href="#8-concrete-suggestions-to-make-sqlite-shine-and-stay-safe">8. Concrete Suggestions to Make SQLite Shine (and Stay Safe)</a></h2>
<h3 id="81-treat-the-database-as-internal-but-publish-a-safe-surface"><a class="header" href="#81-treat-the-database-as-internal-but-publish-a-safe-surface">8.1. Treat the database as “internal”, but publish a safe surface</a></h3>
<ul>
<li>Publish stable <strong>read-only views</strong> for dashboards (e.g., <code>v_files</code>, <code>v_dirs</code>, <code>v_usage_by_dir</code>).</li>
<li>Document that direct writes are unsupported and may corrupt invariants.</li>
</ul>
<h3 id="82-version-the-schema-explicitly"><a class="header" href="#82-version-the-schema-explicitly">8.2. Version the schema explicitly</a></h3>
<ul>
<li>Maintain <code>schema_version</code> table.</li>
<li>Adopt a migration policy:
<ul>
<li>forward-only migrations,</li>
<li>compatibility notes for dashboard consumers.</li>
</ul>
</li>
</ul>
<h3 id="83-plan-for-large-file-ergonomics-without-committing-to-streaming-in-mvp"><a class="header" href="#83-plan-for-large-file-ergonomics-without-committing-to-streaming-in-mvp">8.3. Plan for large-file ergonomics without committing to streaming in MVP</a></h3>
<p>Even if MVP doesn’t expose <code>Read/Write</code>:</p>
<ul>
<li>keep chunking and <code>read_range</code> semantics robust,</li>
<li>design schema so later a streaming façade can be added without migration pain.</li>
</ul>
<h3 id="84-quota-accounting-and-hardlink-behavior-must-be-specified-early"><a class="header" href="#84-quota-accounting-and-hardlink-behavior-must-be-specified-early">8.4. Quota accounting and hardlink behavior must be specified early</a></h3>
<ul>
<li>Decide “logical bytes” vs “physical bytes”.</li>
<li>If hard links are enabled, define reference counting and GC rules.</li>
</ul>
<h3 id="85-provide-an-official-inspector-cli"><a class="header" href="#85-provide-an-official-inspector-cli">8.5. Provide an “official inspector” CLI</a></h3>
<p>Even with SQLite tooling, an official CLI helps:</p>
<ul>
<li>enforce invariants,</li>
<li>display data in stable ways,</li>
<li>and prevent users from relying on unstable internal tables.</li>
</ul>
<hr>
<h2 id="9-how-backend-separation-enables-different-purposes"><a class="header" href="#9-how-backend-separation-enables-different-purposes">9. How Backend Separation Enables “Different Purposes”</a></h2>
<p>Here are realistic backends enabled by keeping the abstraction clean:</p>
<ul>
<li><strong>MemoryBackend:</strong> fast tests, fuzzing, deterministic state.</li>
<li><strong>SQLiteBackend:</strong> portable, queryable, dashboard-friendly container file.</li>
<li><strong>EncryptedSQLiteBackend / SQLCipherBackend:</strong> security-focused deployments.</li>
<li><strong>CompressedChunkBackend:</strong> storage-optimized deployments.</li>
<li><strong>ObjectStoreBackend (S3/GCS):</strong> cloud-native persistence, content-addressed chunks.</li>
<li><strong>HostFSBackend (Graph-store-on-FS):</strong> use the OS filesystem as a persistence substrate without trying to “adapt” native paths.</li>
</ul>
<p>The separation lets each backend trade off performance, storage cost, and operational properties without changing the <code>FilesContainer</code> behavior.</p>
<hr>
<h2 id="10-summary-recommendation"><a class="header" href="#10-summary-recommendation">10. Summary Recommendation</a></h2>
<p><strong>Yes — move forward</strong>, but do it with a clear SQLite-first stance and strong boundary enforcement:</p>
<ul>
<li>SQLite gives you durable storage + queryability + tooling immediately.</li>
<li>A custom binary format is a bigger long-term project and should be considered a “v2” only if SQLite becomes a proven bottleneck.</li>
<li>Backend separation remains valuable because it keeps the architecture future-proof and enables other storage strategies without rewriting filesystem semantics.</li>
</ul>
<hr>
<h2 id="appendix-quick-go--no-go-checklist"><a class="header" href="#appendix-quick-go--no-go-checklist">Appendix: Quick “Go / No-Go” Checklist</a></h2>
<p><strong>Go</strong> if:</p>
<ul>
<li>you accept SQLite-first for persistence,</li>
<li>you can commit to schema versioning and a safe dashboard surface,</li>
<li>you can specify quota/hardlink/GC rules,</li>
<li>and you can keep filesystem invariants in <code>FilesContainer</code>.</li>
</ul>
<p><strong>No-Go</strong> if:</p>
<ul>
<li>you require many-writer high-throughput workloads immediately,</li>
<li>you require strong encryption/compression at-rest as a hard requirement in MVP (unless adopting SQLCipher etc),</li>
<li>or you cannot accept schema stability requirements for external dashboard consumers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anyfs--review-response--decisions-historical-graph-store-design"><a class="header" href="#anyfs--review-response--decisions-historical-graph-store-design">AnyFS — Review Response &amp; Decisions (Historical: Graph-Store Design)</a></h1>
<blockquote>
<p><strong>⚠️ HISTORICAL DOCUMENT</strong></p>
<p>This document reflects an earlier (rejected) design iteration: a graph-store <code>StorageBackend</code> with <code>NodeId</code>/<code>Edge</code>/<code>ChunkId</code> and mandatory transactions.</p>
<p>The <strong>current</strong> AnyFS design is path-based and uses three crates:</p>
<ul>
<li><code>anyfs-backend</code>: <code>VfsBackend</code> trait with <code>std::fs</code>-aligned methods, receiving <code>&amp;str</code> paths</li>
<li><code>anyfs</code>: low-level execution layer for calling any <code>VfsBackend</code> (also provides built-in backends)</li>
<li><code>anyfs-container</code>: <code>FilesContainer&lt;B&gt;</code> policy layer (limits + least-privilege feature whitelist)</li>
</ul>
<p><strong>Note:</strong> The <code>strict-path</code> crate is only used internally by <code>VRootFsBackend</code>, not by the core trait.</p>
<p>See the authoritative design in:</p>
<ul>
<li><code>book/src/architecture/design-overview.md</code></li>
<li><code>book/src/traits/vfs-trait.md</code></li>
</ul>
</blockquote>
<p><strong>Date:</strong> 2025-12-22
<strong>In Response To:</strong> Full Architecture Review + SQLite Addendum
<strong>Status:</strong> Archived (superseded by ADR-001, ADR-003)</p>
<hr>
<h2 id="executive-summary-1"><a class="header" href="#executive-summary-1">Executive Summary</a></h2>
<p>The reviews identified three critical issues and several high/medium priority items. This document records our decisions and the rationale for each.</p>
<p><strong>Key Decisions Made:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Issue</th><th>Decision</th></tr>
</thead>
<tbody>
<tr><td>CF-1: Competing trait designs</td><td><strong>Graph-store (NodeId/Edge) is authoritative</strong></td></tr>
<tr><td>CF-2: FsBackend ambiguity</td><td><strong>Remove from MVP scope</strong></td></tr>
<tr><td>CF-3: Rename cycle prevention</td><td><strong>Ancestry check required, spec added</strong></td></tr>
<tr><td>HP-1: Large file I/O</td><td><strong>Downgrade AI/ML positioning until streaming exists</strong></td></tr>
<tr><td>HP-2: Concurrency</td><td><strong>Single-threaded by design, external sync required</strong></td></tr>
<tr><td>HP-3: Quota with hard links</td><td><strong>Logical bytes per node (not physical/shared)</strong></td></tr>
<tr><td>SQLite vs Binary</td><td><strong>SQLite-first, schema is versioned contract</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="critical-findings--responses"><a class="header" href="#critical-findings--responses">Critical Findings — Responses</a></h2>
<h3 id="cf-1-competing-backend-trait-designs"><a class="header" href="#cf-1-competing-backend-trait-designs">CF-1: Competing Backend Trait Designs</a></h3>
<p><strong>Finding:</strong> Documents show two different trait designs (graph-store vs direct path ops).</p>
<p><strong>Decision:</strong> The <strong>graph-store design (NodeId/Edge/Chunk)</strong> is authoritative.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Graph model naturally supports hard links, rename atomicity, and reference counting</li>
<li>SQLite backend maps directly to tables</li>
<li>Direct path ops would require each backend to re-implement path resolution</li>
<li>The ADRs already established this; the MVP doc was exploratory</li>
</ul>
<p><strong>Actions:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Document 08 (Technical Comparison) MVP trait section will be marked as “exploratory/superseded”</li>
<li><input disabled="" type="checkbox" checked=""> README will state: “ADRs and anyfs-container-design.md are authoritative”</li>
<li><input disabled="" type="checkbox" checked=""> Single trait definition in design doc is the source of truth</li>
</ul>
<p><strong>Authoritative Trait (for the record):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StorageBackend: Send {
    fn transact&lt;F, T&gt;(&amp;mut self, f: F) -&gt; Result&lt;T, BackendError&gt;
    where F: FnOnce(&amp;mut dyn Transaction) -&gt; Result&lt;T, BackendError&gt;;
    
    fn snapshot(&amp;self) -&gt; Box&lt;dyn Snapshot + '_&gt;;
}

pub trait Snapshot: Send {
    fn get_node(&amp;self, id: NodeId) -&gt; Result&lt;Option&lt;NodeRecord&gt;, BackendError&gt;;
    fn get_edge(&amp;self, parent: NodeId, name: &amp;Name) -&gt; Result&lt;Option&lt;NodeId&gt;, BackendError&gt;;
    fn list_edges(&amp;self, parent: NodeId) -&gt; Result&lt;Vec&lt;Edge&gt;, BackendError&gt;;
    fn read_chunk(&amp;self, id: ChunkId) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, BackendError&gt;;
}

pub trait Transaction: Snapshot {
    fn insert_node(&amp;mut self, node: &amp;NodeRecord) -&gt; Result&lt;(), BackendError&gt;;
    fn update_node(&amp;mut self, id: NodeId, node: &amp;NodeRecord) -&gt; Result&lt;(), BackendError&gt;;
    fn delete_node(&amp;mut self, id: NodeId) -&gt; Result&lt;(), BackendError&gt;;
    fn insert_edge(&amp;mut self, edge: &amp;Edge) -&gt; Result&lt;(), BackendError&gt;;
    fn delete_edge(&amp;mut self, parent: NodeId, name: &amp;Name) -&gt; Result&lt;(), BackendError&gt;;
    fn write_chunk(&amp;mut self, id: ChunkId, data: &amp;[u8]) -&gt; Result&lt;(), BackendError&gt;;
    fn delete_content(&amp;mut self, id: ContentId) -&gt; Result&lt;(), BackendError&gt;;
    fn next_node_id(&amp;mut self) -&gt; Result&lt;NodeId, BackendError&gt;;
    fn next_content_id(&amp;mut self) -&gt; Result&lt;ContentId, BackendError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h3 id="cf-2-fsbackend-ambiguity"><a class="header" href="#cf-2-fsbackend-ambiguity">CF-2: FsBackend Ambiguity</a></h3>
<p><strong>Finding:</strong> How does a path-based host filesystem satisfy a NodeId/Edge graph API?</p>
<p><strong>Decision:</strong> <strong>Remove FsBackend from MVP scope.</strong></p>
<p><strong>Rationale:</strong></p>
<ul>
<li>The graph-store trait requires NodeId persistence across restarts</li>
<li>A true “adapter” over host FS would need a sidecar index (defeating simplicity)</li>
<li>A “graph-store-on-FS” is just a worse SQLite (files as records)</li>
<li>MVP focus should be: prove the abstraction with SQLite + Memory</li>
<li>FsBackend can be added post-MVP if there’s demand, with clear semantics</li>
</ul>
<p><strong>Actions:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Remove <code>vfs-fs</code> from MVP crate structure</li>
<li><input disabled="" type="checkbox" checked=""> Update implementation plan to: SQLite + Memory only</li>
<li><input disabled="" type="checkbox" checked=""> Add “Future: FsBackend” section explaining the complexity</li>
</ul>
<p><strong>MVP Crate Structure (revised):</strong></p>
<pre><code>anyfs-container/
├── anyfs/       # Traits, types (StorageBackend, NodeId, VirtualPath)
├── vfs-sqlite/     # SqliteBackend implementation
├── vfs-memory/     # MemoryBackend implementation
└── vfs/            # FilesContainer + builder (batteries included)
</code></pre>
<p><strong>Note on <code>strict-path</code>:</strong> We can still use <code>strict-path</code> for import/export operations (copying files from/to host filesystem), just not as a backend.</p>
<hr>
<h3 id="cf-3-directory-rename-cycle-prevention"><a class="header" href="#cf-3-directory-rename-cycle-prevention">CF-3: Directory Rename Cycle Prevention</a></h3>
<p><strong>Finding:</strong> Renaming <code>/a</code> → <code>/a/b/a</code> would create a cycle. This must be prevented.</p>
<p><strong>Decision:</strong> Add <strong>ancestry check</strong> to rename operation.</p>
<p><strong>Specification:</strong></p>
<pre><code>INVARIANT: The directory graph is a tree rooted at NodeId(1).
           (No node may be its own ancestor.)

RENAME(source, dest):
  1. Resolve source to source_node_id
  2. Resolve dest parent to dest_parent_id
  3. IF source is a directory:
       Walk ancestors of dest_parent_id up to root
       IF source_node_id is found in ancestor chain:
         RETURN Err(VfsError::WouldCreateCycle)
  4. Proceed with rename (delete old edge, insert new edge)
</code></pre>
<p><strong>Error type:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum VfsError {
    // ... existing variants ...
    
    /// Rename would create a directory cycle
    WouldCreateCycle { source: VirtualPath, dest: VirtualPath },
}
<span class="boring">}</span></code></pre>
<p><strong>Conformance tests required:</strong></p>
<ul>
<li><code>rename_dir_into_own_subtree_fails</code></li>
<li><code>rename_dir_into_deeply_nested_subtree_fails</code></li>
<li><code>rename_dir_to_sibling_succeeds</code></li>
<li><code>rename_file_over_existing_file</code> (decide: overwrite or error?)</li>
</ul>
<p><strong>Decision on rename-over-existing:</strong></p>
<ul>
<li>File over file: <strong>Overwrite</strong> (like POSIX <code>rename</code>)</li>
<li>Dir over empty dir: <strong>Overwrite</strong> (like POSIX)</li>
<li>Dir over non-empty dir: <strong>Error</strong> (DirectoryNotEmpty)</li>
<li>File over dir or dir over file: <strong>Error</strong> (type mismatch)</li>
</ul>
<hr>
<h2 id="high-priority-findings--responses"><a class="header" href="#high-priority-findings--responses">High Priority Findings — Responses</a></h2>
<h3 id="hp-1-large-file-io-vs-aiml-positioning"><a class="header" href="#hp-1-large-file-io-vs-aiml-positioning">HP-1: Large File I/O vs AI/ML Positioning</a></h3>
<p><strong>Finding:</strong> Executive summary cites AI/ML use cases, but API is bulk bytes only.</p>
<p><strong>Decision:</strong> <strong>Downgrade AI/ML positioning</strong> in marketing docs until streaming exists.</p>
<p><strong>Actions:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Remove “AI/ML pipelines” from executive summary primary use cases</li>
<li><input disabled="" type="checkbox" checked=""> Add to “Future Considerations”: streaming API for large files</li>
<li><input disabled="" type="checkbox" checked=""> Keep <code>read_range()</code> in MVP (partial reads are useful)</li>
<li><input disabled="" type="checkbox" checked=""> Note that <code>rusqlite</code> blob feature enables future streaming without schema change</li>
</ul>
<p><strong>Revised primary use cases:</strong></p>
<ul>
<li>Multi-tenant SaaS with per-tenant file storage</li>
<li>Desktop applications with portable user data</li>
<li>Testing with deterministic filesystem state</li>
<li>Embedded systems with portable storage</li>
</ul>
<hr>
<h3 id="hp-2-concurrency-model"><a class="header" href="#hp-2-concurrency-model">HP-2: Concurrency Model</a></h3>
<p><strong>Finding:</strong> Need explicit contract for concurrent access.</p>
<p><strong>Decision:</strong> <strong>Single-threaded by design; external synchronization required.</strong></p>
<p><strong>Specification:</strong></p>
<pre><code>CONCURRENCY CONTRACT:

1. FilesContainer is NOT thread-safe by itself.
   - All methods take &amp;self or &amp;mut self
   - &amp;mut self methods require exclusive access

2. For multi-threaded use:
   - Wrap in Arc&lt;Mutex&lt;FilesContainer&lt;B&gt;&gt;&gt; or similar
   - Or use a connection pool pattern (one container per thread)

3. Backend-level concurrency:
   - SQLite has internal locking (safe for multi-process read)
   - Memory backend has no internal locking
   - Container API still requires coherent access patterns

4. NOT SUPPORTED in v1:
   - Concurrent writers to the same container
   - Multi-process write access (SQLite limitation anyway)
</code></pre>
<p><strong>Actions:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Add “Concurrency” section to design doc</li>
<li><input disabled="" type="checkbox" checked=""> Add example of <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> pattern to getting started guide</li>
<li><input disabled="" type="checkbox" checked=""> Document SQLite WAL mode as recommended default</li>
</ul>
<hr>
<h3 id="hp-3-quota-accounting-with-hard-links"><a class="header" href="#hp-3-quota-accounting-with-hard-links">HP-3: Quota Accounting with Hard Links</a></h3>
<p><strong>Finding:</strong> How is <code>total_size</code> computed when nodes share content via hard links?</p>
<p><strong>Decision:</strong> <strong>Logical bytes per node</strong> (simpler, more predictable for quotas).</p>
<p><strong>Specification:</strong></p>
<pre><code>QUOTA ACCOUNTING RULES:

1. total_size = SUM of (size field) for all file nodes
   - Each file node has its own size, even if content is shared
   - This is "logical size", not "physical storage"

2. Hard link behavior:
   - Creating hard link: new node created with same content_id
   - New node has its own size field (equal to original)
   - total_size INCREASES (counts both nodes)
   - This is intentional: quotas should reflect "apparent" usage

3. Delete behavior:
   - Deleting a file node: total_size DECREASES by node's size
   - Content deletion: deferred until no nodes reference content_id
   - Reference counting via link_count in NodeMetadata

4. Copy behavior:
   - Copy creates new node with NEW content_id
   - Content is duplicated (no implicit sharing)
   - total_size INCREASES by copied size

5. Rationale:
   - Predictable for users ("I have 10 files of 1MB each = 10MB used")
   - Avoids "I deleted a file but quota didn't change" confusion
   - Hard links are opt-in and advanced; users opting in understand sharing
</code></pre>
<p><strong>Alternative considered:</strong> Physical bytes (deduplicated). Rejected because:</p>
<ul>
<li>Complicates quota enforcement (when does space free up?)</li>
<li>Confuses users about apparent vs actual usage</li>
<li>Can be added as a separate “physical_size” metric later if needed</li>
</ul>
<hr>
<h2 id="medium-priority-findings--responses"><a class="header" href="#medium-priority-findings--responses">Medium Priority Findings — Responses</a></h2>
<h3 id="mp-1-importexport-semantics"><a class="header" href="#mp-1-importexport-semantics">MP-1: Import/Export Semantics</a></h3>
<p><strong>Decision:</strong> Define explicit policy.</p>
<p><strong>Import Policy:</strong></p>
<pre><code>IMPORT FROM HOST:

1. Filename encoding:
   - Attempt UTF-8 interpretation
   - Non-UTF-8 filenames: SKIP with warning (logged, not fatal)
   - Null bytes in names: REJECT

2. Symlinks on host:
   - Default: DO NOT FOLLOW (skip symlinks)
   - Option: follow_symlinks: bool (if true, import target content)

3. Special files (devices, FIFOs, sockets):
   - SKIP (not supported in virtual filesystem)

4. Metadata preservation:
   - Timestamps: PRESERVE if container has permissions enabled
   - Permissions: PRESERVE if container has permissions enabled
   - Extended attrs: SKIP (too platform-specific)

5. Limits during import:
   - Respect container's capacity limits
   - Fail fast if total_size would exceed max_total_size
   - max_path_depth applies to imported structure
</code></pre>
<p><strong>Export Policy:</strong></p>
<pre><code>EXPORT TO HOST:

1. Filename encoding:
   - VirtualPath is always valid UTF-8
   - Host filesystem may reject certain characters (platform-specific)
   - On rejection: FAIL with clear error

2. Symlinks in container:
   - If symlinks enabled: CREATE host symlinks
   - If target doesn't exist in export: create dangling symlink

3. Metadata:
   - Timestamps: SET if source has them
   - Permissions: SET if source has them and host supports
   - Extended attrs: SKIP

4. Overwrites:
   - Default: ERROR if host path exists
   - Option: overwrite: bool
</code></pre>
<hr>
<h3 id="mp-2-extended-attributes-limits"><a class="header" href="#mp-2-extended-attributes-limits">MP-2: Extended Attributes Limits</a></h3>
<p><strong>Decision:</strong> Add limits and separate storage.</p>
<p><strong>Specification:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CapacityLimits {
    // ... existing fields ...
    
    /// Maximum size of a single xattr value (default: 64 KB)
    pub max_xattr_value_size: Option&lt;usize&gt;,
    
    /// Maximum total xattr size per node (default: 1 MB)
    pub max_xattr_total_size: Option&lt;usize&gt;,
    
    /// Maximum number of xattrs per node (default: 100)
    pub max_xattr_count: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre>
<p><strong>Storage decision:</strong> Xattrs stored in separate table, NOT in NodeRecord.</p>
<pre><code class="language-sql">CREATE TABLE xattrs (
    node_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    value BLOB NOT NULL,
    PRIMARY KEY (node_id, name),
    FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE
);
</code></pre>
<p><strong>API:</strong></p>
<ul>
<li><code>get_node()</code> does NOT return xattrs (lightweight)</li>
<li>Separate methods: <code>get_xattr()</code>, <code>set_xattr()</code>, <code>list_xattrs()</code>, <code>remove_xattr()</code></li>
</ul>
<hr>
<h3 id="mp-3-document-numbering"><a class="header" href="#mp-3-document-numbering">MP-3: Document Numbering</a></h3>
<p><strong>Decision:</strong> Fix it.</p>
<p><strong>Actions:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Renumber sections consistently</li>
<li><input disabled="" type="checkbox" checked=""> Update TOC anchors</li>
<li><input disabled="" type="checkbox" checked=""> Single pass through all docs before implementation</li>
</ul>
<hr>
<h2 id="sqlite-addendum--response"><a class="header" href="#sqlite-addendum--response">SQLite Addendum — Response</a></h2>
<p><strong>Decision:</strong> Accept all recommendations.</p>
<h3 id="gono-go-checklist"><a class="header" href="#gono-go-checklist">Go/No-Go Checklist:</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Requirement</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Accept SQLite-first for persistence</td><td>✅ Yes</td></tr>
<tr><td>Commit to schema versioning</td><td>✅ Yes</td></tr>
<tr><td>Safe dashboard surface (read-only views)</td><td>✅ Yes</td></tr>
<tr><td>Specify quota/hardlink/GC rules</td><td>✅ Yes (see HP-3)</td></tr>
<tr><td>Keep filesystem invariants in FilesContainer</td><td>✅ Yes</td></tr>
</tbody>
</table>
</div>
<h3 id="schema-contract"><a class="header" href="#schema-contract">Schema Contract:</a></h3>
<pre><code class="language-sql">-- Schema version tracking
CREATE TABLE schema_meta (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);
INSERT INTO schema_meta (key, value) VALUES ('version', '1');

-- Read-only views for external consumers (stable contract)
CREATE VIEW v_files AS
SELECT 
    n.id,
    -- reconstruct path via recursive CTE (complex but doable)
    n.size,
    n.created_at,
    n.modified_at
FROM nodes n
WHERE n.kind = 'file';

CREATE VIEW v_usage AS
SELECT 
    COUNT(*) as node_count,
    SUM(CASE WHEN kind = 'file' THEN size ELSE 0 END) as total_size,
    SUM(CASE WHEN kind = 'file' THEN 1 ELSE 0 END) as file_count,
    SUM(CASE WHEN kind = 'directory' THEN 1 ELSE 0 END) as dir_count
FROM nodes;
</code></pre>
<p><strong>Migration policy:</strong></p>
<ul>
<li>Forward-only migrations</li>
<li>Breaking changes require major version bump</li>
<li>Views are stable interface; internal tables may change</li>
</ul>
<hr>
<h2 id="updated-implementation-plan"><a class="header" href="#updated-implementation-plan">Updated Implementation Plan</a></h2>
<h3 id="phase-1-core-foundation-week-1"><a class="header" href="#phase-1-core-foundation-week-1">Phase 1: Core Foundation (Week 1)</a></h3>
<ul>
<li><code>anyfs</code>: VirtualPath, Name, NodeId, ContentId, ChunkId</li>
<li><code>anyfs</code>: Error types, NodeRecord, Edge, NodeMetadata</li>
<li><code>anyfs</code>: StorageBackend, Snapshot, Transaction traits</li>
</ul>
<h3 id="phase-2-memory-backend-week-2"><a class="header" href="#phase-2-memory-backend-week-2">Phase 2: Memory Backend (Week 2)</a></h3>
<ul>
<li><code>vfs-memory</code>: MemoryBackend with clone-on-transact</li>
<li>Conformance test suite (50+ tests)</li>
<li>All tests passing for memory backend</li>
</ul>
<h3 id="phase-3-sqlite-backend-weeks-3-4"><a class="header" href="#phase-3-sqlite-backend-weeks-3-4">Phase 3: SQLite Backend (Weeks 3-4)</a></h3>
<ul>
<li><code>vfs-sqlite</code>: Schema v1 with WAL mode</li>
<li><code>vfs-sqlite</code>: SqliteBackend implementation</li>
<li>Conformance tests passing</li>
<li>Read-only views for dashboard access</li>
</ul>
<h3 id="phase-4-filescontainer-week-5"><a class="header" href="#phase-4-filescontainer-week-5">Phase 4: FilesContainer (Week 5)</a></h3>
<ul>
<li><code>vfs</code>: FilesContainer with all operations</li>
<li>Path resolution, symlink following (if enabled)</li>
<li>Rename cycle prevention</li>
<li>Capacity limit enforcement</li>
</ul>
<h3 id="phase-5-polish-week-6"><a class="header" href="#phase-5-polish-week-6">Phase 5: Polish (Week 6)</a></h3>
<ul>
<li>Import/export with host filesystem</li>
<li>Documentation updates</li>
<li>Example applications</li>
<li>Publish to crates.io</li>
</ul>
<hr>
<h2 id="acceptance-checklist-updated"><a class="header" href="#acceptance-checklist-updated">Acceptance Checklist (Updated)</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Single authoritative backend trait (CF-1) ✅ Decided</li>
<li><input disabled="" type="checkbox"> FsBackend removed from MVP (CF-2) ✅ Decided</li>
<li><input disabled="" type="checkbox"> Rename cycle prevention spec + tests (CF-3) ✅ Decided</li>
<li><input disabled="" type="checkbox"> Quota accounting rules specified (HP-3) ✅ Decided</li>
<li><input disabled="" type="checkbox"> Import/export policies documented (MP-1) ✅ Decided</li>
<li><input disabled="" type="checkbox"> Xattr limits defined (MP-2) ✅ Decided</li>
<li><input disabled="" type="checkbox"> Doc numbering fixed (MP-3) ⬜ Todo</li>
<li><input disabled="" type="checkbox"> Conformance tests pass for SQLite + Memory ⬜ Implementation</li>
</ul>
<hr>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>All critical and high-priority issues have been resolved with explicit decisions. The project is <strong>approved to proceed</strong> with implementation, following the revised plan:</p>
<ol>
<li><strong>Graph-store trait</strong> is authoritative</li>
<li><strong>SQLite + Memory</strong> backends for MVP (no FsBackend)</li>
<li><strong>Rename cycle prevention</strong> via ancestry check</li>
<li><strong>Logical bytes</strong> for quota accounting</li>
<li><strong>Schema versioning</strong> with stable read-only views</li>
<li><strong>Single-threaded</strong> with external sync for multi-thread</li>
</ol>
<p>The design is now internally consistent and ready for implementation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="open-questions--future-considerations"><a class="header" href="#open-questions--future-considerations">Open Questions &amp; Future Considerations</a></h1>
<p><strong>Status:</strong> Under Discussion
<strong>Last Updated:</strong> 2025-12-23</p>
<hr>
<p>This document captures open questions and design considerations that may influence future development of AnyFS.</p>
<hr>
<h2 id="symlink-handling-with-vrootfsbackend"><a class="header" href="#symlink-handling-with-vrootfsbackend">Symlink Handling with VRootFsBackend</a></h2>
<p><strong>Question:</strong> If VRootFsBackend wraps a real filesystem directory, and the user has symlinks disabled at the FilesContainer level, what happens to symlinks that exist in the underlying host filesystem?</p>
<p><strong>Considerations:</strong></p>
<ol>
<li>
<p><strong>VRootFsBackend inherits real FS behavior</strong>: The underlying filesystem still has symlinks. Even if we don’t expose symlink <em>creation</em> APIs, operations like <code>read</code> or <code>metadata</code> might still follow symlinks on the host.</p>
</li>
<li>
<p><strong>Options:</strong></p>
<ul>
<li><strong>Transparent following</strong>: VRootFsBackend always follows symlinks on the host (simplest, matches host behavior)</li>
<li><strong>Refuse symlinks</strong>: VRootFsBackend returns an error if it encounters a symlink</li>
<li><strong>Configurable per-backend</strong>: Let VRootFsBackend accept a <code>follow_symlinks: bool</code> option</li>
</ul>
</li>
<li>
<p><strong>Recommendation:</strong> VRootFsBackend should transparently follow symlinks on the host filesystem. The “symlinks disabled” policy at the container level means <em>creating</em> symlinks is disabled, not that the backend must refuse to traverse existing ones.</p>
</li>
</ol>
<hr>
<h2 id="virtual-vs-real-backends-path-resolution"><a class="header" href="#virtual-vs-real-backends-path-resolution">Virtual vs Real Backends: Path Resolution</a></h2>
<p><strong>Question:</strong> Should path resolution logic be different for virtual backends (memory, SQLite) vs filesystem-based backends (VRootFsBackend)?</p>
<p><strong>Analysis:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend Type</th><th>Path Resolution</th><th>Symlink Handling</th></tr>
</thead>
<tbody>
<tr><td>MemoryBackend</td><td>Pure lexical (in our code)</td><td>We control everything</td></tr>
<tr><td>SqliteBackend</td><td>Pure lexical (in our code)</td><td>We control everything</td></tr>
<tr><td>VRootFsBackend</td><td>OS handles it</td><td>OS follows symlinks on host</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> For virtual backends, we perform lexical path resolution ourselves. For VRootFsBackend, we delegate to the OS via <code>std::fs</code>. The <code>strict-path::VirtualRoot</code> ensures we can’t escape the root directory, but symlink resolution within that root is handled by the OS.</p>
<hr>
<h2 id="compression-and-encryption"><a class="header" href="#compression-and-encryption">Compression and Encryption</a></h2>
<p><strong>Question:</strong> Does the current design allow backends to compress/decompress or encrypt/decrypt files transparently?</p>
<p><strong>Answer:</strong> Yes. The backend receives the data and stores it however it wants. A backend could:</p>
<ul>
<li>Compress data before writing to SQLite</li>
<li>Encrypt blobs with a user-provided key</li>
<li>Use a remote object store with encryption at rest</li>
</ul>
<p>This is an implementation detail of the backend, not visible to the <code>FilesContainer</code> API.</p>
<hr>
<h2 id="hooks-and-callbacks"><a class="header" href="#hooks-and-callbacks">Hooks and Callbacks</a></h2>
<p><strong>Question:</strong> Should AnyFS support hooks or callbacks for file operations (e.g., audit logging, validation)?</p>
<p><strong>Considerations:</strong></p>
<ul>
<li>AgentFS (see comparison below) provides audit logging as a core feature</li>
<li>Hooks add complexity but enable powerful use cases</li>
<li>Could be implemented as a middleware pattern around FilesContainer</li>
</ul>
<p><strong>Options:</strong></p>
<ol>
<li><strong>No hooks in v1</strong>: Keep it simple. Users can wrap FilesContainer in their own type.</li>
<li><strong>Event emitter</strong>: FilesContainer emits events that users can subscribe to</li>
<li><strong>Middleware trait</strong>: Allow wrapping backends with cross-cutting concerns</li>
</ol>
<p><strong>Recommendation:</strong> Defer to v2. Users can wrap <code>FilesContainer</code> or backends for now.</p>
<hr>
<h2 id="agentfs-comparison"><a class="header" href="#agentfs-comparison">AgentFS Comparison</a></h2>
<p><a href="https://github.com/tursodatabase/agentfs">AgentFS</a> is a filesystem designed for AI agents with:</p>
<ul>
<li><strong>Auditability</strong>: Every operation recorded in SQLite</li>
<li><strong>Reproducibility</strong>: Snapshot and restore agent state</li>
<li><strong>Portability</strong>: Everything in a single SQLite file</li>
</ul>
<p><strong>Similarities with AnyFS:</strong></p>
<ul>
<li>SQLite as portable storage</li>
<li>Single-file deployment</li>
<li>Agent/tenant isolation</li>
</ul>
<p><strong>Differences:</strong></p>
<ul>
<li>AgentFS is specialized for AI agent workflows (includes key-value store, tool call logging)</li>
<li>AnyFS is a general-purpose virtual filesystem abstraction</li>
<li>AgentFS has more features; AnyFS has more flexibility</li>
</ul>
<p><strong>Could AnyFS use AgentFS?</strong> Possibly as a backend, but AgentFS’s API is different from <code>VfsBackend</code>. Integration would require an adapter.</p>
<p><strong>Takeaway:</strong> AgentFS validates the SQLite-based portable filesystem approach. We could learn from their audit logging if we add hooks in the future.</p>
<hr>
<h2 id="vfs-crate-comparison"><a class="header" href="#vfs-crate-comparison">VFS Crate Comparison</a></h2>
<p>The <a href="https://docs.rs/vfs/">vfs crate</a> provides virtual filesystem abstractions with:</p>
<ul>
<li><strong>PhysicalFS</strong>: Host filesystem access</li>
<li><strong>MemoryFS</strong>: In-memory storage</li>
<li><strong>AltrootFS</strong>: Rooted filesystem (similar to our VRootFsBackend)</li>
<li><strong>OverlayFS</strong>: Layered filesystem</li>
<li><strong>EmbeddedFS</strong>: Compile resources into binary</li>
</ul>
<p><strong>Similarities with AnyFS:</strong></p>
<ul>
<li>Trait-based abstraction over storage</li>
<li>Memory and physical filesystem backends</li>
</ul>
<p><strong>Differences:</strong></p>
<ul>
<li>VFS doesn’t have SQLite backend</li>
<li>VFS doesn’t have policy/quota layer</li>
<li>AnyFS focuses on isolation and limits</li>
</ul>
<p><strong>Why not use VFS?</strong> VFS is a good library, but AnyFS’s design goals differ:</p>
<ol>
<li>We want SQLite as a first-class backend</li>
<li>We need quota/limit enforcement</li>
<li>We want feature whitelisting (least privilege)</li>
</ol>
<hr>
<h2 id="fuse-mount-support"><a class="header" href="#fuse-mount-support">FUSE Mount Support</a></h2>
<p><strong>Question:</strong> Should AnyFS support mounting as a FUSE filesystem?</p>
<p><strong>What is FUSE?</strong>
<a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE (Filesystem in Userspace)</a> allows implementing filesystems in userspace rather than kernel code. It enables:</p>
<ul>
<li>Mounting any backend as a real filesystem</li>
<li>Using standard Unix tools (ls, cat, etc.) on AnyFS containers</li>
<li>Integration with existing workflows</li>
</ul>
<p><strong>Considerations:</strong></p>
<ul>
<li>FUSE requires platform-specific code (Linux, macOS via macFUSE)</li>
<li>Adds significant complexity</li>
<li>Performance overhead vs direct API access</li>
<li>Security implications of exposing to OS</li>
</ul>
<p><strong>Recommendation:</strong> Not in v1. If there’s demand, we could add a <code>anyfs-fuse</code> crate that mounts a FilesContainer as a FUSE filesystem. This would be a separate, optional layer.</p>
<hr>
<h2 id="type-system-protection-for-cross-container-operations"><a class="header" href="#type-system-protection-for-cross-container-operations">Type-System Protection for Cross-Container Operations</a></h2>
<p><strong>Question:</strong> Should we use the type system to prevent accidentally mixing data between containers?</p>
<p><strong>Example concern:</strong> Reading from Container A and writing to Container B without explicit acknowledgment.</p>
<p><strong>Options:</strong></p>
<ol>
<li><strong>Marker generics</strong>: <code>FilesContainer&lt;B, Marker&gt;</code> where Marker distinguishes instances</li>
<li><strong>Opaque handles</strong>: File content wrapped in typed handles tied to origin container</li>
<li><strong>No protection</strong>: Trust the user to wire things correctly</li>
</ol>
<p><strong>Recommendation:</strong> Defer. The complexity may not be worth it for most use cases. Users who need this can implement their own type wrappers.</p>
<hr>
<h2 id="naming-considerations"><a class="header" href="#naming-considerations">Naming Considerations</a></h2>
<p>Based on review feedback, the following naming concerns were raised:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Current Name</th><th>Concern</th><th>Alternatives Considered</th></tr>
</thead>
<tbody>
<tr><td><code>anyfs-traits</code></td><td>“traits” is vague</td><td><code>anyfs-backend</code> (adopted)</td></tr>
<tr><td><code>anyfs-container</code></td><td>Could imply Docker</td><td><code>anyfs-storage</code>, <code>anyfs-fs</code>, <code>fsContainer</code></td></tr>
<tr><td><code>anyfs</code></td><td>Sounds like Hebrew “ani efes” (I am zero)</td><td><code>anyfs</code> retained for simplicity</td></tr>
</tbody>
</table>
</div>
<p><strong>Decision:</strong> Renamed <code>anyfs-traits</code> to <code>anyfs-backend</code>. Other names retained.</p>
<hr>
<h2 id="posix-behavior"><a class="header" href="#posix-behavior">POSIX Behavior</a></h2>
<p><strong>Question:</strong> How POSIX-compatible should AnyFS be?</p>
<p><strong>Answer:</strong> AnyFS is <strong>not</strong> a POSIX emulator. We use <code>std::fs</code>-like naming and semantics for familiarity, but we don’t aim for full POSIX compliance. Specific differences:</p>
<ul>
<li>Lexical path resolution (not runtime symlink following during normalization)</li>
<li>No file descriptors or open file handles in the basic API</li>
<li>Simplified permissions model</li>
<li>No device files, FIFOs, or sockets</li>
</ul>
<hr>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>These questions inform future development but don’t block v1:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Topic</th><th>v1 Decision</th></tr>
</thead>
<tbody>
<tr><td>Symlinks with VRootFsBackend</td><td>Transparent following on host</td></tr>
<tr><td>Path resolution</td><td>Virtual = lexical; VRootFs = OS</td></tr>
<tr><td>Compression/encryption</td><td>Backend responsibility</td></tr>
<tr><td>Hooks/callbacks</td><td>Defer to v2</td></tr>
<tr><td>FUSE mount</td><td>Not in v1, consider v2</td></tr>
<tr><td>Type-system protection</td><td>Defer</td></tr>
<tr><td>POSIX compatibility</td><td>Not a goal</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="historical-vfs-container--pre-container-design-document"><a class="header" href="#historical-vfs-container--pre-container-design-document">Historical: VFS Container — Pre-Container Design Document</a></h1>
<blockquote>
<p>This document is historical and reflects an early design iteration before the current architecture was finalized.</p>
<p>The current AnyFS design uses three crates: <code>anyfs-traits</code>, <code>anyfs</code>, <code>anyfs-container</code> with a path-based <code>VfsBackend</code> trait (20 methods).</p>
<p>For current design, see:</p>
<ul>
<li><code>book/src/architecture/adrs.md</code></li>
<li><code>book/src/architecture/design-overview.md</code></li>
</ul>
</blockquote>
<p><strong>Version:</strong> 0.1.0-draft
<strong>Status:</strong> Historical (superseded)
<strong>Authors:</strong> [TBD]
<strong>Last Updated:</strong> 2025-01-XX</p>
<hr>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#1-executive-summary-1">Executive Summary</a></li>
<li><a href="#2-goals-and-non-goals">Goals and Non-Goals</a></li>
<li><a href="#3-architecture-overview">Architecture Overview</a></li>
<li><a href="#4-core-abstractions">Core Abstractions</a></li>
<li><a href="#5-backend-specification">Backend Specification</a></li>
<li><a href="#6-filescontainer-api">FilesContainer API</a></li>
<li><a href="#7-path-handling">Path Handling</a></li>
<li><a href="#8-filesystem-features">Filesystem Features</a></li>
<li><a href="#9-capacity-management">Capacity Management</a></li>
<li><a href="#10-error-handling">Error Handling</a></li>
<li><a href="#11-crate-structure">Crate Structure</a></li>
<li><a href="#12-security-considerations">Security Considerations</a></li>
<li><a href="#13-implementation-plan">Implementation Plan</a></li>
<li><a href="#14-open-questions">Open Questions</a></li>
<li><a href="#15-future-considerations">Future Considerations</a></li>
<li><a href="#appendices">Appendices</a></li>
</ol>
<hr>
<h2 id="1-executive-summary-1"><a class="header" href="#1-executive-summary-1">1. Executive Summary</a></h2>
<h3 id="11-what-is-this"><a class="header" href="#11-what-is-this">1.1 What Is This?</a></h3>
<p>VFS Container is a <strong>storage-agnostic virtual filesystem abstraction</strong> for Rust. It provides:</p>
<ul>
<li>A minimal trait (<code>StorageBackend</code>) that any storage system can implement</li>
<li>A high-level API (<code>FilesContainer</code>) with familiar filesystem operations</li>
<li>Reference implementations for SQLite, in-memory, and host filesystem backends</li>
<li>Complete isolation from host OS filesystem semantics</li>
</ul>
<h3 id="12-key-insight"><a class="header" href="#12-key-insight">1.2 Key Insight</a></h3>
<p>Existing virtual filesystem abstractions conflate <strong>filesystem semantics</strong> with <strong>storage operations</strong>. They require backend implementers to understand paths, symlinks, permissions, and resolution logic.</p>
<p>This design separates concerns:</p>
<pre><code>┌─────────────────────────────────────────────┐
│  FilesContainer (Filesystem Semantics)      │  ← paths, symlinks, resolution
├─────────────────────────────────────────────┤
│  StorageBackend (Storage Operations)        │  ← nodes, edges, blobs
└─────────────────────────────────────────────┘
</code></pre>
<p>The backend is a <strong>typed graph store</strong>. It knows nothing about filesystems. It stores nodes (metadata) and edges (parent-child relationships). All filesystem logic lives above it.</p>
<h3 id="13-primary-use-cases"><a class="header" href="#13-primary-use-cases">1.3 Primary Use Cases</a></h3>
<ul>
<li><strong>Multi-tenant isolated storage</strong>: Each tenant gets a completely isolated namespace</li>
<li><strong>Portable data containers</strong>: Single-file SQLite databases that can be moved, backed up, versioned</li>
<li><strong>Safe sandbox environments</strong>: No code execution, no host filesystem escape</li>
<li><strong>Testing</strong>: Deterministic, isolated filesystem for unit/integration tests</li>
<li><strong>Embedded applications</strong>: Portable data storage without OS dependencies</li>
</ul>
<hr>
<h2 id="2-goals-and-non-goals"><a class="header" href="#2-goals-and-non-goals">2. Goals and Non-Goals</a></h2>
<h3 id="21-goals"><a class="header" href="#21-goals">2.1 Goals</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ID</th><th>Goal</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>G1</td><td><strong>Backend simplicity</strong></td><td>Implementing a new backend should take hours, not days. The trait surface must be minimal.</td></tr>
<tr><td>G2</td><td><strong>Impossible to misuse</strong></td><td>Type system prevents invalid states. Transactions are mandatory. IDs are distinct types.</td></tr>
<tr><td>G3</td><td><strong>Complete isolation</strong></td><td>Virtual paths never resolve to host filesystem. Escape is structurally impossible.</td></tr>
<tr><td>G4</td><td><strong>Portable storage</strong></td><td>The SQLite backend produces a single file that works on any platform.</td></tr>
<tr><td>G5</td><td><strong>Configurable semantics</strong></td><td>Features like symlinks, hard links, and permissions are opt-in.</td></tr>
<tr><td>G6</td><td><strong>Resource limits</strong></td><td>First-class support for storage quotas, file size limits, and node counts.</td></tr>
<tr><td>G7</td><td><strong>No execution</strong></td><td>This is a data container. No binary execution, no plugins, no shell semantics.</td></tr>
</tbody>
</table>
</div>
<h3 id="22-non-goals"><a class="header" href="#22-non-goals">2.2 Non-Goals</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ID</th><th>Non-Goal</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>NG1</td><td>POSIX compliance</td><td>We deliberately avoid full POSIX semantics. Simpler is safer.</td></tr>
<tr><td>NG2</td><td>Host filesystem mounting</td><td>No FUSE, no kernel integration. Purely userspace.</td></tr>
<tr><td>NG3</td><td>Maximum performance</td><td>Correctness and safety over raw speed. Backends can optimize internally.</td></tr>
<tr><td>NG4</td><td>Distributed consensus</td><td>Multi-node coordination is out of scope. Single-writer model.</td></tr>
<tr><td>NG5</td><td>Streaming/async in core trait</td><td>Start synchronous. Async can be added as a separate trait later.</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="3-architecture-overview"><a class="header" href="#3-architecture-overview">3. Architecture Overview</a></h2>
<h3 id="31-layer-diagram"><a class="header" href="#31-layer-diagram">3.1 Layer Diagram</a></h3>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│                         User Code                                │
└──────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌──────────────────────────────────────────────────────────────────┐
│                      FilesContainer&lt;B&gt;                           │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │  • Path parsing &amp; validation                               │  │
│  │  • Symlink resolution (with loop detection)                │  │
│  │  • Hard link reference counting                            │  │
│  │  • Permission checking (if enabled)                        │  │
│  │  • Capacity limit enforcement                              │  │
│  │  • Metadata management                                     │  │
│  └────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌──────────────────────────────────────────────────────────────────┐
│                    StorageBackend (trait)                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │  • Insert/get/update/delete nodes                          │  │
│  │  • Insert/get/delete edges                                 │  │
│  │  • Read/write content chunks                               │  │
│  │  • Transaction boundary                                    │  │
│  └────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌───────────────────┬───────────────────┬──────────────────────────┐
│  SqliteBackend    │  MemoryBackend    │  FsBackend               │
│  (vfs-sqlite)     │  (vfs-memory)     │  (vfs-fs)                │
└───────────────────┴───────────────────┴──────────────────────────┘
</code></pre>
<h3 id="32-data-model"><a class="header" href="#32-data-model">3.2 Data Model</a></h3>
<p>The virtual filesystem is modeled as a <strong>directed graph</strong>:</p>
<ul>
<li><strong>Nodes</strong>: Files, directories, symlinks (each with metadata)</li>
<li><strong>Edges</strong>: Named parent→child relationships</li>
<li><strong>Content</strong>: Binary data, stored separately and referenced by ID</li>
</ul>
<pre><code>         ┌─────────────────┐
         │  Node (Dir)     │
         │  id: 1 (root)   │
         └────────┬────────┘
                  │
        ┌─────────┴─────────┐
        │ "etc"             │ "home"
        ▼                   ▼
  ┌───────────┐       ┌───────────┐
  │ Node (Dir)│       │ Node (Dir)│
  │ id: 2     │       │ id: 3     │
  └─────┬─────┘       └─────┬─────┘
        │ "config"          │ "user"
        ▼                   ▼
  ┌───────────┐       ┌───────────┐
  │ Node(File)│       │ Node (Dir)│
  │ id: 4     │       │ id: 5     │
  │ content:C1│       └───────────┘
  └───────────┘

  Content Store:
  ┌─────────────────────┐
  │ C1 → [chunk0, ...]  │
  └─────────────────────┘
</code></pre>
<h3 id="33-separation-of-concerns"><a class="header" href="#33-separation-of-concerns">3.3 Separation of Concerns</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Handled By</th></tr>
</thead>
<tbody>
<tr><td>Path string parsing</td><td><code>VirtualPath</code> (in <code>anyfs</code>)</td></tr>
<tr><td>Path traversal &amp; resolution</td><td><code>FilesContainer</code></td></tr>
<tr><td>Symlink following</td><td><code>FilesContainer</code></td></tr>
<tr><td>Link count management</td><td><code>FilesContainer</code></td></tr>
<tr><td>Permission enforcement</td><td><code>FilesContainer</code></td></tr>
<tr><td>Capacity enforcement</td><td><code>FilesContainer</code></td></tr>
<tr><td>Node/edge storage</td><td><code>StorageBackend</code></td></tr>
<tr><td>Content chunking</td><td><code>StorageBackend</code> (fixed chunk size)</td></tr>
<tr><td>Transaction atomicity</td><td><code>StorageBackend</code></td></tr>
<tr><td>Compression, encryption</td><td>Backend-specific (internal)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="4-core-abstractions"><a class="header" href="#4-core-abstractions">4. Core Abstractions</a></h2>
<h3 id="41-identity-types"><a class="header" href="#41-identity-types">4.1 Identity Types</a></h3>
<p>All IDs are newtypes to prevent accidental misuse:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Unique identifier for a node (file, directory, symlink)
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct NodeId(pub(crate) u64);

/// Unique identifier for content (separate from node for deduplication)
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct ContentId(pub(crate) u64);

/// Reference to a specific chunk within content
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct ChunkId {
    pub content: ContentId,
    pub index: u32,
}

/// Validated filename component (never empty, no `/`, no `\0`, not `.` or `..`)
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct Name(String);

impl Name {
    pub fn new(s: impl AsRef&lt;str&gt;) -&gt; Result&lt;Self, InvalidNameError&gt; {
        let s = s.as_ref();
        if s.is_empty() 
            || s.contains('/') 
            || s.contains('\0') 
            || s == "." 
            || s == ".." 
        {
            return Err(InvalidNameError(s.to_string()));
        }
        Ok(Name(s.to_string()))
    }
    
    pub fn as_str(&amp;self) -&gt; &amp;str {
        &amp;self.0
    }
}
<span class="boring">}</span></code></pre>
<h3 id="42-node-types"><a class="header" href="#42-node-types">4.2 Node Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The kind of filesystem node
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum NodeKind {
    /// Regular file with content
    File {
        content_id: ContentId,
        size: u64,
    },
    
    /// Directory (children are edges, not stored here)
    Directory,
    
    /// Symbolic link to another path
    Symlink {
        target: String,  // Raw target path (may be relative)
    },
}

/// Complete node record
#[derive(Clone, Debug)]
pub struct NodeRecord {
    pub id: NodeId,
    pub kind: NodeKind,
    pub metadata: NodeMetadata,
}

/// Node metadata
#[derive(Clone, Debug, Default)]
pub struct NodeMetadata {
    pub created_at: Option&lt;Timestamp&gt;,
    pub modified_at: Option&lt;Timestamp&gt;,
    pub accessed_at: Option&lt;Timestamp&gt;,
    pub permissions: Option&lt;Permissions&gt;,
    pub link_count: u32,  // Number of hard links (edges pointing to this node)
    pub extended_attrs: HashMap&lt;String, Vec&lt;u8&gt;&gt;,
}

/// Unix-style permission bits (optional feature)
#[derive(Clone, Copy, Debug, Default)]
pub struct Permissions {
    pub mode: u16,  // e.g., 0o755
}

/// Timestamp in milliseconds since Unix epoch
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Timestamp(pub i64);
<span class="boring">}</span></code></pre>
<h3 id="43-edges"><a class="header" href="#43-edges">4.3 Edges</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A named link from parent to child
#[derive(Clone, Debug)]
pub struct Edge {
    pub parent: NodeId,
    pub name: Name,
    pub child: NodeId,
}
<span class="boring">}</span></code></pre>
<h3 id="44-content-chunking"><a class="header" href="#44-content-chunking">4.4 Content Chunking</a></h3>
<p>Content is stored in fixed-size chunks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Chunk size: 64 KB
/// 
/// Rationale:
/// - Large enough to minimize chunk count for typical files
/// - Small enough for efficient partial reads
/// - Matches common filesystem block sizes
pub const CHUNK_SIZE: usize = 64 * 1024;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="5-backend-specification"><a class="header" href="#5-backend-specification">5. Backend Specification</a></h2>
<h3 id="51-core-trait"><a class="header" href="#51-core-trait">5.1 Core Trait</a></h3>
<p>The backend trait is deliberately minimal — <strong>13 methods</strong> total:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StorageBackend: Send {
    /// Execute operations within a transaction.
    /// All mutations MUST happen inside a transaction.
    /// Guarantees atomicity: either all operations commit or none do.
    fn transact&lt;F, T&gt;(&amp;mut self, f: F) -&gt; Result&lt;T, BackendError&gt;
    where
        F: FnOnce(&amp;mut dyn Transaction) -&gt; Result&lt;T, BackendError&gt;;

    /// Get a read-only snapshot for consistent reads.
    fn snapshot(&amp;self) -&gt; Box&lt;dyn Snapshot + '_&gt;;
}

/// Read-only operations
pub trait Snapshot: Send {
    fn get_node(&amp;self, id: NodeId) -&gt; Result&lt;Option&lt;NodeRecord&gt;, BackendError&gt;;
    fn get_edge(&amp;self, parent: NodeId, name: &amp;Name) -&gt; Result&lt;Option&lt;NodeId&gt;, BackendError&gt;;
    fn list_edges(&amp;self, parent: NodeId) -&gt; Result&lt;Vec&lt;Edge&gt;, BackendError&gt;;
    fn read_chunk(&amp;self, id: ChunkId) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, BackendError&gt;;
    
    /// Optional: batch read for efficiency
    fn get_nodes(&amp;self, ids: &amp;[NodeId]) -&gt; Result&lt;Vec&lt;Option&lt;NodeRecord&gt;&gt;, BackendError&gt; {
        ids.iter().map(|id| self.get_node(*id)).collect()
    }
}

/// Read-write operations (only available inside transaction)
pub trait Transaction: Snapshot {
    fn insert_node(&amp;mut self, node: &amp;NodeRecord) -&gt; Result&lt;(), BackendError&gt;;
    fn update_node(&amp;mut self, id: NodeId, node: &amp;NodeRecord) -&gt; Result&lt;(), BackendError&gt;;
    fn delete_node(&amp;mut self, id: NodeId) -&gt; Result&lt;(), BackendError&gt;;

    fn insert_edge(&amp;mut self, edge: &amp;Edge) -&gt; Result&lt;(), BackendError&gt;;
    fn delete_edge(&amp;mut self, parent: NodeId, name: &amp;Name) -&gt; Result&lt;(), BackendError&gt;;

    fn write_chunk(&amp;mut self, id: ChunkId, data: &amp;[u8]) -&gt; Result&lt;(), BackendError&gt;;
    fn delete_content(&amp;mut self, id: ContentId) -&gt; Result&lt;(), BackendError&gt;;
    
    /// Generate a new unique node ID
    fn next_node_id(&amp;mut self) -&gt; Result&lt;NodeId, BackendError&gt;;
    
    /// Generate a new unique content ID
    fn next_content_id(&amp;mut self) -&gt; Result&lt;ContentId, BackendError&gt;;
    
    /// Optional: batch operations for efficiency
    fn insert_nodes(&amp;mut self, nodes: &amp;[NodeRecord]) -&gt; Result&lt;(), BackendError&gt; {
        for node in nodes {
            self.insert_node(node)?;
        }
        Ok(())
    }
    
    fn insert_edges(&amp;mut self, edges: &amp;[Edge]) -&gt; Result&lt;(), BackendError&gt; {
        for edge in edges {
            self.insert_edge(edge)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="52-lifecycle-trait"><a class="header" href="#52-lifecycle-trait">5.2 Lifecycle Trait</a></h3>
<p>Separate from operations because not all backends support all lifecycle operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait BackendLifecycle: Sized {
    type Config;
    
    /// Create new storage (fails if already exists)
    fn create(config: Self::Config) -&gt; Result&lt;Self, BackendError&gt;;
    
    /// Open existing storage (fails if doesn't exist)
    fn open(config: Self::Config) -&gt; Result&lt;Self, BackendError&gt;;
    
    /// Open existing or create new
    fn open_or_create(config: Self::Config) -&gt; Result&lt;Self, BackendError&gt;;
    
    /// Destroy all data (optional — not all backends support this)
    fn destroy(self) -&gt; Result&lt;(), BackendError&gt; {
        Err(BackendError::NotSupported)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="53-backend-errors"><a class="header" href="#53-backend-errors">5.3 Backend Errors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum BackendError {
    #[error("node not found: {0:?}")]
    NodeNotFound(NodeId),
    
    #[error("edge not found: {parent:?}/{name}")]
    EdgeNotFound { parent: NodeId, name: String },
    
    #[error("edge already exists: {parent:?}/{name}")]
    EdgeAlreadyExists { parent: NodeId, name: String },
    
    #[error("node already exists: {0:?}")]
    NodeAlreadyExists(NodeId),
    
    #[error("content not found: {0:?}")]
    ContentNotFound(ContentId),
    
    #[error("storage full")]
    StorageFull,
    
    #[error("operation not supported by this backend")]
    NotSupported,
    
    #[error("transaction conflict")]
    TransactionConflict,
    
    #[error("backend I/O error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("backend internal error: {0}")]
    Internal(String),
}
<span class="boring">}</span></code></pre>
<h3 id="54-what-backends-do-not-handle"><a class="header" href="#54-what-backends-do-not-handle">5.4 What Backends Do NOT Handle</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Why Not Backend</th></tr>
</thead>
<tbody>
<tr><td>Path resolution</td><td>Backend operates on NodeIds, not paths</td></tr>
<tr><td>Symlink following</td><td>Filesystem semantic, not storage</td></tr>
<tr><td>Hard link counting</td><td>Core increments/decrements, backend just stores</td></tr>
<tr><td>Permission checking</td><td>Policy, not storage</td></tr>
<tr><td>Capacity limits</td><td>Policy, not storage</td></tr>
<tr><td>Content chunking logic</td><td>Core splits/reassembles, backend stores fixed chunks</td></tr>
<tr><td>Name validation</td><td><code>Name</code> type validates on construction</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="6-filescontainer-api"><a class="header" href="#6-filescontainer-api">6. FilesContainer API</a></h2>
<h3 id="61-construction"><a class="header" href="#61-construction">6.1 Construction</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: StorageBackend&gt; FilesContainer&lt;B&gt; {
    /// Create with default configuration
    pub fn new(backend: B) -&gt; Result&lt;Self, VfsError&gt;;
    
    /// Start building with configuration
    pub fn builder() -&gt; ContainerBuilder&lt;NoBackend&gt;;
}

pub struct ContainerBuilder&lt;B&gt; {
    backend: B,
    config: ContainerConfig,
}

impl ContainerBuilder&lt;NoBackend&gt; {
    pub fn new() -&gt; Self;
}

impl&lt;B&gt; ContainerBuilder&lt;B&gt; {
    /// Set the storage backend
    pub fn backend&lt;NewB: StorageBackend&gt;(self, backend: NewB) -&gt; ContainerBuilder&lt;NewB&gt;;
    
    // Feature toggles
    pub fn symlinks(self, enabled: bool) -&gt; Self;
    pub fn hard_links(self, enabled: bool) -&gt; Self;
    pub fn permissions(self, enabled: bool) -&gt; Self;
    pub fn extended_attrs(self, enabled: bool) -&gt; Self;
    
    // Resolution limits
    pub fn max_path_depth(self, depth: u16) -&gt; Self;
    pub fn max_symlink_resolution(self, max: u16) -&gt; Self;
    
    // Capacity limits (fluent)
    pub fn max_total_size(self, bytes: u64) -&gt; Self;
    pub fn max_file_size(self, bytes: u64) -&gt; Self;
    pub fn max_node_count(self, count: u64) -&gt; Self;
    pub fn max_dir_entries(self, count: u32) -&gt; Self;
    pub fn max_name_length(self, length: u16) -&gt; Self;
    
    // Capacity limits (struct)
    pub fn limits(self, limits: CapacityLimits) -&gt; Self;
}

impl&lt;B: StorageBackend&gt; ContainerBuilder&lt;B&gt; {
    /// Build the container (initializes root if needed)
    pub fn build(self) -&gt; Result&lt;FilesContainer&lt;B&gt;, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="62-file-operations"><a class="header" href="#62-file-operations">6.2 File Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: StorageBackend&gt; FilesContainer&lt;B&gt; {
    // ─────────────────────────────────────────────────────────────
    // Read Operations
    // ─────────────────────────────────────────────────────────────
    
    /// Check if a path exists
    pub fn exists(&amp;self, path: &amp;VirtualPath) -&gt; bool;
    
    /// Get metadata for a path
    pub fn metadata(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Metadata, VfsError&gt;;
    
    /// Read entire file contents
    pub fn read(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    
    /// Read a range of bytes from a file
    pub fn read_range(&amp;self, path: &amp;VirtualPath, offset: u64, len: u64) -&gt; Result&lt;Vec&lt;u8&gt;, VfsError&gt;;
    
    /// List directory contents
    pub fn list(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;DirEntry&gt;, VfsError&gt;;
    
    /// Read symlink target (does not follow the link)
    pub fn read_link(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;VirtualPath, VfsError&gt;;
    
    // ─────────────────────────────────────────────────────────────
    // Write Operations
    // ─────────────────────────────────────────────────────────────
    
    /// Create a directory
    pub fn mkdir(&amp;mut self, path: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Create a directory and all parent directories
    pub fn mkdir_all(&amp;mut self, path: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Write file contents (creates or overwrites)
    pub fn write(&amp;mut self, path: &amp;VirtualPath, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Append to a file
    pub fn append(&amp;mut self, path: &amp;VirtualPath, data: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Create a symbolic link
    pub fn symlink(&amp;mut self, path: &amp;VirtualPath, target: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Create a hard link
    pub fn hard_link(&amp;mut self, path: &amp;VirtualPath, target: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Delete a file or empty directory
    pub fn remove(&amp;mut self, path: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Delete a directory and all contents
    pub fn remove_all(&amp;mut self, path: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Rename/move a file or directory
    pub fn rename(&amp;mut self, from: &amp;VirtualPath, to: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Copy a file
    pub fn copy(&amp;mut self, from: &amp;VirtualPath, to: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Copy a directory recursively
    pub fn copy_all(&amp;mut self, from: &amp;VirtualPath, to: &amp;VirtualPath) -&gt; Result&lt;(), VfsError&gt;;
    
    // ─────────────────────────────────────────────────────────────
    // Metadata Operations
    // ─────────────────────────────────────────────────────────────
    
    /// Set permissions (if enabled)
    pub fn set_permissions(&amp;mut self, path: &amp;VirtualPath, perms: Permissions) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Set timestamps
    pub fn set_times(&amp;mut self, path: &amp;VirtualPath, times: Times) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Set extended attribute
    pub fn set_xattr(&amp;mut self, path: &amp;VirtualPath, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), VfsError&gt;;
    
    /// Get extended attribute
    pub fn get_xattr(&amp;self, path: &amp;VirtualPath, name: &amp;str) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, VfsError&gt;;
    
    /// Remove extended attribute
    pub fn remove_xattr(&amp;mut self, path: &amp;VirtualPath, name: &amp;str) -&gt; Result&lt;(), VfsError&gt;;
    
    /// List extended attributes
    pub fn list_xattrs(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Vec&lt;String&gt;, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<h3 id="63-importexport"><a class="header" href="#63-importexport">6.3 Import/Export</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: StorageBackend&gt; FilesContainer&lt;B&gt; {
    /// Import a file or directory from the host filesystem
    pub fn import_from_host(
        &amp;mut self,
        host_path: &amp;std::path::Path,
        virtual_dest: &amp;VirtualPath,
    ) -&gt; Result&lt;ImportStats, VfsError&gt;;
    
    /// Export a file or directory to the host filesystem
    pub fn export_to_host(
        &amp;self,
        virtual_src: &amp;VirtualPath,
        host_path: &amp;std::path::Path,
    ) -&gt; Result&lt;ExportStats, VfsError&gt;;
}

pub struct ImportStats {
    pub files_imported: u64,
    pub directories_imported: u64,
    pub bytes_imported: u64,
    pub symlinks_imported: u64,
}

pub struct ExportStats {
    pub files_exported: u64,
    pub directories_exported: u64,
    pub bytes_exported: u64,
    pub symlinks_exported: u64,
}
<span class="boring">}</span></code></pre>
<h3 id="64-capacity--lifecycle"><a class="header" href="#64-capacity--lifecycle">6.4 Capacity &amp; Lifecycle</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: StorageBackend&gt; FilesContainer&lt;B&gt; {
    /// Get current capacity usage
    pub fn usage(&amp;self) -&gt; Result&lt;CapacityUsage, VfsError&gt;;
    
    /// Get configured capacity limits
    pub fn limits(&amp;self) -&gt; &amp;CapacityLimits;
    
    /// Get remaining capacity
    pub fn remaining(&amp;self) -&gt; Result&lt;CapacityRemaining, VfsError&gt;;
    
    /// Remove all files and directories (reset to empty)
    pub fn clear(&amp;mut self) -&gt; Result&lt;(), VfsError&gt;;
}

impl&lt;B: StorageBackend + BackendLifecycle&gt; FilesContainer&lt;B&gt; {
    /// Destroy the container and its backing storage
    pub fn destroy(self) -&gt; Result&lt;(), VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="7-path-handling"><a class="header" href="#7-path-handling">7. Path Handling</a></h2>
<h3 id="71-virtualpath-type"><a class="header" href="#71-virtualpath-type">7.1 VirtualPath Type</a></h3>
<p>Paths are <strong>lexical only</strong> — no host filesystem interaction:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A validated virtual filesystem path
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct VirtualPath {
    /// Normalized path string (always starts with `/`)
    inner: String,
}

impl VirtualPath {
    /// Parse and normalize a path
    pub fn new(s: impl AsRef&lt;str&gt;) -&gt; Result&lt;Self, PathError&gt;;
    
    /// The root path
    pub fn root() -&gt; Self;
    
    /// Get path components
    pub fn components(&amp;self) -&gt; impl Iterator&lt;Item = &amp;str&gt;;
    
    /// Get parent path
    pub fn parent(&amp;self) -&gt; Option&lt;VirtualPath&gt;;
    
    /// Get filename (last component)
    pub fn file_name(&amp;self) -&gt; Option&lt;&amp;str&gt;;
    
    /// Join with another path
    pub fn join(&amp;self, other: impl AsRef&lt;str&gt;) -&gt; Result&lt;VirtualPath, PathError&gt;;
    
    /// Check if path is absolute
    pub fn is_absolute(&amp;self) -&gt; bool;  // Always true after parsing
    
    /// Get path depth (e.g., `/a/b/c` = 3)
    pub fn depth(&amp;self) -&gt; usize;
    
    /// As string slice
    pub fn as_str(&amp;self) -&gt; &amp;str;
}
<span class="boring">}</span></code></pre>
<h3 id="72-normalization-rules"><a class="header" href="#72-normalization-rules">7.2 Normalization Rules</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Output</th><th>Rule</th></tr>
</thead>
<tbody>
<tr><td><code>/a/b/c</code></td><td><code>/a/b/c</code></td><td>Already normalized</td></tr>
<tr><td><code>a/b/c</code></td><td><code>/a/b/c</code></td><td>Relative paths made absolute</td></tr>
<tr><td><code>/a//b/c</code></td><td><code>/a/b/c</code></td><td>Collapse multiple slashes</td></tr>
<tr><td><code>/a/./b/c</code></td><td><code>/a/b/c</code></td><td>Remove <code>.</code> components</td></tr>
<tr><td><code>/a/b/../c</code></td><td><code>/a/c</code></td><td>Resolve <code>..</code> lexically</td></tr>
<tr><td><code>/a/b/c/..</code></td><td><code>/a/b</code></td><td>Resolve trailing <code>..</code></td></tr>
<tr><td><code>/..</code></td><td><code>/</code></td><td>Cannot escape root</td></tr>
<tr><td><code>/../../../a</code></td><td><code>/a</code></td><td>All <code>..</code> at root collapse</td></tr>
<tr><td><code>/a/b/</code></td><td><code>/a/b</code></td><td>Remove trailing slash</td></tr>
<tr><td><code>/</code></td><td><code>/</code></td><td>Root is valid</td></tr>
<tr><td>``</td><td>Error</td><td>Empty path invalid</td></tr>
<tr><td><code>/a/\0/b</code></td><td>Error</td><td>Null bytes invalid</td></tr>
</tbody>
</table>
</div>
<h3 id="73-path-errors"><a class="header" href="#73-path-errors">7.3 Path Errors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum PathError {
    #[error("path is empty")]
    Empty,
    
    #[error("path contains null byte")]
    NullByte,
    
    #[error("path component is empty")]
    EmptyComponent,
    
    #[error("path depth {depth} exceeds limit of {limit}")]
    TooDeep { depth: usize, limit: usize },
    
    #[error("path component too long: {length} &gt; {limit}")]
    ComponentTooLong { length: usize, limit: usize },
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="8-filesystem-features"><a class="header" href="#8-filesystem-features">8. Filesystem Features</a></h2>
<h3 id="81-feature-flags"><a class="header" href="#81-feature-flags">8.1 Feature Flags</a></h3>
<p>All advanced features are <strong>opt-in</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ContainerConfig {
    /// Enable symbolic links (default: false)
    pub symlinks: bool,
    
    /// Enable hard links (default: false)
    pub hard_links: bool,
    
    /// Enable permission checking (default: false)
    pub permissions: bool,
    
    /// Enable extended attributes (default: false)
    pub extended_attrs: bool,
    
    // ... limits ...
}
<span class="boring">}</span></code></pre>
<h3 id="82-symbolic-links"><a class="header" href="#82-symbolic-links">8.2 Symbolic Links</a></h3>
<p>When <code>symlinks: true</code>:</p>
<ul>
<li><code>symlink(path, target)</code> creates a symlink</li>
<li><code>read_link(path)</code> returns the raw target</li>
<li>Path resolution follows symlinks (with loop detection)</li>
<li><code>metadata(path)</code> follows symlinks; <code>symlink_metadata(path)</code> does not</li>
</ul>
<p><strong>Resolution algorithm:</strong></p>
<pre><code>resolve(path, follow_count = 0):
    if follow_count &gt; max_symlink_resolution:
        return Error::SymlinkLoop
    
    node = lookup(path)
    
    if node is Symlink:
        target = node.target
        if target.is_relative():
            target = path.parent().join(target)
        return resolve(target, follow_count + 1)
    
    return node
</code></pre>
<h3 id="83-hard-links"><a class="header" href="#83-hard-links">8.3 Hard Links</a></h3>
<p>When <code>hard_links: true</code>:</p>
<ul>
<li><code>hard_link(path, target)</code> creates a new edge to an existing file node</li>
<li><code>link_count</code> in metadata tracks the number of edges</li>
<li>File content is deleted only when <code>link_count</code> reaches 0</li>
<li>Hard links to directories are <strong>not supported</strong> (preventing cycles)</li>
</ul>
<h3 id="84-permissions"><a class="header" href="#84-permissions">8.4 Permissions</a></h3>
<p>When <code>permissions: true</code>:</p>
<ul>
<li>Nodes store <code>mode: u16</code> (Unix-style)</li>
<li><code>set_permissions(path, perms)</code> modifies the mode</li>
<li>All operations check permissions before proceeding</li>
<li>Default mode for new files: <code>0o644</code></li>
<li>Default mode for new directories: <code>0o755</code></li>
</ul>
<p><strong>Note:</strong> There is no concept of user/group — permissions are enforced uniformly. This is a simplification suitable for single-tenant or application-controlled scenarios.</p>
<h3 id="85-extended-attributes"><a class="header" href="#85-extended-attributes">8.5 Extended Attributes</a></h3>
<p>When <code>extended_attrs: true</code>:</p>
<ul>
<li>Arbitrary key-value pairs attached to nodes</li>
<li>Keys are strings (max 255 bytes, validated)</li>
<li>Values are byte arrays (max configurable size)</li>
<li>No namespacing (e.g., <code>user.</code>, <code>system.</code>) — all attrs are equal</li>
</ul>
<hr>
<h2 id="9-capacity-management"><a class="header" href="#9-capacity-management">9. Capacity Management</a></h2>
<h3 id="91-limit-configuration"><a class="header" href="#91-limit-configuration">9.1 Limit Configuration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
pub struct CapacityLimits {
    /// Maximum total storage in bytes (sum of all file sizes)
    pub max_total_size: Option&lt;u64&gt;,
    
    /// Maximum single file size in bytes
    pub max_file_size: Option&lt;u64&gt;,
    
    /// Maximum number of nodes (files + directories + symlinks)
    pub max_node_count: Option&lt;u64&gt;,
    
    /// Maximum entries in a single directory
    pub max_dir_entries: Option&lt;u32&gt;,
    
    /// Maximum path depth (e.g., /a/b/c = depth 3)
    pub max_path_depth: Option&lt;u16&gt;,
    
    /// Maximum filename length in bytes
    pub max_name_length: Option&lt;u16&gt;,
}

impl Default for CapacityLimits {
    fn default() -&gt; Self {
        Self {
            max_total_size: None,            // Unlimited
            max_file_size: Some(1 &lt;&lt; 30),    // 1 GB
            max_node_count: None,            // Unlimited
            max_dir_entries: Some(10_000),   // 10K entries per dir
            max_path_depth: Some(64),        // 64 levels deep
            max_name_length: Some(255),      // 255 bytes
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="92-usage-tracking"><a class="header" href="#92-usage-tracking">9.2 Usage Tracking</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Default)]
pub struct CapacityUsage {
    /// Total bytes used by file contents
    pub total_size: u64,
    
    /// Total number of nodes
    pub node_count: u64,
    
    /// Number of files
    pub file_count: u64,
    
    /// Number of directories
    pub directory_count: u64,
    
    /// Number of symlinks
    pub symlink_count: u64,
}

#[derive(Clone, Debug)]
pub struct CapacityRemaining {
    /// Bytes remaining (None = unlimited)
    pub bytes: Option&lt;u64&gt;,
    
    /// Nodes remaining (None = unlimited)
    pub nodes: Option&lt;u64&gt;,
    
    /// Quick check: can we write anything?
    pub can_write: bool,
}
<span class="boring">}</span></code></pre>
<h3 id="93-enforcement-points"><a class="header" href="#93-enforcement-points">9.3 Enforcement Points</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Limits Checked</th></tr>
</thead>
<tbody>
<tr><td><code>write()</code></td><td><code>max_file_size</code>, <code>max_total_size</code></td></tr>
<tr><td><code>append()</code></td><td><code>max_file_size</code>, <code>max_total_size</code></td></tr>
<tr><td><code>mkdir()</code></td><td><code>max_node_count</code>, <code>max_path_depth</code>, <code>max_dir_entries</code> (parent)</td></tr>
<tr><td><code>symlink()</code></td><td><code>max_node_count</code>, <code>max_dir_entries</code> (parent)</td></tr>
<tr><td><code>hard_link()</code></td><td><code>max_dir_entries</code> (parent)</td></tr>
<tr><td><code>copy()</code></td><td>Same as <code>write()</code></td></tr>
<tr><td><code>rename()</code></td><td><code>max_dir_entries</code> (destination parent), <code>max_name_length</code></td></tr>
<tr><td>Path parsing</td><td><code>max_path_depth</code>, <code>max_name_length</code></td></tr>
</tbody>
</table>
</div>
<h3 id="94-capacity-errors"><a class="header" href="#94-capacity-errors">9.4 Capacity Errors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum CapacityError {
    #[error("total storage limit exceeded: {used} / {limit} bytes")]
    TotalSizeExceeded { used: u64, limit: u64 },
    
    #[error("file size {size} exceeds limit of {limit} bytes")]
    FileSizeExceeded { size: u64, limit: u64 },
    
    #[error("node count limit exceeded: {count} / {limit}")]
    NodeCountExceeded { count: u64, limit: u64 },
    
    #[error("directory has {count} entries, limit is {limit}")]
    DirEntriesExceeded { count: u32, limit: u32 },
    
    #[error("path depth {depth} exceeds limit of {limit}")]
    PathDepthExceeded { depth: u16, limit: u16 },
    
    #[error("name length {length} bytes exceeds limit of {limit}")]
    NameLengthExceeded { length: u16, limit: u16 },
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="10-error-handling"><a class="header" href="#10-error-handling">10. Error Handling</a></h2>
<h3 id="101-error-hierarchy"><a class="header" href="#101-error-hierarchy">10.1 Error Hierarchy</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Top-level error type for FilesContainer operations
#[derive(Debug, thiserror::Error)]
pub enum VfsError {
    #[error("path error: {0}")]
    Path(#[from] PathError),
    
    #[error("capacity error: {0}")]
    Capacity(#[from] CapacityError),
    
    #[error("backend error: {0}")]
    Backend(#[from] BackendError),
    
    #[error("not found: {0}")]
    NotFound(VirtualPath),
    
    #[error("already exists: {0}")]
    AlreadyExists(VirtualPath),
    
    #[error("not a file: {0}")]
    NotAFile(VirtualPath),
    
    #[error("not a directory: {0}")]
    NotADirectory(VirtualPath),
    
    #[error("not a symlink: {0}")]
    NotASymlink(VirtualPath),
    
    #[error("directory not empty: {0}")]
    DirectoryNotEmpty(VirtualPath),
    
    #[error("symlink loop detected at: {0}")]
    SymlinkLoop(VirtualPath),
    
    #[error("cannot create hard link to directory")]
    HardLinkToDirectory,
    
    #[error("feature not enabled: {0}")]
    FeatureNotEnabled(&amp;'static str),
    
    #[error("permission denied: {0}")]
    PermissionDenied(VirtualPath),
    
    #[error("invalid operation: {0}")]
    InvalidOperation(String),
}
<span class="boring">}</span></code></pre>
<h3 id="102-error-context"><a class="header" href="#102-error-context">10.2 Error Context</a></h3>
<p>Consider adding context via extension trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait VfsResultExt&lt;T&gt; {
    fn with_path(self, path: &amp;VirtualPath) -&gt; Result&lt;T, VfsError&gt;;
}

impl&lt;T&gt; VfsResultExt&lt;T&gt; for Result&lt;T, BackendError&gt; {
    fn with_path(self, path: &amp;VirtualPath) -&gt; Result&lt;T, VfsError&gt; {
        self.map_err(|e| match e {
            BackendError::NodeNotFound(_) =&gt; VfsError::NotFound(path.clone()),
            other =&gt; VfsError::Backend(other),
        })
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="11-crate-structure"><a class="header" href="#11-crate-structure">11. Crate Structure</a></h2>
<h3 id="111-workspace-layout"><a class="header" href="#111-workspace-layout">11.1 Workspace Layout</a></h3>
<pre><code>anyfs-container/
├── Cargo.toml              # Workspace manifest
├── README.md
├── LICENSE
│
├── anyfs/               # Core traits and types
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── backend.rs      # StorageBackend, Transaction, Snapshot traits
│       ├── types.rs        # NodeId, ContentId, ChunkId, Name
│       ├── node.rs         # NodeKind, NodeRecord, NodeMetadata
│       ├── edge.rs         # Edge
│       ├── path.rs         # VirtualPath
│       ├── error.rs        # BackendError, PathError
│       └── limits.rs       # CapacityLimits
│
├── vfs-sqlite/             # SQLite backend
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── backend.rs      # SqliteBackend implementation
│       ├── schema.rs       # SQL schema definitions
│       └── migrations.rs   # Schema migrations
│
├── vfs-memory/             # In-memory backend
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs          # MemoryBackend implementation
│
├── vfs-fs/                 # Host filesystem backend
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs          # FsBackend implementation (via strict-path)
│
└── vfs/                    # High-level API (batteries included)
    ├── Cargo.toml
    └── src/
        ├── lib.rs
        ├── container.rs    # FilesContainer&lt;B&gt;
        ├── builder.rs      # ContainerBuilder
        ├── operations.rs   # File operation implementations
        ├── resolution.rs   # Path resolution, symlink following
        ├── import_export.rs # Host filesystem import/export
        └── error.rs        # VfsError, CapacityError
</code></pre>
<h3 id="112-dependency-graph"><a class="header" href="#112-dependency-graph">11.2 Dependency Graph</a></h3>
<pre><code>                    ┌─────────┐
                    │   vfs   │  (high-level API)
                    └────┬────┘
                         │
          ┌──────────────┼──────────────┐
          │              │              │
          ▼              ▼              ▼
    ┌──────────┐  ┌──────────┐  ┌──────────┐
    │vfs-sqlite│  │vfs-memory│  │  vfs-fs  │
    └────┬─────┘  └────┬─────┘  └────┬─────┘
          │              │              │
          └──────────────┼──────────────┘
                         │
                         ▼
                   ┌──────────┐
                   │ anyfs │  (traits, types)
                   └──────────┘
</code></pre>
<h3 id="113-feature-flags"><a class="header" href="#113-feature-flags">11.3 Feature Flags</a></h3>
<p><strong><code>vfs</code> crate:</strong></p>
<pre><code class="language-toml">[features]
default = ["sqlite", "memory"]

# Include backends
sqlite = ["dep:vfs-sqlite"]
memory = ["dep:vfs-memory"]
fs = ["dep:vfs-fs"]

# Enable all filesystem features by default
full-features = []
</code></pre>
<h3 id="114-re-exports"><a class="header" href="#114-re-exports">11.4 Re-exports</a></h3>
<p>The <code>vfs</code> crate re-exports everything for convenience:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// vfs/src/lib.rs

pub use anyfs::{
    // Traits
    StorageBackend, BackendLifecycle, Snapshot, Transaction,
    
    // Types
    NodeId, ContentId, ChunkId, Name, Edge,
    NodeKind, NodeRecord, NodeMetadata,
    VirtualPath, PathError,
    BackendError,
    CapacityLimits,
    CHUNK_SIZE,
};

// Container API
pub use crate::container::FilesContainer;
pub use crate::builder::ContainerBuilder;
pub use crate::error::{VfsError, CapacityError};

// Backends (conditional)
#[cfg(feature = "sqlite")]
pub use vfs_sqlite::SqliteBackend;

#[cfg(feature = "memory")]
pub use vfs_memory::MemoryBackend;

#[cfg(feature = "fs")]
pub use vfs_fs::FsBackend;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="12-security-considerations"><a class="header" href="#12-security-considerations">12. Security Considerations</a></h2>
<h3 id="121-threat-model"><a class="header" href="#121-threat-model">12.1 Threat Model</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Mitigation</th></tr>
</thead>
<tbody>
<tr><td><strong>Host filesystem escape</strong></td><td>Paths are lexical strings, never resolved against host FS. No <code>std::fs</code> in path handling.</td></tr>
<tr><td><strong>Path traversal via <code>..</code></strong></td><td>Lexical normalization prevents escaping root. <code>/../../etc/passwd</code> → <code>/etc/passwd</code> (inside VFS).</td></tr>
<tr><td><strong>Symlink attacks</strong></td><td>Resolution has configurable max depth. Loops are detected.</td></tr>
<tr><td><strong>Denial of service</strong></td><td>Capacity limits prevent unbounded growth.</td></tr>
<tr><td><strong>Billion laughs (zip bomb)</strong></td><td>Content is stored as-is. No automatic decompression.</td></tr>
<tr><td><strong>Code execution</strong></td><td>No execution capability. Content is data only.</td></tr>
</tbody>
</table>
</div>
<h3 id="122-trust-boundaries"><a class="header" href="#122-trust-boundaries">12.2 Trust Boundaries</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                    Trusted Zone                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │  FilesContainer (enforces policy)               │   │
│  │  ┌─────────────────────────────────────────┐    │   │
│  │  │  StorageBackend (dumb storage)          │    │   │
│  │  └─────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              Backend-Specific Storage                   │
│  SQLite file / Memory / Controlled host directory       │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="123-backend-security-notes"><a class="header" href="#123-backend-security-notes">12.3 Backend Security Notes</a></h3>
<p><strong>SqliteBackend:</strong></p>
<ul>
<li>Database file should be in a controlled directory</li>
<li>Consider SQLite encryption extension for sensitive data</li>
<li>WAL mode recommended for crash safety</li>
</ul>
<p><strong>MemoryBackend:</strong></p>
<ul>
<li>Data lost on drop — suitable for testing/ephemeral use</li>
<li>No persistence security concerns</li>
</ul>
<p><strong>FsBackend:</strong></p>
<ul>
<li>Uses <code>strict-path</code> to prevent escape from configured root</li>
<li>Root directory must be carefully chosen</li>
<li>Inherits host filesystem permissions</li>
</ul>
<hr>
<h2 id="13-implementation-plan"><a class="header" href="#13-implementation-plan">13. Implementation Plan</a></h2>
<h3 id="131-phases"><a class="header" href="#131-phases">13.1 Phases</a></h3>
<pre><code>Phase 1: Core Foundation
├── anyfs crate
│   ├── [ ] Types: NodeId, ContentId, ChunkId, Name
│   ├── [ ] Node types: NodeKind, NodeRecord, NodeMetadata
│   ├── [ ] Edge type
│   ├── [ ] VirtualPath with normalization
│   ├── [ ] StorageBackend trait
│   ├── [ ] Transaction, Snapshot traits
│   ├── [ ] BackendLifecycle trait
│   ├── [ ] BackendError enum
│   └── [ ] CapacityLimits struct

Phase 2: Memory Backend
├── vfs-memory crate
│   ├── [ ] MemoryBackend struct
│   ├── [ ] In-memory node/edge storage
│   ├── [ ] In-memory content storage
│   ├── [ ] Transaction support (copy-on-write or mutex)
│   └── [ ] Unit tests

Phase 3: Basic Container
├── vfs crate (partial)
│   ├── [ ] FilesContainer struct
│   ├── [ ] ContainerBuilder
│   ├── [ ] Basic operations: read, write, mkdir, remove, list
│   ├── [ ] Path resolution (no symlinks yet)
│   ├── [ ] VfsError enum
│   └── [ ] Integration tests with MemoryBackend

Phase 4: SQLite Backend
├── vfs-sqlite crate
│   ├── [ ] Schema design
│   ├── [ ] SqliteBackend struct
│   ├── [ ] Transaction via SQLite transactions
│   ├── [ ] Lifecycle: create, open, open_or_create, destroy
│   ├── [ ] Migrations strategy
│   └── [ ] Integration tests

Phase 5: Advanced Features
├── vfs crate (complete)
│   ├── [ ] Symlink support (feature-gated)
│   ├── [ ] Symlink resolution with loop detection
│   ├── [ ] Hard link support (feature-gated)
│   ├── [ ] Link count management
│   ├── [ ] Permissions (feature-gated)
│   ├── [ ] Extended attributes (feature-gated)
│   └── [ ] Metadata operations

Phase 6: Capacity Management
├── vfs crate (capacity)
│   ├── [ ] Limit enforcement on all operations
│   ├── [ ] Usage tracking (aggregates in metadata)
│   ├── [ ] usage() and remaining() methods
│   └── [ ] CapacityError handling

Phase 7: Import/Export
├── vfs crate (import/export)
│   ├── [ ] import_from_host
│   ├── [ ] export_to_host
│   ├── [ ] Preserve metadata on import
│   └── [ ] Handle symlinks appropriately

Phase 8: Filesystem Backend
├── vfs-fs crate
│   ├── [ ] FsBackend using strict-path VirtualRoot
│   ├── [ ] Map nodes/edges to directories/files
│   ├── [ ] Content storage as files
│   └── [ ] Integration tests

Phase 9: Polish
├── Documentation
│   ├── [ ] API documentation (rustdoc)
│   ├── [ ] README with examples
│   ├── [ ] Architecture documentation
│   └── [ ] Security considerations
├── Testing
│   ├── [ ] Conformance test suite for backends
│   ├── [ ] Property-based tests (proptest)
│   ├── [ ] Fuzz testing for path parsing
│   └── [ ] Benchmarks
└── Release
    ├── [ ] Publish to crates.io
    └── [ ] Announce
</code></pre>
<h3 id="132-milestone-summary"><a class="header" href="#132-milestone-summary">13.2 Milestone Summary</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Milestone</th><th>Deliverable</th><th>Est. Effort</th></tr>
</thead>
<tbody>
<tr><td>M1: Core Types</td><td><code>anyfs</code> crate publishable</td><td>1 week</td></tr>
<tr><td>M2: Memory Backend</td><td><code>vfs-memory</code> crate with tests</td><td>1 week</td></tr>
<tr><td>M3: Basic Container</td><td>Read/write/mkdir/remove working</td><td>2 weeks</td></tr>
<tr><td>M4: SQLite Backend</td><td><code>vfs-sqlite</code> crate with tests</td><td>2 weeks</td></tr>
<tr><td>M5: Symlinks + Hard Links</td><td>Feature-gated, fully tested</td><td>1 week</td></tr>
<tr><td>M6: Capacity + Permissions</td><td>Limits enforced, permissions checked</td><td>1 week</td></tr>
<tr><td>M7: Import/Export</td><td>Host FS interop</td><td>1 week</td></tr>
<tr><td>M8: FS Backend</td><td><code>vfs-fs</code> crate with tests</td><td>1 week</td></tr>
<tr><td>M9: Release</td><td>Docs, polish, publish</td><td>1 week</td></tr>
</tbody>
</table>
</div>
<p><strong>Total estimated effort: ~11 weeks</strong></p>
<h3 id="133-testing-strategy"><a class="header" href="#133-testing-strategy">13.3 Testing Strategy</a></h3>
<p><strong>Unit tests:</strong></p>
<ul>
<li>Every module has tests</li>
<li>VirtualPath normalization: exhaustive edge cases</li>
<li>Name validation: all invalid inputs rejected</li>
</ul>
<p><strong>Backend conformance tests:</strong></p>
<ul>
<li>Macro generates test suite</li>
<li>Every backend must pass identical tests</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// anyfs/src/testing.rs

#[macro_export]
macro_rules! backend_conformance_tests {
    ($backend_factory:expr) =&gt; {
        #[test]
        fn test_insert_and_get_node() {
            let mut backend = $backend_factory();
            // ...
        }
        
        #[test]
        fn test_transaction_rollback() {
            // ...
        }
        
        // ... 50+ tests
    };
}

// vfs-memory/src/lib.rs
#[cfg(test)]
mod tests {
    anyfs::backend_conformance_tests!(|| MemoryBackend::new());
}
<span class="boring">}</span></code></pre>
<p><strong>Integration tests:</strong></p>
<ul>
<li>Full workflows through FilesContainer</li>
<li>Symlink resolution edge cases</li>
<li>Capacity limit enforcement</li>
</ul>
<p><strong>Property-based tests (proptest):</strong></p>
<ul>
<li>Arbitrary path strings normalize correctly</li>
<li>Arbitrary operations maintain invariants</li>
</ul>
<p><strong>Fuzz tests:</strong></p>
<ul>
<li>Path parsing doesn’t panic</li>
<li>Backend operations don’t panic</li>
</ul>
<hr>
<h2 id="14-open-questions"><a class="header" href="#14-open-questions">14. Open Questions</a></h2>
<h3 id="141-decisions-needed"><a class="header" href="#141-decisions-needed">14.1 Decisions Needed</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ID</th><th>Question</th><th>Options</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Q1</td><td>Should symlink targets be validated on creation?</td><td>(a) Yes — must be valid path, (b) No — store as-is</td><td><strong>(b)</strong> — matches POSIX, allows dangling symlinks</td></tr>
<tr><td>Q2</td><td>Async support?</td><td>(a) Sync only, (b) Async trait now, (c) Separate async trait later</td><td><strong>(c)</strong> — start simple, add when needed</td></tr>
<tr><td>Q3</td><td>Should <code>copy()</code> preserve hard links within a tree?</td><td>(a) Yes — complex, (b) No — each copy is independent</td><td><strong>(b)</strong> — simpler, predictable</td></tr>
<tr><td>Q4</td><td>Content-addressable storage?</td><td>(a) Yes — deduplicate, (b) No — each file has own content</td><td><strong>(b) initially</strong> — can add later as optimization</td></tr>
<tr><td>Q5</td><td>How to handle concurrent access?</td><td>(a) Single-threaded only, (b) Mutex-based, (c) Backend decides</td><td><strong>(c)</strong> — SQLite has its own locking</td></tr>
<tr><td>Q6</td><td>Extended attr size limit?</td><td>Specific number</td><td><strong>64 KB per attr</strong> — generous but bounded</td></tr>
<tr><td>Q7</td><td>Should backends expose raw handles?</td><td>(a) Yes — escape hatch, (b) No — pure abstraction</td><td><strong>(a)</strong> — power users need it</td></tr>
</tbody>
</table>
</div>
<h3 id="142-future-considerations-deferred"><a class="header" href="#142-future-considerations-deferred">14.2 Future Considerations Deferred</a></h3>
<ul>
<li>Streaming read/write API</li>
<li>Async backend trait</li>
<li>Watch/notify on changes</li>
<li>Compression (backend-internal)</li>
<li>Encryption (backend-internal)</li>
<li>Distributed backends</li>
<li>FUSE integration (separate crate, not part of core)</li>
</ul>
<hr>
<h2 id="15-future-considerations"><a class="header" href="#15-future-considerations">15. Future Considerations</a></h2>
<h3 id="151-async-support"><a class="header" href="#151-async-support">15.1 Async Support</a></h3>
<p>When needed, add a parallel trait hierarchy:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait AsyncStorageBackend: Send + Sync {
    async fn transact&lt;F, T&gt;(&amp;mut self, f: F) -&gt; Result&lt;T, BackendError&gt;
    where
        F: for&lt;'a&gt; FnOnce(&amp;'a mut dyn AsyncTransaction) -&gt; BoxFuture&lt;'a, Result&lt;T, BackendError&gt;&gt; + Send;
    
    async fn snapshot(&amp;self) -&gt; Box&lt;dyn AsyncSnapshot + '_&gt;;
}
<span class="boring">}</span></code></pre>
<p>FilesContainer becomes generic over sync/async.</p>
<h3 id="152-content-addressable-storage"><a class="header" href="#152-content-addressable-storage">15.2 Content-Addressable Storage</a></h3>
<p>For deduplication:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ContentId(pub(crate) [u8; 32]);  // SHA-256

impl ContentId {
    pub fn from_data(data: &amp;[u8]) -&gt; Self {
        let hash = sha256(data);
        ContentId(hash)
    }
}
<span class="boring">}</span></code></pre>
<p>Backend stores content by hash. Multiple nodes can reference same ContentId.</p>
<h3 id="153-streaming-api"><a class="header" href="#153-streaming-api">15.3 Streaming API</a></h3>
<p>For large files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: StorageBackend&gt; FilesContainer&lt;B&gt; {
    pub fn open_read(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;impl Read, VfsError&gt;;
    pub fn open_write(&amp;mut self, path: &amp;VirtualPath) -&gt; Result&lt;impl Write, VfsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>Requires backend support for streaming chunks.</p>
<h3 id="154-change-notifications"><a class="header" href="#154-change-notifications">15.4 Change Notifications</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: StorageBackend&gt; FilesContainer&lt;B&gt; {
    pub fn watch(&amp;self, path: &amp;VirtualPath) -&gt; Result&lt;Receiver&lt;ChangeEvent&gt;, VfsError&gt;;
}

pub enum ChangeEvent {
    Created(VirtualPath),
    Modified(VirtualPath),
    Deleted(VirtualPath),
    Renamed { from: VirtualPath, to: VirtualPath },
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<h3 id="a-sqlite-schema-reference"><a class="header" href="#a-sqlite-schema-reference">A. SQLite Schema (Reference)</a></h3>
<pre><code class="language-sql">-- Schema version for migrations
CREATE TABLE schema_version (
    version INTEGER PRIMARY KEY
);

-- Nodes (files, directories, symlinks)
CREATE TABLE nodes (
    id INTEGER PRIMARY KEY,
    kind INTEGER NOT NULL,          -- 0=file, 1=directory, 2=symlink
    content_id INTEGER,             -- FK to contents (files only)
    size INTEGER DEFAULT 0,         -- file size in bytes
    symlink_target TEXT,            -- symlink target path
    link_count INTEGER DEFAULT 1,   -- hard link count
    permissions INTEGER,            -- mode bits (optional)
    created_at INTEGER,             -- unix timestamp ms
    modified_at INTEGER,
    accessed_at INTEGER
);

-- Directory entries (edges)
CREATE TABLE edges (
    parent_id INTEGER NOT NULL REFERENCES nodes(id),
    name TEXT NOT NULL,
    child_id INTEGER NOT NULL REFERENCES nodes(id),
    PRIMARY KEY (parent_id, name)
);

CREATE INDEX idx_edges_child ON edges(child_id);

-- Content chunks
CREATE TABLE chunks (
    content_id INTEGER NOT NULL,
    chunk_index INTEGER NOT NULL,
    data BLOB NOT NULL,
    PRIMARY KEY (content_id, chunk_index)
);

-- Extended attributes
CREATE TABLE xattrs (
    node_id INTEGER NOT NULL REFERENCES nodes(id),
    name TEXT NOT NULL,
    value BLOB NOT NULL,
    PRIMARY KEY (node_id, name)
);

-- Container metadata (for tracking aggregates)
CREATE TABLE metadata (
    key TEXT PRIMARY KEY,
    value INTEGER
);
-- Keys: 'total_size', 'node_count', 'next_node_id', 'next_content_id'

-- Root node is always ID 1
INSERT INTO nodes (id, kind, link_count) VALUES (1, 1, 1);
INSERT INTO metadata (key, value) VALUES ('next_node_id', 2);
INSERT INTO metadata (key, value) VALUES ('next_content_id', 1);
INSERT INTO metadata (key, value) VALUES ('total_size', 0);
INSERT INTO metadata (key, value) VALUES ('node_count', 1);
</code></pre>
<h3 id="b-memory-backend-data-structures-reference"><a class="header" href="#b-memory-backend-data-structures-reference">B. Memory Backend Data Structures (Reference)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MemoryBackend {
    nodes: HashMap&lt;NodeId, NodeRecord&gt;,
    edges: HashMap&lt;(NodeId, String), NodeId&gt;,
    children: HashMap&lt;NodeId, HashSet&lt;String&gt;&gt;,  // For list_edges
    chunks: HashMap&lt;ChunkId, Vec&lt;u8&gt;&gt;,
    next_node_id: u64,
    next_content_id: u64,
    metadata: ContainerMetadata,
}

struct ContainerMetadata {
    total_size: u64,
    node_count: u64,
}
<span class="boring">}</span></code></pre>
<h3 id="c-glossary"><a class="header" href="#c-glossary">C. Glossary</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Term</th><th>Definition</th></tr>
</thead>
<tbody>
<tr><td><strong>Backend</strong></td><td>Implementation of <code>StorageBackend</code> trait; handles persistence</td></tr>
<tr><td><strong>Node</strong></td><td>A filesystem entity (file, directory, or symlink)</td></tr>
<tr><td><strong>Edge</strong></td><td>A named parent→child relationship</td></tr>
<tr><td><strong>Content</strong></td><td>Binary data stored separately from node metadata</td></tr>
<tr><td><strong>Chunk</strong></td><td>Fixed-size piece of content (64 KB)</td></tr>
<tr><td><strong>Container</strong></td><td>A <code>FilesContainer</code> instance; the high-level API</td></tr>
<tr><td><strong>Virtual Path</strong></td><td>A path within the virtual filesystem (not on host)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="document-history"><a class="header" href="#document-history">Document History</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Version</th><th>Date</th><th>Author</th><th>Changes</th></tr>
</thead>
<tbody>
<tr><td>0.1.0-draft</td><td>2025-XX-XX</td><td>—</td><td>Initial draft</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="reviewers"><a class="header" href="#reviewers">Reviewers</a></h2>
<ul>
<li><input disabled="" type="checkbox"> Reviewer 1: _________________</li>
<li><input disabled="" type="checkbox"> Reviewer 2: _________________</li>
<li><input disabled="" type="checkbox"> Reviewer 3: _________________</li>
</ul>
<p><strong>Review deadline:</strong> ____-<strong>-</strong></p>
<hr>
<p><em>End of document.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="historical-vfs-documentation-review-findings"><a class="header" href="#historical-vfs-documentation-review-findings">Historical: VFS Documentation Review Findings</a></h1>
<blockquote>
<p>This review predates the current AnyFS design and references an earlier architecture (<code>vfs-switchable</code> naming, etc.).</p>
<p>The current AnyFS design uses three crates: <code>anyfs-traits</code>, <code>anyfs</code>, <code>anyfs-container</code> with a path-based <code>VfsBackend</code> trait.</p>
<p>For current design, see:</p>
<ul>
<li><code>book/src/architecture/adrs.md</code></li>
<li><code>book/src/architecture/design-overview.md</code></li>
</ul>
</blockquote>
<h2 id="executive-summary-2"><a class="header" href="#executive-summary-2">Executive Summary</a></h2>
<p>The documentation is currently in a <strong>fractured state</strong> with significant contradictions between the “Design” documents and the “User Guide” documents. The ecosystem appears to be transitioning from a monolithic <code>vfs</code> crate concept to a split <code>vfs-switchable</code>/<code>vfs-container</code> architecture, but the documentation has not been fully synchronized.</p>
<h2 id="critical-inconsistencies"><a class="header" href="#critical-inconsistencies">Critical Inconsistencies</a></h2>
<h3 id="1-crate-architecture--naming"><a class="header" href="#1-crate-architecture--naming">1. Crate Architecture &amp; Naming</a></h3>
<ul>
<li><strong>Conflict</strong>:
<ul>
<li><code>02-api-quick-reference.md</code> and <code>05-getting-started-guide.md</code> instruct users to depend on a single <code>vfs</code> crate (v0.1).</li>
<li><code>11-restructured-design.md</code> and <code>vfs-design.md</code> explicitly define a split architecture: <code>vfs-switchable</code> (core trait) and <code>vfs-container</code> (isolation).</li>
</ul>
</li>
<li><strong>Issue</strong>: The name <code>vfs</code> is already an existing, popular crate on crates.io. <code>vfs-design.md</code> even lists the <code>vfs</code> crate as an alternative/competitor in the Appendix, creating a confusing circular reference where the docs tell you to use the competitor’s name.</li>
</ul>
<h3 id="2-core-api-signature-vfsbackend"><a class="header" href="#2-core-api-signature-vfsbackend">2. Core API Signature (<code>VfsBackend</code>)</a></h3>
<ul>
<li><strong>Conflict</strong>:
<ul>
<li><code>vfs-design.md</code> (v0.2.0) defines the core trait methods as taking <code>impl AsRef&lt;Path&gt;</code>, arguing this is “idiomatic Rust”.</li>
<li><code>11-restructured-design.md</code> defines the core trait methods as taking <code>&amp;VirtualPath</code>.</li>
</ul>
</li>
<li><strong>Impact</strong>: This is a fundamental design divergence.
<ul>
<li><code>impl AsRef&lt;Path&gt;</code> implies the backend is responsible for path validation and safety.</li>
<li><code>&amp;VirtualPath</code> implies the caller (Container) guarantees safety/normalization <em>before</em> the backend sees it.</li>
<li><strong>Verdict</strong>: <code>11-restructured-design.md</code> (using <code>VirtualPath</code>) aligns better with the stated goal of “Containment” and safety, whereas <code>vfs-design.md</code> seems to cling to standard library interoperability at the cost of safety guarantees.</li>
</ul>
</li>
</ul>
<h3 id="3-path-resolution-strategy"><a class="header" href="#3-path-resolution-strategy">3. Path Resolution Strategy</a></h3>
<ul>
<li><strong>Conflict</strong>:
<ul>
<li><code>04-ADR-004</code> and <code>11-restructured-design.md</code> advocate for “Lexical Path Resolution” using <code>VirtualPath</code> to prevent escapes.</li>
<li><code>vfs-design.md</code> suggests <code>VRootFsBackend</code> passes paths <em>directly</em> to <code>strict-path</code>, but strict-path usually requires a specific path type or setup. The <code>impl AsRef&lt;Path&gt;</code> signature in <code>vfs-design.md</code> obscures <em>how</em> the backend ensures safety if it accepts raw strings.</li>
</ul>
</li>
</ul>
<h2 id="missing-or-outdated-content"><a class="header" href="#missing-or-outdated-content">Missing or Outdated Content</a></h2>
<ul>
<li><strong>Document Gap</strong>: File <code>07</code> is missing from the numbered sequence.</li>
<li><strong>Phantom Versioning</strong>: “v0.1” is referenced in guides, but “v0.2.0” is the version of the design doc. The project seems to be pre-alpha but docs imply an existing v0.1 release.</li>
</ul>
<h2 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h2>
<ol>
<li><strong>Standardize on the Split Architecture</strong>: Adopt the <code>vfs-switchable</code> and <code>vfs-container</code> structure from <code>11-restructured-design.md</code>.</li>
<li><strong>Rename the “User-Facing” Crate</strong>: Avoid <code>vfs</code>. If <code>vfs-container</code> is the main entry point, use that or a new unique name (e.g., <code>tektite-vfs</code>, <code>vfs-isolated</code>).</li>
<li><strong>Resolve the Trait Signature</strong>: Go with <code>&amp;VirtualPath</code>. It provides stronger type safety boundaries and prevents backends from mishandling paths (e.g., resolving <code>..</code> incorrectly).
<ul>
<li><em>Correction needed</em>: Update <code>vfs-design.md</code> to reflect <code>&amp;VirtualPath</code> instead of <code>impl AsRef&lt;Path&gt;</code>.</li>
</ul>
</li>
<li><strong>Update Guides</strong>: Rewrite <code>02</code> and <code>05</code> to reflect the multi-crate setup (or a workspace) and correct dependency names.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
